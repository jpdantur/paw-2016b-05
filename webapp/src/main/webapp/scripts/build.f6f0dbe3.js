if (function(global, factory) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    } : factory(global);
}("undefined" != typeof window ? window : this, function(window, noGlobal) {
    function DOMEval(code, doc) {
        doc = doc || document;
        var script = doc.createElement("script");
        script.text = code, doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = jQuery.type(obj);
        return "function" !== type && !jQuery.isWindow(obj) && ("array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj);
    }
    function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    function winnow(elements, qualifier, not) {
        return jQuery.isFunction(qualifier) ? jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
        }) : qualifier.nodeType ? jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        }) : "string" != typeof qualifier ? jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
        }) : risSimple.test(qualifier) ? jQuery.filter(qualifier, elements, not) : (qualifier = jQuery.filter(qualifier, elements), 
        jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not && 1 === elem.nodeType;
        }));
    }
    function sibling(cur, dir) {
        for (;(cur = cur[dir]) && 1 !== cur.nodeType; ) ;
        return cur;
    }
    function createOptions(options) {
        var object = {};
        return jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = !0;
        }), object;
    }
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            value && jQuery.isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && jQuery.isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.apply(void 0, [ value ].slice(noValue));
        } catch (value) {
            reject.apply(void 0, [ value ]);
        }
    }
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed), window.removeEventListener("load", completed), 
        jQuery.ready();
    }
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    function getData(data) {
        return "true" === data || "false" !== data && ("null" === data ? null : data === +data + "" ? +data : rbrace.test(data) ? JSON.parse(data) : data);
    }
    function dataAttr(elem, key, data) {
        var name;
        if (void 0 === data && 1 === elem.nodeType) if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(), 
        "string" == typeof (data = elem.getAttribute(name))) {
            try {
                data = getData(data);
            } catch (e) {}
            dataUser.set(elem, key, data);
        } else data = void 0;
        return data;
    }
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3], valueParts = valueParts || [], initialInUnit = +initial || 1;
            do {
                scale = scale || ".5", initialInUnit /= scale, jQuery.style(elem, prop, initialInUnit + unit);
            } while (scale !== (scale = currentValue() / initial) && 1 !== scale && --maxIterations);
        }
        return valueParts && (initialInUnit = +initialInUnit || +initial || 0, adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2], 
        tween && (tween.unit = unit, tween.start = initialInUnit, tween.end = adjusted)), 
        adjusted;
    }
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        return display || (temp = doc.body.appendChild(doc.createElement(nodeName)), display = jQuery.css(temp, "display"), 
        temp.parentNode.removeChild(temp), "none" === display && (display = "block"), defaultDisplayMap[nodeName] = display, 
        display);
    }
    function showHide(elements, show) {
        for (var display, elem, values = [], index = 0, length = elements.length; index < length; index++) elem = elements[index], 
        elem.style && (display = elem.style.display, show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null, 
        values[index] || (elem.style.display = "")), "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none", 
        dataPriv.set(elem, "display", display)));
        for (index = 0; index < length; index++) null != values[index] && (elements[index].style.display = values[index]);
        return elements;
    }
    function getAll(context, tag) {
        var ret;
        return ret = void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : void 0 !== context.querySelectorAll ? context.querySelectorAll(tag || "*") : [], 
        void 0 === tag || tag && nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function setGlobalEval(elems, refElements) {
        for (var i = 0, l = elems.length; i < l; i++) dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
    function buildFragment(elems, context, scripts, selection, ignored) {
        for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; i < l; i++) if ((elem = elems[i]) || 0 === elem) if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem); else if (rhtml.test(elem)) {
            for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2], 
            j = wrap[0]; j--; ) tmp = tmp.lastChild;
            jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        } else nodes.push(context.createTextNode(elem));
        for (fragment.textContent = "", i = 0; elem = nodes[i++]; ) if (selection && jQuery.inArray(elem, selection) > -1) ignored && ignored.push(elem); else if (contains = jQuery.contains(elem.ownerDocument, elem), 
        tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), 
        scripts) for (j = 0; elem = tmp[j++]; ) rscriptType.test(elem.type || "") && scripts.push(elem);
        return fragment;
    }
    function returnTrue() {
        return !0;
    }
    function returnFalse() {
        return !1;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if ("object" == typeof types) {
            "string" != typeof selector && (data = data || selector, selector = void 0);
            for (type in types) on(elem, type, selector, data, types[type], one);
            return elem;
        }
        if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, 
        data = void 0) : (fn = data, data = selector, selector = void 0)), !1 === fn) fn = returnFalse; else if (!fn) return elem;
        return 1 === one && (origFn = fn, fn = function(event) {
            return jQuery().off(event), origFn.apply(this, arguments);
        }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    function manipulationTarget(elem, content) {
        return nodeName(elem, "table") && nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? jQuery(">tbody", elem)[0] || elem : elem;
    }
    function disableScript(elem) {
        return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        return match ? elem.type = match[1] : elem.removeAttribute("type"), elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (1 === dest.nodeType) {
            if (dataPriv.hasData(src) && (pdataOld = dataPriv.access(src), pdataCur = dataPriv.set(dest, pdataOld), 
            events = pdataOld.events)) {
                delete pdataCur.handle, pdataCur.events = {};
                for (type in events) for (i = 0, l = events[type].length; i < l; i++) jQuery.event.add(dest, type, events[type][i]);
            }
            dataUser.hasData(src) && (udataOld = dataUser.access(src), udataCur = jQuery.extend({}, udataOld), 
            dataUser.set(dest, udataCur));
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : "input" !== nodeName && "textarea" !== nodeName || (dest.defaultValue = src.defaultValue);
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return collection.each(function(index) {
            var self = collection.eq(index);
            isFunction && (args[0] = value.call(this, index, self.html())), domManip(self, args, callback, ignored);
        });
        if (l && (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored), 
        first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), 
        first || ignored)) {
            for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; i < l; i++) node = fragment, 
            i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), 
            callback.call(collection[i], node, i);
            if (hasScripts) for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), 
            i = 0; i < hasScripts; i++) node = scripts[i], rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : DOMEval(node.textContent.replace(rcleanScript, ""), doc));
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++) keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)), 
        node.parentNode && (keepData && jQuery.contains(node.ownerDocument, node) && setGlobalEval(getAll(node, "script")), 
        node.parentNode.removeChild(node));
        return elem;
    }
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name], 
        "" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), 
        !support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, 
        minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, 
        ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), 
        void 0 !== ret ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    function vendorPropName(name) {
        if (name in emptyStyle) return name;
        for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--; ) if ((name = cssPrefixes[i] + capName) in emptyStyle) return name;
    }
    function finalPropName(name) {
        var ret = jQuery.cssProps[name];
        return ret || (ret = jQuery.cssProps[name] = vendorPropName(name) || name), ret;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i, val = 0;
        for (i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0; i < 4; i += 2) "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), 
        isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), 
        "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), 
        "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox, styles = getStyles(elem), val = curCSS(elem, name, styles), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
        return rnumnonpx.test(val) ? val : (valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), 
        "auto" === val && (val = elem["offset" + name[0].toUpperCase() + name.slice(1)]), 
        (val = parseFloat(val) || 0) + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px");
    }
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    function schedule() {
        inProgress && (!1 === document.hidden && window.requestAnimationFrame ? window.requestAnimationFrame(schedule) : window.setTimeout(schedule, jQuery.fx.interval), 
        jQuery.fx.tick());
    }
    function createFxNow() {
        return window.setTimeout(function() {
            fxNow = void 0;
        }), fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        for (includeWidth = includeWidth ? 1 : 0; i < 4; i += 2 - includeWidth) which = cssExpand[i], 
        attrs["margin" + which] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type), attrs;
    }
    function createTween(value, prop, animation) {
        for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; index < length; index++) if (tween = collection[index].call(animation, prop, value)) return tween;
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, 
        oldfire = hooks.empty.fire, hooks.empty.fire = function() {
            hooks.unqueued || oldfire();
        }), hooks.unqueued++, anim.always(function() {
            anim.always(function() {
                hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire();
            });
        }));
        for (prop in props) if (value = props[prop], rfxtypes.test(value)) {
            if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                hidden = !0;
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
        if ((propTween = !jQuery.isEmptyObject(props)) || !jQuery.isEmptyObject(orig)) {
            isBox && 1 === elem.nodeType && (opts.overflow = [ style.overflow, style.overflowX, style.overflowY ], 
            restoreDisplay = dataShow && dataShow.display, null == restoreDisplay && (restoreDisplay = dataPriv.get(elem, "display")), 
            display = jQuery.css(elem, "display"), "none" === display && (restoreDisplay ? display = restoreDisplay : (showHide([ elem ], !0), 
            restoreDisplay = elem.style.display || restoreDisplay, display = jQuery.css(elem, "display"), 
            showHide([ elem ]))), ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done(function() {
                style.display = restoreDisplay;
            }), null == restoreDisplay && (display = style.display, restoreDisplay = "none" === display ? "" : display)), 
            style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always(function() {
                style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2];
            })), propTween = !1;
            for (prop in orig) propTween || (dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {
                display: restoreDisplay
            }), toggle && (dataShow.hidden = !hidden), hidden && showHide([ elem ], !0), anim.done(function() {
                hidden || showHide([ elem ]), dataPriv.remove(elem, "fxshow");
                for (prop in orig) jQuery.style(elem, prop, orig[prop]);
            })), propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = propTween.start, 
            hidden && (propTween.end = propTween.start, propTween.start = 0));
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) if (name = jQuery.camelCase(index), easing = specialEasing[name], 
        value = props[index], Array.isArray(value) && (easing = value[1], value = props[index] = value[0]), 
        index !== name && (props[name] = value, delete props[index]), (hooks = jQuery.cssHooks[name]) && "expand" in hooks) {
            value = hooks.expand(value), delete props[name];
            for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing);
        } else specialEasing[name] = easing;
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) return !1;
            for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; index < length; index++) animation.tweens[index].run(percent);
            return deferred.notifyWith(elem, [ animation, percent, remaining ]), percent < 1 && length ? remaining : (length || deferred.notifyWith(elem, [ animation, 1, 0 ]), 
            deferred.resolveWith(elem, [ animation ]), !1);
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(!0, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                return animation.tweens.push(tween), tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                for (stopped = !0; index < length; index++) animation.tweens[index].run(1);
                return gotoEnd ? (deferred.notifyWith(elem, [ animation, 1, 0 ]), deferred.resolveWith(elem, [ animation, gotoEnd ])) : deferred.rejectWith(elem, [ animation, gotoEnd ]), 
                this;
            }
        }), props = animation.props;
        for (propFilter(props, animation.opts.specialEasing); index < length; index++) if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts)) return jQuery.isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result)), 
        result;
        return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), 
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always), 
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })), animation;
    }
    function stripAndCollapse(value) {
        return (value.match(rnothtmlwhite) || []).join(" ");
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) jQuery.each(obj, function(i, v) {
            traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add);
        }); else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj); else for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
    }
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (jQuery.isFunction(func)) for (;dataType = dataTypes[i++]; ) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", 
            (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func);
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        function inspect(dataType) {
            var selected;
            return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), 
                inspect(dataTypeOrTransport), !1);
            }), selected;
        }
        var inspected = {}, seekingTransport = structure === transports;
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep), target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; ) dataTypes.shift(), 
        void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
        if (ct) for (type in contents) if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
        }
        if (dataTypes[0] in responses) finalDataType = dataTypes[0]; else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                firstDataType || (firstDataType = type);
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) return finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), 
        responses[finalDataType];
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
        for (current = dataTypes.shift(); current; ) if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), 
        !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), 
        prev = current, current = dataTypes.shift()) if ("*" === current) current = prev; else if ("*" !== prev && prev !== current) {
            if (!(conv = converters[prev + " " + current] || converters["* " + current])) for (conv2 in converters) if (tmp = conv2.split(" "), 
            tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                !0 === conv ? conv = converters[conv2] : !0 !== converters[conv2] && (current = tmp[0], 
                dataTypes.unshift(tmp[1]));
                break;
            }
            if (!0 !== conv) if (conv && s.throws) response = conv(response); else try {
                response = conv(response);
            } catch (e) {
                return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                };
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    var arr = [], document = window.document, getProto = Object.getPrototypeOf, slice = arr.slice, concat = arr.concat, push = arr.push, indexOf = arr.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, fnToString = hasOwn.toString, ObjectFunctionString = fnToString.call(Object), support = {}, jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: "3.2.1",
        constructor: jQuery,
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return null == num ? slice.call(this) : num < 0 ? this[num + this.length] : this[num];
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            return ret.prevObject = this, ret;
        },
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    }, jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
        for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, 
        i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, 
        i--); i < length; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], 
        copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, 
        clone = src && Array.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, 
        target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        return target;
    }, jQuery.extend({
        expando: "jQuery" + ("3.2.1" + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return "function" === jQuery.type(obj);
        },
        isWindow: function(obj) {
            return null != obj && obj === obj.window;
        },
        isNumeric: function(obj) {
            var type = jQuery.type(obj);
            return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj));
        },
        isPlainObject: function(obj) {
            var proto, Ctor;
            return !(!obj || "[object Object]" !== toString.call(obj) || (proto = getProto(obj)) && ("function" != typeof (Ctor = hasOwn.call(proto, "constructor") && proto.constructor) || fnToString.call(Ctor) !== ObjectFunctionString));
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) return !1;
            return !0;
        },
        type: function(obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            DOMEval(code);
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) for (length = obj.length; i < length && !1 !== callback.call(obj[i], i, obj[i]); i++) ; else for (i in obj) if (!1 === callback.call(obj[i], i, obj[i])) break;
            return obj;
        },
        trim: function(text) {
            return null == text ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [ arr ] : arr) : push.call(ret, arr)), 
            ret;
        },
        inArray: function(elem, arr, i) {
            return null == arr ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            for (var len = +second.length, j = 0, i = first.length; j < len; j++) first[i++] = second[j];
            return first.length = i, first;
        },
        grep: function(elems, callback, invert) {
            for (var matches = [], i = 0, length = elems.length, callbackExpect = !invert; i < length; i++) !callback(elems[i], i) !== callbackExpect && matches.push(elems[i]);
            return matches;
        },
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) for (length = elems.length; i < length; i++) null != (value = callback(elems[i], i, arg)) && ret.push(value); else for (i in elems) null != (value = callback(elems[i], i, arg)) && ret.push(value);
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if ("string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), jQuery.isFunction(fn)) return args = slice.call(arguments, 2), 
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy;
        },
        now: Date.now,
        support: support
    }), "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]), 
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    var Sizzle = function(window) {
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            if (results = results || [], "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
            if (!seed && ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), 
            context = context || document, documentIsHTML)) {
                if (11 !== nodeType && (match = rquickExpr.exec(selector))) if (m = match[1]) {
                    if (9 === nodeType) {
                        if (!(elem = context.getElementById(m))) return results;
                        if (elem.id === m) return results.push(elem), results;
                    } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), 
                    results;
                } else {
                    if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), 
                    results;
                    if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), 
                    results;
                }
                if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    if (1 !== nodeType) newContext = context, newSelector = selector; else if ("object" !== context.nodeName.toLowerCase()) {
                        for ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando), 
                        groups = tokenize(selector), i = groups.length; i--; ) groups[i] = "#" + nid + " " + toSelector(groups[i]);
                        newSelector = groups.join(","), newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    }
                    if (newSelector) try {
                        return push.apply(results, newContext.querySelectorAll(newSelector)), results;
                    } catch (qsaError) {} finally {
                        nid === expando && context.removeAttribute("id");
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            function cache(key, value) {
                return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value;
            }
            var keys = [];
            return cache;
        }
        function markFunction(fn) {
            return fn[expando] = !0, fn;
        }
        function assert(fn) {
            var el = document.createElement("fieldset");
            try {
                return !!fn(el);
            } catch (e) {
                return !1;
            } finally {
                el.parentNode && el.parentNode.removeChild(el), el = null;
            }
        }
        function addHandle(attrs, handler) {
            for (var arr = attrs.split("|"), i = arr.length; i--; ) Expr.attrHandle[arr[i]] = handler;
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
            if (diff) return diff;
            if (cur) for (;cur = cur.nextSibling; ) if (cur === b) return -1;
            return a ? 1 : -1;
        }
        function createDisabledPseudo(disabled) {
            return function(elem) {
                return "form" in elem ? elem.parentNode && !1 === elem.disabled ? "label" in elem ? "label" in elem.parentNode ? elem.parentNode.disabled === disabled : elem.disabled === disabled : elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled : elem.disabled === disabled : "label" in elem && elem.disabled === disabled;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                return argument = +argument, markFunction(function(seed, matches) {
                    for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; ) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]));
                });
            });
        }
        function testContext(context) {
            return context && void 0 !== context.getElementsByTagName && context;
        }
        function setFilters() {}
        function toSelector(tokens) {
            for (var i = 0, len = tokens.length, selector = ""; i < len; i++) selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && "parentNode" === key, doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
                return !1;
            } : function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    for (;elem = elem[dir]; ) if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0;
                } else for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) if (outerCache = elem[expando] || (elem[expando] = {}), 
                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {}), skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem; else {
                    if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                    if (uniqueCache[key] = newCache, newCache[2] = matcher(elem, context, xml)) return !0;
                }
                return !1;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                for (var i = matchers.length; i--; ) if (!matchers[i](elem, context, xml)) return !1;
                return !0;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            for (var i = 0, len = contexts.length; i < len; i++) Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; i < len; i++) (elem = unmatched[i]) && (filter && !filter(elem, context, xml) || (newUnmatched.push(elem), 
            mapped && map.push(i)));
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), 
            postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), 
            markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter) for (temp = condense(matcherOut, postMap), 
                postFilter(temp, [], context, xml), i = temp.length; i--; ) (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            for (temp = [], i = matcherOut.length; i--; ) (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        for (i = matcherOut.length; i--; ) (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem));
                    }
                } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), 
                postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut);
            });
        }
        function matcherFromTokens(tokens) {
            for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, !0), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                return checkContext = null, ret;
            } ]; i < len; i++) if (matcher = Expr.relative[tokens[i].type]) matchers = [ addCombinator(elementMatcher(matchers), matcher) ]; else {
                if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                    for (j = ++i; j < len && !Expr.relative[tokens[j].type]; j++) ;
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                        value: " " === tokens[i - 2].type ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                for (outermost && (outermostContext = context === document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                    if (byElement && elem) {
                        for (j = 0, context || elem.ownerDocument === document || (setDocument(elem), xml = !documentIsHTML); matcher = elementMatchers[j++]; ) if (matcher(elem, context || document, xml)) {
                            results.push(elem);
                            break;
                        }
                        outermost && (dirruns = dirrunsUnique);
                    }
                    bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem));
                }
                if (matchedCount += i, bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j++]; ) matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        if (matchedCount > 0) for (;i--; ) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results);
                }
                return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), 
                unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            return a === b && (hasDuplicate = !0), 0;
        }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            for (var i = 0, len = list.length; i < len; i++) if (list[i] === elem) return i;
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320);
        }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            return asCodePoint ? "\0" === ch ? "" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch;
        }, unloadHandler = function() {
            setDocument();
        }, disabledAncestor = addCombinator(function(elem) {
            return !0 === elem.disabled && ("form" in elem || "label" in elem);
        }, {
            dir: "parentNode",
            next: "legend"
        });
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), 
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    for (var j = target.length, i = 0; target[j++] = els[i++]; ) ;
                    target.length = j - 1;
                }
            };
        }
        support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return !!documentElement && "HTML" !== documentElement.nodeName;
        }, setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, 
            docElem = document.documentElement, documentIsHTML = !isXML(document), preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)), 
            support.attributes = assert(function(el) {
                return el.className = "i", !el.getAttribute("className");
            }), support.getElementsByTagName = assert(function(el) {
                return el.appendChild(document.createComment("")), !el.getElementsByTagName("*").length;
            }), support.getElementsByClassName = rnative.test(document.getElementsByClassName), 
            support.getById = assert(function(el) {
                return docElem.appendChild(el).id = expando, !document.getElementsByName || !document.getElementsByName(expando).length;
            }), support.getById ? (Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    return elem.getAttribute("id") === attrId;
                };
            }, Expr.find.ID = function(id, context) {
                if (void 0 !== context.getElementById && documentIsHTML) {
                    var elem = context.getElementById(id);
                    return elem ? [ elem ] : [];
                }
            }) : (Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    var node = void 0 !== elem.getAttributeNode && elem.getAttributeNode("id");
                    return node && node.value === attrId;
                };
            }, Expr.find.ID = function(id, context) {
                if (void 0 !== context.getElementById && documentIsHTML) {
                    var node, i, elems, elem = context.getElementById(id);
                    if (elem) {
                        if ((node = elem.getAttributeNode("id")) && node.value === id) return [ elem ];
                        for (elems = context.getElementsByName(id), i = 0; elem = elems[i++]; ) if ((node = elem.getAttributeNode("id")) && node.value === id) return [ elem ];
                    }
                    return [];
                }
            }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                return void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0;
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if ("*" === tag) {
                    for (;elem = results[i++]; ) 1 === elem.nodeType && tmp.push(elem);
                    return tmp;
                }
                return results;
            }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                if (void 0 !== context.getElementsByClassName && documentIsHTML) return context.getElementsByClassName(className);
            }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(document.querySelectorAll)) && (assert(function(el) {
                docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>", 
                el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), 
                el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), 
                el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), 
                el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]");
            }), assert(function(el) {
                el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var input = document.createElement("input");
                input.setAttribute("type", "hidden"), el.appendChild(input).setAttribute("name", "D"), 
                el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), 
                2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"), 
                docElem.appendChild(el).disabled = !0, 2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"), 
                el.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:");
            })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(el) {
                support.disconnectedMatch = matches.call(el, "*"), matches.call(el, "[s!='']:x"), 
                rbuggyMatches.push("!=", pseudos);
            }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), 
            hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, sortOrder = hasCompare ? function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return compare || (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1);
            } : function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                if (aup === bup) return siblingCheck(a, b);
                for (cur = a; cur = cur.parentNode; ) ap.unshift(cur);
                for (cur = b; cur = cur.parentNode; ) bp.unshift(cur);
                for (;ap[i] === bp[i]; ) i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            }, document) : document;
        }, Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        }, Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), 
            support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret;
            } catch (e) {}
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        }, Sizzle.contains = function(context, elem) {
            return (context.ownerDocument || context) !== document && setDocument(context), 
            contains(context, elem);
        }, Sizzle.attr = function(elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }, Sizzle.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        }, Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        }, Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), 
            results.sort(sortOrder), hasDuplicate) {
                for (;elem = results[i++]; ) elem === results[i] && (j = duplicates.push(i));
                for (;j--; ) results.splice(duplicates[j], 1);
            }
            return sortInput = null, results;
        }, getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (nodeType) {
                if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                    if ("string" == typeof elem.textContent) return elem.textContent;
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem);
                } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue;
            } else for (;node = elem[i++]; ) ret += getText(node);
            return ret;
        }, Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), 
                    "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4);
                },
                CHILD: function(match) {
                    return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), 
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), 
                    match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), 
                    match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), 
                    match[2] = unquoted.slice(0, excess)), match.slice(0, 3));
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return "*" === nodeNameSelector ? function() {
                        return !0;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test("string" == typeof elem.className && elem.className || void 0 !== elem.getAttribute && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        return null == result ? "!=" === operator : !operator || (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator && (result === check || result.slice(0, check.length + 1) === check + "-"));
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
                    return 1 === first && 0 === last ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = !1;
                        if (parent) {
                            if (simple) {
                                for (;dir; ) {
                                    for (node = elem; node = node[dir]; ) if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                    start = dir = "only" === type && !start && "nextSibling";
                                }
                                return !0;
                            }
                            if (start = [ forward ? parent.firstChild : parent.lastChild ], forward && useCache) {
                                for (node = parent, outerCache = node[expando] || (node[expando] = {}), uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), 
                                cache = uniqueCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex && cache[2], 
                                node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); ) if (1 === node.nodeType && ++diff && node === elem) {
                                    uniqueCache[type] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            } else if (useCache && (node = elem, outerCache = node[expando] || (node[expando] = {}), 
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), cache = uniqueCache[type] || [], 
                            nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex), !1 === diff) for (;(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && (outerCache = node[expando] || (node[expando] = {}), 
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), uniqueCache[type] = [ dirruns, diff ]), 
                            node !== elem)); ) ;
                            return (diff -= last) === first || diff % first == 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [ pseudo, pseudo, "", argument ], 
                    Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                        for (var idx, matched = fn(seed, argument), i = matched.length; i--; ) idx = indexOf(seed, matched[i]), 
                        seed[idx] = !(matches[idx] = matched[i]);
                    }) : function(elem) {
                        return fn(elem, 0, args);
                    }) : fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; ) (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem));
                    }) : function(elem, context, xml) {
                        return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    return text = text.replace(runescape, funescape), function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), 
                    lang = lang.replace(runescape, funescape).toLowerCase(), function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return (elemLang = elemLang.toLowerCase()) === lang || 0 === elemLang.indexOf(lang + "-");
                        } while ((elem = elem.parentNode) && 1 === elem.nodeType);
                        return !1;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: createDisabledPseudo(!1),
                disabled: createDisabledPseudo(!0),
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected;
                },
                selected: function(elem) {
                    return elem.parentNode && elem.parentNode.selectedIndex, !0 === elem.selected;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) if (elem.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(elem) {
                    return !Expr.pseudos.empty(elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && "button" === elem.type || "button" === name;
                },
                text: function(elem) {
                    var attr;
                    return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase());
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; i < length; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; i < length; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; --i >= 0; ) matchIndexes.push(i);
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; ++i < length; ) matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        }, Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) Expr.pseudos[i] = function(type) {
            return function(elem) {
                return "input" === elem.nodeName.toLowerCase() && elem.type === type;
            };
        }(i);
        for (i in {
            submit: !0,
            reset: !0
        }) Expr.pseudos[i] = function(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return ("input" === name || "button" === name) && elem.type === type;
            };
        }(i);
        return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters(), 
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar; ) {
                matched && !(match = rcomma.exec(soFar)) || (match && (soFar = soFar.slice(match[0].length) || soFar), 
                groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: match[0].replace(rtrim, " ")
                }), soFar = soFar.slice(matched.length));
                for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                }), soFar = soFar.slice(matched.length));
                if (!matched) break;
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }, compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                for (match || (match = tokenize(selector)), i = match.length; i--; ) cached = matcherFromTokens(match[i]), 
                cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), 
                cached.selector = selector;
            }
            return cached;
        }, select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            if (results = results || [], 1 === match.length) {
                if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                    if (!(context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0])) return results;
                    compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length);
                }
                for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], 
                !Expr.relative[type = token.type]); ) if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                    if (tokens.splice(i, 1), !(selector = seed.length && toSelector(tokens))) return push.apply(results, seed), 
                    results;
                    break;
                }
            }
            return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context), 
            results;
        }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, 
        support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(el) {
            return 1 & el.compareDocumentPosition(document.createElement("fieldset"));
        }), assert(function(el) {
            return el.innerHTML = "<a href='#'></a>", "#" === el.firstChild.getAttribute("href");
        }) || addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) return elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2);
        }), support.attributes && assert(function(el) {
            return el.innerHTML = "<input/>", el.firstChild.setAttribute("value", ""), "" === el.firstChild.getAttribute("value");
        }) || addHandle("value", function(elem, name, isXML) {
            if (!isXML && "input" === elem.nodeName.toLowerCase()) return elem.defaultValue;
        }), assert(function(el) {
            return null == el.getAttribute("disabled");
        }) || addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) return !0 === elem[name] ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }), Sizzle;
    }(window);
    jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, 
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, 
    jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains, jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir, until) {
        for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; ) if (1 === elem.nodeType) {
            if (truncate && jQuery(elem).is(until)) break;
            matched.push(elem);
        }
        return matched;
    }, siblings = function(n, elem) {
        for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
        return matched;
    }, rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i, risSimple = /^.[^:#\[\.,]*$/;
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return 1 === elem.nodeType;
        }));
    }, jQuery.fn.extend({
        find: function(selector) {
            var i, ret, len = this.length, self = this;
            if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function() {
                for (i = 0; i < len; i++) if (jQuery.contains(self[i], this)) return !0;
            }));
            for (ret = this.pushStack([]), i = 0; i < len; i++) jQuery.find(selector, self[i], ret);
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], !1));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], !0));
        },
        is: function(selector) {
            return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector) return this;
        if (root = root || rootjQuery, "string" == typeof selector) {
            if (!(match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [ null, selector, null ] : rquickExpr.exec(selector)) || !match[1] && context) return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
            if (match[1]) {
                if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), 
                rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) for (match in context) jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                return this;
            }
            return elem = document.getElementById(match[2]), elem && (this[0] = elem, this.length = 1), 
            this;
        }
        return selector.nodeType ? (this[0] = selector, this.length = 1, this) : jQuery.isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this);
    }).prototype = jQuery.fn, rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                for (var i = 0; i < l; i++) if (jQuery.contains(this, targets[i])) return !0;
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = "string" != typeof selectors && jQuery(selectors);
            if (!rneedsContext.test(selectors)) for (;i < l; i++) for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function(elem) {
            return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
        }
    }), jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            return nodeName(elem, "iframe") ? elem.contentDocument : (nodeName(elem, "template") && (elem = elem.content || elem), 
            jQuery.merge([], elem.childNodes));
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), 
            this.length > 1 && (guaranteedUnique[name] || jQuery.uniqueSort(matched), rparentsprev.test(name) && matched.reverse()), 
            this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    jQuery.Callbacks = function(options) {
        options = "string" == typeof options ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            for (locked = locked || options.once, fired = firing = !0; queue.length; firingIndex = -1) for (memory = queue.shift(); ++firingIndex < list.length; ) !1 === list[firingIndex].apply(memory[0], memory[1]) && options.stopOnFalse && (firingIndex = list.length, 
            memory = !1);
            options.memory || (memory = !1), firing = !1, locked && (list = memory ? [] : "");
        }, self = {
            add: function() {
                return list && (memory && !firing && (firingIndex = list.length - 1, queue.push(memory)), 
                function add(args) {
                    jQuery.each(args, function(_, arg) {
                        jQuery.isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== jQuery.type(arg) && add(arg);
                    });
                }(arguments), memory && !firing && fire()), this;
            },
            remove: function() {
                return jQuery.each(arguments, function(_, arg) {
                    for (var index; (index = jQuery.inArray(arg, list, index)) > -1; ) list.splice(index, 1), 
                    index <= firingIndex && firingIndex--;
                }), this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            empty: function() {
                return list && (list = []), this;
            },
            disable: function() {
                return locked = queue = [], list = memory = "", this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                return locked = queue = [], memory || firing || (list = memory = ""), this;
            },
            locked: function() {
                return !!locked;
            },
            fireWith: function(context, args) {
                return locked || (args = args || [], args = [ context, args.slice ? args.slice() : args ], 
                queue.push(args), firing || fire()), this;
            },
            fire: function() {
                return self.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    }, jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2 ], [ "resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected" ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    return deferred.done(arguments).fail(arguments), this;
                },
                catch: function(fn) {
                    return promise.then(null, fn);
                },
                pipe: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                returned && jQuery.isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [ returned ] : arguments);
                            });
                        }), fns = null;
                    }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                    function resolve(depth, deferred, handler, special) {
                        return function() {
                            var that = this, args = arguments, mightThrow = function() {
                                var returned, then;
                                if (!(depth < maxDepth)) {
                                    if ((returned = handler.apply(that, args)) === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                    then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then, 
                                    jQuery.isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++, 
                                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0, 
                                    args = [ returned ]), (special || deferred.resolveWith)(that, args));
                                }
                            }, process = special ? mightThrow : function() {
                                try {
                                    mightThrow();
                                } catch (e) {
                                    jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace), 
                                    depth + 1 >= maxDepth && (handler !== Thrower && (that = void 0, args = [ e ]), 
                                    deferred.rejectWith(that, args));
                                }
                            };
                            depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()), 
                            window.setTimeout(process));
                        };
                    }
                    var maxDepth = 0;
                    return jQuery.Deferred(function(newDefer) {
                        tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)), 
                        tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity)), 
                        tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
                    }).promise();
                },
                promise: function(obj) {
                    return null != obj ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            return jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add, stateString && list.add(function() {
                    state = stateString;
                }, tuples[3 - i][2].disable, tuples[0][2].lock), list.add(tuple[3].fire), deferred[tuple[0]] = function() {
                    return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments), 
                    this;
                }, deferred[tuple[0] + "With"] = list.fireWith;
            }), promise.promise(deferred), func && func.call(deferred, deferred), deferred;
        },
        when: function(singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function(i) {
                return function(value) {
                    resolveContexts[i] = this, resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value, 
                    --remaining || master.resolveWith(resolveContexts, resolveValues);
                };
            };
            if (remaining <= 1 && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining), 
            "pending" === master.state() || jQuery.isFunction(resolveValues[i] && resolveValues[i].then))) return master.then();
            for (;i--; ) adoptValue(resolveValues[i], updateFunc(i), master.reject);
            return master.promise();
        }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
        window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }, jQuery.readyException = function(error) {
        window.setTimeout(function() {
            throw error;
        });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
        return readyList.then(fn).catch(function(error) {
            jQuery.readyException(error);
        }), this;
    }, jQuery.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(wait) {
            (!0 === wait ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, !0 !== wait && --jQuery.readyWait > 0 || readyList.resolveWith(document, [ jQuery ]));
        }
    }), jQuery.ready.then = readyList.then, "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed), 
    window.addEventListener("load", completed));
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = null == key;
        if ("object" === jQuery.type(key)) {
            chainable = !0;
            for (i in key) access(elems, fn, i, key[i], !0, emptyGet, raw);
        } else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), 
        bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
        })), fn)) for (;i < len; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    }, acceptData = function(owner) {
        return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType;
    };
    Data.uid = 1, Data.prototype = {
        cache: function(owner) {
            var value = owner[this.expando];
            return value || (value = {}, acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: !0
            }))), value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if ("string" == typeof data) cache[jQuery.camelCase(data)] = value; else for (prop in data) cache[jQuery.camelCase(prop)] = data[prop];
            return cache;
        },
        get: function(owner, key) {
            return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
        },
        access: function(owner, key, value) {
            return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value), 
            void 0 !== value ? value : key);
        },
        remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (void 0 !== cache) {
                if (void 0 !== key) {
                    Array.isArray(key) ? key = key.map(jQuery.camelCase) : (key = jQuery.camelCase(key), 
                    key = key in cache ? [ key ] : key.match(rnothtmlwhite) || []), i = key.length;
                    for (;i--; ) delete cache[key[i]];
                }
                (void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando]);
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return void 0 !== cache && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data(), dataUser = new Data(), rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    }), jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (void 0 === key) {
                if (this.length && (data = dataUser.get(elem), 1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
                    for (i = attrs.length; i--; ) attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), 
                    dataAttr(elem, name, data[name])));
                    dataPriv.set(elem, "hasDataAttrs", !0);
                }
                return data;
            }
            return "object" == typeof key ? this.each(function() {
                dataUser.set(this, key);
            }) : access(this, function(value) {
                var data;
                if (elem && void 0 === value) {
                    if (void 0 !== (data = dataUser.get(elem, key))) return data;
                    if (void 0 !== (data = dataAttr(elem, key))) return data;
                } else this.each(function() {
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, !0);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    }), jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) return type = (type || "fx") + "queue", queue = dataPriv.get(elem, type), 
            data && (!queue || Array.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), 
            queue || [];
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), 
            delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire();
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    }), jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                --count || defer.resolveWith(elements, [ elements ]);
            };
            for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--; ) (tmp = dataPriv.get(elements[i], type + "queueHooks")) && tmp.empty && (count++, 
            tmp.empty.add(resolve));
            return resolve(), defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), cssExpand = [ "Top", "Right", "Bottom", "Left" ], isHiddenWithinTree = function(elem, el) {
        return elem = el || elem, "none" === elem.style.display || "" === elem.style.display && jQuery.contains(elem.ownerDocument, elem) && "none" === jQuery.css(elem, "display");
    }, swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
        ret = callback.apply(elem, args || []);
        for (name in options) elem.style[name] = old[name];
        return ret;
    }, defaultDisplayMap = {};
    jQuery.fn.extend({
        show: function() {
            return showHide(this, !0);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide();
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i, rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, rscriptType = /^$|\/(?:java|ecma)script/i, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var rhtml = /<|&#?\w+;/;
    !function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), 
        div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, 
        div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue;
    }();
    var documentElement = document.documentElement, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (elemData) for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, 
            selector = handleObjIn.selector), selector && jQuery.find.matchesSelector(documentElement, selector), 
            handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), 
            (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                return void 0 !== jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            }), types = (types || "").match(rnothtmlwhite) || [ "" ], t = types.length; t--; ) tmp = rtypenamespace.exec(types[t]) || [], 
            type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, 
            type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, 
            handleObj = jQuery.extend({
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
            }, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, 
            special.setup && !1 !== special.setup.call(elem, data, namespaces, eventHandle) || elem.addEventListener && elem.addEventListener(type, eventHandle)), 
            special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), 
            selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), 
            jQuery.event.global[type] = !0);
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (elemData && (events = elemData.events)) {
                for (types = (types || "").match(rnothtmlwhite) || [ "" ], t = types.length; t--; ) if (tmp = rtypenamespace.exec(types[t]) || [], 
                type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                    for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, 
                    handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
                    origCount = j = handlers.length; j--; ) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), 
                    handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                    origCount && !handlers.length && (special.teardown && !1 !== special.teardown.call(elem, namespaces, elemData.handle) || jQuery.removeEvent(elem, type, elemData.handle), 
                    delete events[type]);
                } else for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events");
            }
        },
        dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, event = jQuery.event.fix(nativeEvent), args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            for (args[0] = event, i = 1; i < arguments.length; i++) args[i] = arguments[i];
            if (event.delegateTarget = this, !special.preDispatch || !1 !== special.preDispatch.call(this, event)) {
                for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); ) for (event.currentTarget = matched.elem, 
                j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); ) event.rnamespace && !event.rnamespace.test(handleObj.namespace) || (event.handleObj = handleObj, 
                event.data = handleObj.data, void 0 !== (ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args)) && !1 === (event.result = ret) && (event.preventDefault(), 
                event.stopPropagation()));
                return special.postDispatch && special.postDispatch.call(this, event), event.result;
            }
        },
        handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !("click" === event.type && event.button >= 1)) for (;cur !== this; cur = cur.parentNode || this) if (1 === cur.nodeType && ("click" !== event.type || !0 !== cur.disabled)) {
                for (matchedHandlers = [], matchedSelectors = {}, i = 0; i < delegateCount; i++) handleObj = handlers[i], 
                sel = handleObj.selector + " ", void 0 === matchedSelectors[sel] && (matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [ cur ]).length), 
                matchedSelectors[sel] && matchedHandlers.push(handleObj);
                matchedHandlers.length && handlerQueue.push({
                    elem: cur,
                    handlers: matchedHandlers
                });
            }
            return cur = this, delegateCount < handlers.length && handlerQueue.push({
                elem: cur,
                handlers: handlers.slice(delegateCount)
            }), handlerQueue;
        },
        addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: !0,
                configurable: !0,
                get: jQuery.isFunction(hook) ? function() {
                    if (this.originalEvent) return hook(this.originalEvent);
                } : function() {
                    if (this.originalEvent) return this.originalEvent[name];
                },
                set: function(value) {
                    Object.defineProperty(this, name, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: value
                    });
                }
            });
        },
        fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) return this.focus(), !1;
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) return this.blur(), !1;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if ("checkbox" === this.type && this.click && nodeName(this, "input")) return this.click(), 
                    !1;
                },
                _default: function(event) {
                    return nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result);
                }
            }
        }
    }, jQuery.removeEvent = function(elem, type, handle) {
        elem.removeEventListener && elem.removeEventListener(type, handle);
    }, jQuery.Event = function(src, props) {
        return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, 
        this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && !1 === src.returnValue ? returnTrue : returnFalse, 
        this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target, 
        this.currentTarget = src.currentTarget, this.relatedTarget = src.relatedTarget) : this.type = src, 
        props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), 
        void (this[jQuery.expando] = !0)) : new jQuery.Event(src, props);
    }, jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: !1,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue, e && !this.isSimulated && e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue, e && !this.isSimulated && e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue, e && !this.isSimulated && e.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, jQuery.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function(event) {
            var button = event.button;
            return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which;
        }
    }, jQuery.event.addProp), jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                return related && (related === target || jQuery.contains(target, related)) || (event.type = handleObj.origType, 
                ret = handleObj.handler.apply(this, arguments), event.type = fix), ret;
            }
        };
    }), jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, 
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), 
            this;
            if ("object" == typeof types) {
                for (type in types) this.off(type, selector, types[type]);
                return this;
            }
            return !1 !== selector && "function" != typeof selector || (fn = selector, selector = void 0), 
            !1 === fn && (fn = returnFalse), this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem))) for (destElements = getAll(clone), 
            srcElements = getAll(elem), i = 0, l = srcElements.length; i < l; i++) fixInput(srcElements[i], destElements[i]);
            if (dataAndEvents) if (deepDataAndEvents) for (srcElements = srcElements || getAll(elem), 
            destElements = destElements || getAll(clone), i = 0, l = srcElements.length; i < l; i++) cloneCopyEvent(srcElements[i], destElements[i]); else cloneCopyEvent(elem, clone);
            return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), 
            clone;
        },
        cleanData: function(elems) {
            for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++) if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                    if (data.events) for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                    elem[dataPriv.expando] = void 0;
                }
                elem[dataUser.expando] && (elem[dataUser.expando] = void 0);
            }
        }
    }), jQuery.fn.extend({
        detach: function(selector) {
            return remove(this, selector, !0);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value) {
            return access(this, function(value) {
                return void 0 === value ? jQuery.text(this) : this.empty().each(function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = value);
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    manipulationTarget(this, elem).appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        empty: function() {
            for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
            elem.textContent = "");
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            return dataAndEvents = null != dataAndEvents && dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, 
            this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
                if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (;i < l; i++) elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
                        elem.innerHTML = value);
                        elem = 0;
                    } catch (e) {}
                }
                elem && this.empty().append(value);
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)), parent && parent.replaceChild(elem, this));
            }, ignored);
        }
    }), jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; i <= last; i++) elems = i === last ? this : this.clone(!0), 
            jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
            return this.pushStack(ret);
        };
    });
    var rmargin = /^margin/, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        return view && view.opener || (view = window), view.getComputedStyle(elem);
    };
    !function() {
        function computeStyleTests() {
            if (div) {
                div.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", 
                div.innerHTML = "", documentElement.appendChild(container);
                var divStyle = window.getComputedStyle(div);
                pixelPositionVal = "1%" !== divStyle.top, reliableMarginLeftVal = "2px" === divStyle.marginLeft, 
                boxSizingReliableVal = "4px" === divStyle.width, div.style.marginRight = "50%", 
                pixelMarginRightVal = "4px" === divStyle.marginRight, documentElement.removeChild(container), 
                div = null;
            }
        }
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
        div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", 
        support.clearCloneStyle = "content-box" === div.style.backgroundClip, container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", 
        container.appendChild(div), jQuery.extend(support, {
            pixelPosition: function() {
                return computeStyleTests(), pixelPositionVal;
            },
            boxSizingReliable: function() {
                return computeStyleTests(), boxSizingReliableVal;
            },
            pixelMarginRight: function() {
                return computeStyleTests(), pixelMarginRightVal;
            },
            reliableMarginLeft: function() {
                return computeStyleTests(), reliableMarginLeftVal;
            }
        }));
    }();
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "Moz", "ms" ], emptyStyle = document.createElement("div").style;
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return "" === ret ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                var ret, type, hooks, origName = jQuery.camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
                return isCustomProp || (name = finalPropName(origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], 
                void 0 === value ? hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name] : (type = typeof value, 
                "string" === type && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret), 
                type = "number"), void (null != value && value === value && ("number" === type && (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")), 
                support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), 
                hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (isCustomProp ? style.setProperty(name, value) : style[name] = value))));
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            return rcustomProp.test(name) || (name = finalPropName(origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], 
            hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), void 0 === val && (val = curCSS(elem, name, styles)), 
            "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), 
            "" === extra || extra ? (num = parseFloat(val), !0 === extra || isFinite(num) ? num || 0 : val) : val;
        }
    }), jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) return !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, name, extra) : swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, name, extra);
                });
            },
            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles);
                return subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[name] = value, 
                value = jQuery.css(elem, name)), setPositiveNumber(elem, value, subtract);
            }
        };
    }), jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
        }, function() {
            return elem.getBoundingClientRect().left;
        })) + "px";
    }), jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [ value ]; i < 4; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        }, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber);
    }), jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name)) {
                    for (styles = getStyles(elem), len = name.length; i < len; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                    return map;
                }
                return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    }), jQuery.Tween = Tween, Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem, this.prop = prop, this.easing = easing || jQuery.easing._default, 
            this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, 
            this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this;
        }
    }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, ""), 
                result && "auto" !== result ? result : 0);
            },
            set: function(tween) {
                jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || null == tween.elem.style[jQuery.cssProps[tween.prop]] && !jQuery.cssHooks[tween.prop] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            }
        }
    }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now);
        }
    }, jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [ function(prop, value) {
                var tween = this.createTween(prop, value);
                return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween), tween;
            } ]
        },
        tweener: function(props, callback) {
            jQuery.isFunction(props) ? (callback = props, props = [ "*" ]) : props = props.match(rnothtmlwhite);
            for (var prop, index = 0, length = props.length; index < length; index++) prop = props[index], 
            Animation.tweeners[prop] = Animation.tweeners[prop] || [], Animation.tweeners[prop].unshift(callback);
        },
        prefilters: [ defaultPrefilter ],
        prefilter: function(callback, prepend) {
            prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback);
        }
    }), jQuery.speed = function(speed, easing, fn) {
        var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        return jQuery.fx.off ? opt.duration = 0 : "number" != typeof opt.duration && (opt.duration in jQuery.fx.speeds ? opt.duration = jQuery.fx.speeds[opt.duration] : opt.duration = jQuery.fx.speeds._default), 
        null != opt.queue && !0 !== opt.queue || (opt.queue = "fx"), opt.old = opt.complete, 
        opt.complete = function() {
            jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue);
        }, opt;
    }, jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                (empty || dataPriv.get(this, "finish")) && anim.stop(!0);
            };
            return doAnimation.finish = doAnimation, empty || !1 === optall.queue ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop, stop(gotoEnd);
            };
            return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), 
            clearQueue && !1 !== type && this.queue(type || "fx", []), this.each(function() {
                var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) data[index] && data[index].stop && stopQueue(data[index]); else for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                for (index = timers.length; index--; ) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), 
                dequeue = !1, timers.splice(index, 1));
                !dequeue && gotoEnd || jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            return !1 !== type && (type = type || "fx"), this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), 
                index = timers.length; index--; ) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), 
                timers.splice(index, 1));
                for (index = 0; index < length; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                delete data.finish;
            });
        }
    }), jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback);
        };
    }), jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    }), jQuery.timers = [], jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        for (fxNow = jQuery.now(); i < timers.length; i++) (timer = timers[i])() || timers[i] !== timer || timers.splice(i--, 1);
        timers.length || jQuery.fx.stop(), fxNow = void 0;
    }, jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer), jQuery.fx.start();
    }, jQuery.fx.interval = 13, jQuery.fx.start = function() {
        inProgress || (inProgress = !0, schedule());
    }, jQuery.fx.stop = function() {
        inProgress = null;
    }, jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, jQuery.fn.delay = function(time, type) {
        return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx", 
        this.queue(type, function(next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function() {
                window.clearTimeout(timeout);
            };
        });
    }, function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, 
        input = document.createElement("input"), input.value = "t", input.type = "radio", 
        support.radioValue = "t" === input.value;
    }();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    }), jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (3 !== nType && 8 !== nType && 2 !== nType) return void 0 === elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)), 
            void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), 
            value) : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), 
            null == ret ? void 0 : ret));
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && "radio" === value && nodeName(elem, "input")) {
                        var val = elem.value;
                        return elem.setAttribute("type", value), val && (elem.value = val), value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && 1 === elem.nodeType) for (;name = attrNames[i++]; ) elem.removeAttribute(name);
        }
    }), boolHook = {
        set: function(elem, value, name) {
            return !1 === value ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), 
            name;
        }
    }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            return isXML || (handle = attrHandle[lowercaseName], attrHandle[lowercaseName] = ret, 
            ret = null != getter(elem, name, isXML) ? lowercaseName : null, attrHandle[lowercaseName] = handle), 
            ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    }), jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (3 !== nType && 8 !== nType && 2 !== nType) return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name, 
            hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }), support.optSelected || (jQuery.propHooks.selected = {
        get: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.parentNode && parent.parentNode.selectedIndex, null;
        },
        set: function(elem) {
            var parent = elem.parentNode;
            parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex);
        }
    }), jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    }), jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
            if ("string" == typeof value && value) for (classes = value.match(rnothtmlwhite) || []; elem = this[i++]; ) if (curValue = getClass(elem), 
            cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                for (j = 0; clazz = classes[j++]; ) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                finalValue = stripAndCollapse(cur), curValue !== finalValue && elem.setAttribute("class", finalValue);
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            if ("string" == typeof value && value) for (classes = value.match(rnothtmlwhite) || []; elem = this[i++]; ) if (curValue = getClass(elem), 
            cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                for (j = 0; clazz = classes[j++]; ) for (;cur.indexOf(" " + clazz + " ") > -1; ) cur = cur.replace(" " + clazz + " ", " ");
                finalValue = stripAndCollapse(cur), curValue !== finalValue && elem.setAttribute("class", finalValue);
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            }) : this.each(function() {
                var className, i, self, classNames;
                if ("string" === type) for (i = 0, self = jQuery(this), classNames = value.match(rnothtmlwhite) || []; className = classNames[i++]; ) self.hasClass(className) ? self.removeClass(className) : self.addClass(className); else void 0 !== value && "boolean" !== type || (className = getClass(this), 
                className && dataPriv.set(this, "__className__", className), this.setAttribute && this.setAttribute("class", className || !1 === value ? "" : dataPriv.get(this, "__className__") || ""));
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            for (className = " " + selector + " "; elem = this[i++]; ) if (1 === elem.nodeType && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return !0;
            return !1;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            return arguments.length ? (isFunction = jQuery.isFunction(value), this.each(function(i) {
                var val;
                1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, 
                null == val ? val = "" : "number" == typeof val ? val += "" : Array.isArray(val) && (val = jQuery.map(val, function(value) {
                    return null == value ? "" : value + "";
                })), (hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]) && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val));
            })) : elem ? (hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], 
            hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value, 
            "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret)) : void 0;
        }
    }), jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return null != val ? val : stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type, values = one ? null : [], max = one ? index + 1 : options.length;
                    for (i = index < 0 ? max : one ? index : 0; i < max; i++) if (option = options[i], 
                    (option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                        if (value = jQuery(option).val(), one) return value;
                        values.push(value);
                    }
                    return values;
                },
                set: function(elem, value) {
                    for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; ) option = options[i], 
                    (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) && (optionSet = !0);
                    return optionSet || (elem.selectedIndex = -1), values;
                }
            }
        }
    }), jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (Array.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
        }, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
            return null === elem.getAttribute("value") ? "on" : elem.value;
        });
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") > -1 && (namespaces = type.split("."), 
            type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, 
            event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), 
            event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), 
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            event.result = void 0, event.target || (event.target = elem), data = null == data ? [ event ] : jQuery.makeArray(data, [ event ]), 
            special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || !1 !== special.trigger.apply(elem, data))) {
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), 
                    tmp = cur;
                    tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
                for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); ) event.type = i > 1 ? bubbleType : special.bindType || type, 
                handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle"), 
                handle && handle.apply(cur, data), (handle = ontype && cur[ontype]) && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data), 
                !1 === event.result && event.preventDefault());
                return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && !1 !== special._default.apply(eventPath.pop(), data) || !acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], 
                tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = void 0, 
                tmp && (elem[ontype] = tmp)), event.result;
            }
        },
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: !0
            });
            jQuery.event.trigger(e, null, elem);
        }
    }), jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) return jQuery.event.trigger(type, data, elem, !0);
        }
    }), jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    }), jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    }), support.focusin = "onfocusin" in window, support.focusin || jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
            setup: function() {
                var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                attaches || doc.addEventListener(orig, handler, !0), dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), 
                dataPriv.remove(doc, fix));
            }
        };
    });
    var location = window.location, nonce = jQuery.now(), rquery = /\?/;
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || "string" != typeof data) return null;
        try {
            xml = new window.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
            xml = void 0;
        }
        return xml && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data), 
        xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
            var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value);
        };
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function() {
            add(this.name, this.value);
        }); else for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
        return s.join("&");
    }, jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return null == val ? null : Array.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document.createElement("a");
    originAnchor.href = location.href, jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                completed || (completed = !0, timeoutTimer && window.clearTimeout(timeoutTimer), 
                transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, 
                isSuccess = status >= 200 && status < 300 || 304 === status, responses && (response = ajaxHandleResponses(s, jqXHR, responses)), 
                response = ajaxConvert(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), 
                modified && (jQuery.lastModified[cacheURL] = modified), (modified = jqXHR.getResponseHeader("etag")) && (jQuery.etag[cacheURL] = modified)), 
                204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, 
                success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, 
                !status && statusText || (statusText = "error", status < 0 && (status = 0))), jqXHR.status = status, 
                jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]) : deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]), 
                jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]), 
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]), 
                --jQuery.active || jQuery.event.trigger("ajaxStop")));
            }
            "object" == typeof url && (options = url, url = void 0), options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders) for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); ) responseHeaders[match[1].toLowerCase()] = match[2];
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return null == match ? null : match;
                },
                getAllResponseHeaders: function() {
                    return completed ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name, 
                    requestHeaders[name] = value), this;
                },
                overrideMimeType: function(type) {
                    return null == completed && (s.mimeType = type), this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) if (completed) jqXHR.always(map[jqXHR.status]); else for (code in map) statusCode[code] = [ statusCode[code], map[code] ];
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    return transport && transport.abort(finalText), done(0, finalText), this;
                }
            };
            if (deferred.promise(jqXHR), s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"), 
            s.type = options.method || options.type || s.method || s.type, s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [ "" ], 
            null == s.crossDomain) {
                urlAnchor = document.createElement("a");
                try {
                    urlAnchor.href = s.url, urlAnchor.href = urlAnchor.href, s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = !0;
                }
            }
            if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), 
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), completed) return jqXHR;
            fireGlobals = jQuery.event && s.global, fireGlobals && 0 == jQuery.active++ && jQuery.event.trigger("ajaxStart"), 
            s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url.replace(rhash, ""), 
            s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length), 
            s.data && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), 
            !1 === s.cache && (cacheURL = cacheURL.replace(rantiCache, "$1"), uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached), 
            s.url = cacheURL + uncached), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), 
            jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), 
            (s.data && s.hasContent && !1 !== s.contentType || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), 
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
            if (s.beforeSend && (!1 === s.beforeSend.call(callbackContext, jqXHR, s) || completed)) return jqXHR.abort();
            if (strAbort = "abort", completeDeferred.add(s.complete), jqXHR.done(s.success), 
            jqXHR.fail(s.error), transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                if (jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [ jqXHR, s ]), 
                completed) return jqXHR;
                s.async && s.timeout > 0 && (timeoutTimer = window.setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout));
                try {
                    completed = !1, transport.send(requestHeaders, done);
                } catch (e) {
                    if (completed) throw e;
                    done(-1, e);
                }
            } else done(-1, "No Transport");
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script");
        }
    }), jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), 
            jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    }), jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            throws: !0
        });
    }, jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            return this[0] && (jQuery.isFunction(html) && (html = html.call(this[0])), wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), 
            this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function() {
                for (var elem = this; elem.firstElementChild; ) elem = elem.firstElementChild;
                return elem;
            }).append(this)), this;
        },
        wrapInner: function(html) {
            return jQuery.isFunction(html) ? this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            }) : this.each(function() {
                var self = jQuery(this), contents = self.contents();
                contents.length ? contents.wrapAll(html) : self.append(html);
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function(selector) {
            return this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes);
            }), this;
        }
    }), jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
    }, jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    }, jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, 
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) return {
            send: function(headers, complete) {
                var i, xhr = options.xhr();
                if (xhr.open(options.type, options.url, options.async, options.username, options.password), 
                options.xhrFields) for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), 
                options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                for (i in headers) xhr.setRequestHeader(i, headers[i]);
                callback = function(type) {
                    return function() {
                        callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null, 
                        "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {
                            binary: xhr.response
                        } : {
                            text: xhr.responseText
                        }, xhr.getAllResponseHeaders()));
                    };
                }, xhr.onload = callback(), errorCallback = xhr.onerror = callback("error"), void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function() {
                    4 === xhr.readyState && window.setTimeout(function() {
                        callback && errorCallback();
                    });
                }, callback = callback("abort");
                try {
                    xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                    if (callback) throw e;
                }
            },
            abort: function() {
                callback && callback();
            }
        };
    }), jQuery.ajaxPrefilter(function(s) {
        s.crossDomain && (s.contents.script = !1);
    }), jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                return jQuery.globalEval(text), text;
            }
        }
    }), jQuery.ajaxPrefilter("script", function(s) {
        void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET");
    }), jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type);
                    }), document.head.appendChild(script[0]);
                },
                abort: function() {
                    callback && callback();
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            return this[callback] = !0, callback;
        }
    }), jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = !1 !== s.jsonp && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || "jsonp" === s.dataTypes[0]) return callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, 
        jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : !1 !== s.jsonp && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), 
        s.converters["script json"] = function() {
            return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0];
        }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
            responseContainer = arguments;
        }, jqXHR.always(function() {
            void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten, 
            s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), 
            responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), 
            responseContainer = overwritten = void 0;
        }), "script";
    }), support.createHTMLDocument = function() {
        var body = document.implementation.createHTMLDocument("").body;
        return body.innerHTML = "<form></form><form></form>", 2 === body.childNodes.length;
    }(), jQuery.parseHTML = function(data, context, keepScripts) {
        if ("string" != typeof data) return [];
        "boolean" == typeof context && (keepScripts = context, context = !1);
        var base, parsed, scripts;
        return context || (support.createHTMLDocument ? (context = document.implementation.createHTMLDocument(""), 
        base = context.createElement("base"), base.href = document.location.href, context.head.appendChild(base)) : context = document), 
        parsed = rsingleTag.exec(data), scripts = !keepScripts && [], parsed ? [ context.createElement(parsed[1]) ] : (parsed = buildFragment([ data ], context, scripts), 
        scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes));
    }, jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(" ");
        return off > -1 && (selector = stripAndCollapse(url.slice(off)), url = url.slice(0, off)), 
        jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), 
        self.length > 0 && jQuery.ajax({
            url: url,
            type: type || "GET",
            dataType: "html",
            data: params
        }).done(function(responseText) {
            response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
        }).always(callback && function(jqXHR, status) {
            self.each(function() {
                callback.apply(this, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }), this;
    }, jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    }), jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    }, jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), 
            curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1, 
            calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, 
            curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), 
            jQuery.isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))), 
            null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), 
            "using" in options ? options.using.call(elem, props) : curElem.css(props);
        }
    }, jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) return void 0 === options ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var doc, docElem, rect, win, elem = this[0];
            return elem ? elem.getClientRects().length ? (rect = elem.getBoundingClientRect(), 
            doc = elem.ownerDocument, docElem = doc.documentElement, win = doc.defaultView, 
            {
                top: rect.top + win.pageYOffset - docElem.clientTop,
                left: rect.left + win.pageXOffset - docElem.clientLeft
            }) : {
                top: 0,
                left: 0
            } : void 0;
        },
        position: function() {
            if (this[0]) {
                var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
                return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), 
                offset = this.offset(), nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), 
                parentOffset = {
                    top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", !0),
                    left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", !0)
                }), {
                    top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                    left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position"); ) offsetParent = offsetParent.offsetParent;
                return offsetParent || documentElement;
            });
        }
    }), jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win;
                return jQuery.isWindow(elem) ? win = elem : 9 === elem.nodeType && (win = elem.defaultView), 
                void 0 === val ? win ? win[prop] : elem[method] : void (win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val);
            }, method, val, arguments.length);
        };
    }), jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) return computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
        });
    }), jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (!0 === margin || !0 === value ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    return jQuery.isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, 
                    Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : void 0, chainable);
            };
        });
    }), jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    }), jQuery.holdReady = function(hold) {
        hold ? jQuery.readyWait++ : jQuery.ready(!0);
    }, jQuery.isArray = Array.isArray, jQuery.parseJSON = JSON.parse, jQuery.nodeName = nodeName, 
    "function" == typeof define && define.amd && define("jquery", [], function() {
        return jQuery;
    });
    var _jQuery = window.jQuery, _$ = window.$;
    return jQuery.noConflict = function(deep) {
        return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), 
        jQuery;
    }, noGlobal || (window.jQuery = window.$ = jQuery), jQuery;
}), function(window) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        return ErrorConstructor = ErrorConstructor || Error, function() {
            var paramPrefix, i, code = arguments[0], template = arguments[1], message = "[" + (module ? module + ":" : "") + code + "] ", templateArgs = sliceArgs(arguments, 2).map(function(arg) {
                return toDebugString(arg, minErrConfig.objectMaxDepth);
            });
            for (message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1);
                return index < templateArgs.length ? templateArgs[index] : match;
            }), message += "\nhttp://errors.angularjs.org/1.6.4/" + (module ? module + "/" : "") + code, 
            i = 0, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
            return new ErrorConstructor(message);
        };
    }
    function errorHandlingConfig(config) {
        return isObject(config) ? void (isDefined(config.objectMaxDepth) && (minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN)) : minErrConfig;
    }
    function isValidObjectMaxDepth(maxDepth) {
        return isNumber(maxDepth) && maxDepth > 0;
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return !0;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || "function" == typeof obj.item);
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" !== key && "length" !== key && "name" !== key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = "object" != typeof obj;
            for (key = 0, length = obj.length; key < length; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj);
        } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj)) for (key in obj) iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty) for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function baseExtend(dst, objs, deep) {
        for (var h = dst.$$hashKey, i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (isObject(obj) || isFunction(obj)) for (var keys = Object.keys(obj), j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j], src = obj[key];
                deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), 
                baseExtend(dst[key], [ src ], !0)) : dst[key] = src;
            }
        }
        return setHashKey(dst, h), dst;
    }
    function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !1);
    }
    function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !0);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
    }
    function isUndefined(value) {
        return void 0 === value;
    }
    function isDefined(value) {
        return void 0 !== value;
    }
    function isObject(value) {
        return null !== value && "object" == typeof value;
    }
    function isBlankObject(value) {
        return null !== value && "object" == typeof value && !getPrototypeOf(value);
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj);
    }
    function isFormData(obj) {
        return "[object FormData]" === toString.call(obj);
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj);
    }
    function isBoolean(value) {
        return "boolean" == typeof value;
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    function isArrayBuffer(obj) {
        return "[object ArrayBuffer]" === toString.call(obj);
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++) obj[items[i]] = !0;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return -1 !== Array.prototype.indexOf.call(array, obj);
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && array.splice(index, 1), index;
    }
    function copy(source, destination, maxDepth) {
        function copyRecurse(source, destination, maxDepth) {
            if (--maxDepth < 0) return "...";
            var key, h = destination.$$hashKey;
            if (isArray(source)) for (var i = 0, ii = source.length; i < ii; i++) destination.push(copyElement(source[i], maxDepth)); else if (isBlankObject(source)) for (key in source) destination[key] = copyElement(source[key], maxDepth); else if (source && "function" == typeof source.hasOwnProperty) for (key in source) source.hasOwnProperty(key) && (destination[key] = copyElement(source[key], maxDepth)); else for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key], maxDepth));
            return setHashKey(destination, h), destination;
        }
        function copyElement(source, maxDepth) {
            if (!isObject(source)) return source;
            var index = stackSource.indexOf(source);
            if (-1 !== index) return stackDest[index];
            if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
            var needsRecurse = !1, destination = copyType(source);
            return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)), 
            needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
        }
        function copyType(source) {
            switch (toString.call(source)) {
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

              case "[object ArrayBuffer]":
                if (!source.slice) {
                    var copied = new ArrayBuffer(source.byteLength);
                    return new Uint8Array(copied).set(new Uint8Array(source)), copied;
                }
                return source.slice(0);

              case "[object Boolean]":
              case "[object Number]":
              case "[object String]":
              case "[object Date]":
                return new source.constructor(source.valueOf());

              case "[object RegExp]":
                var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                return re.lastIndex = source.lastIndex, re;

              case "[object Blob]":
                return new source.constructor([ source ], {
                    type: source.type
                });
            }
            if (isFunction(source.cloneNode)) return source.cloneNode(!0);
        }
        var stackSource = [], stackDest = [];
        if (maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN, destination) {
            if (isTypedArray(destination) || isArrayBuffer(destination)) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            return isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                "$$hashKey" !== key && delete destination[key];
            }), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination, maxDepth);
        }
        return copyElement(source, maxDepth);
    }
    function simpleCompare(a, b) {
        return a === b || a !== a && b !== b;
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1;
        if (t1 === typeof o2 && "object" === t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return !!isDate(o2) && simpleCompare(o1.getTime(), o2.getTime());
                if (isRegExp(o1)) return !!isRegExp(o2) && o1.toString() === o2.toString();
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                keySet = createMap();
                for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key])) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) === o2.length) {
                for (key = 0; key < length; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        if (!isUndefined(obj)) return isNumber(pretty) || (pretty = pretty ? 2 : null), 
        JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, "");
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        return addDateMinutes(date, reverse * (timezoneToOffset(timezone, dateTimezoneOffset) - dateTimezoneOffset));
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            var splitPoint, key, val;
            keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), splitPoint = keyValue.indexOf("="), 
            -1 !== splitPoint && (key = keyValue.substring(0, splitPoint), val = keyValue.substring(splitPoint + 1)), 
            key = tryDecodeURIComponent(key), isDefined(key) && (val = !isDefined(val) || tryDecodeURIComponent(val), 
            hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val));
        }), obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (!0 === arrayValue ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (!0 === value ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
        return null;
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        if (forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, 
            module = element.getAttribute(name));
        }), forEach(ngAttrPrefixes, function(prefix) {
            var candidate, name = prefix + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, 
            module = candidate.getAttribute(name));
        }), appElement) {
            if (!isAutoBootstrapAllowed) return void window.console.error("Angular: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.");
            config.strictDi = null !== getNgAttribute(appElement, "strict-di"), bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        isObject(config) || (config = {}), config = extend({
            strictDi: !1
        }, config);
        var doBootstrap = function() {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === window.document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [], modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(!0);
            } ]), modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, 
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
        angular.resumeBootstrap = function(extraModules) {
            return forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }, void (isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()));
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
        return injector.get("$$testability");
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; i < len; i++) key = keys[i], 
        obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
    }
    function getBlockNodes(nodes) {
        for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++) (blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))), 
        blockNodes.push(node));
        return blockNodes || nodes;
    }
    function createMap() {
        return Object.create(null);
    }
    function stringify(value) {
        if (null == value) return "";
        switch (typeof value) {
          case "string":
            break;

          case "number":
            value = "" + value;
            break;

          default:
            value = !hasCustomToString(value) || isArray(value) || isDate(value) ? toJson(value) : value.toString();
        }
        return value;
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var info = {};
                return function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                }(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue || (queue = invokeQueue), function() {
                            return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    function invokeLaterAndSetModuleName(provider, method, queue) {
                        return queue || (queue = invokeQueue), function(recipeName, factoryFunction) {
                            return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), 
                            queue.push([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        info: function(value) {
                            if (isDefined(value)) {
                                if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                return info = value, this;
                            }
                            return info;
                        },
                        requires: requires,
                        name: name,
                        provider: invokeLaterAndSetModuleName("$provide", "provider"),
                        factory: invokeLaterAndSetModuleName("$provide", "factory"),
                        service: invokeLaterAndSetModuleName("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                        animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                        filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                        controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                        directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                        component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                });
            };
        });
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
        }
        return dst || src;
    }
    function serializeObject(obj, maxDepth) {
        var seen = [];
        return isValidObjectMaxDepth(maxDepth) && (obj = copy(obj, null, maxDepth)), JSON.stringify(obj, function(key, val) {
            if (val = toJsonReplacer(key, val), isObject(val)) {
                if (seen.indexOf(val) >= 0) return "...";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj, maxDepth) {
        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? serializeObject(obj, maxDepth) : obj;
    }
    function jqNextId() {
        return ++jqId;
    }
    function cssKebabToCamel(name) {
        return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
    }
    function fnCamelCaseReplace(all, letter) {
        return letter.toUpperCase();
    }
    function kebabToCamel(name) {
        return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) return !0;
        return !1;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
            for (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
            i = wrap[0]; i--; ) tmp = tmp.lastChild;
            nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
            fragment.appendChild(node);
        }), fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [];
    }
    function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        parent && parent.replaceChild(wrapper, node), wrapper.appendChild(node);
    }
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        var argIsString;
        if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
            if (argIsString && "<" !== element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : isFunction(element) ? jqLiteReady(element) : jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        !onlyDescendants && jqLiteAcceptsData(element) && jqLite.cleanData([ element ]), 
        element.querySelectorAll && jqLite.cleanData(element.querySelectorAll("*"));
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
        if (handle) if (type) {
            var removeHandler = function(type) {
                var listenerFns = events[type];
                isDefined(fn) && arrayRemove(listenerFns || [], fn), isDefined(fn) && listenerFns && listenerFns.length > 0 || (element.removeEventListener(type, handle), 
                delete events[type]);
            };
            forEach(type.split(" "), function(type) {
                removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type]);
            });
        } else for (type in events) "$destroy" !== type && element.removeEventListener(type, handle), 
        delete events[type];
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) return void delete expandoStore.data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), 
            jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = void 0;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), 
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: void 0
        }), expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var prop, isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
            if (isSimpleSetter) data[kebabToCamel(key)] = value; else {
                if (massGetter) return data;
                if (isSimpleGetter) return data && data[kebabToCamel(key)];
                for (prop in key) data[kebabToCamel(prop)] = key[prop];
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return !!element.getAttribute && (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
        });
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
            }), element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) if (elements.nodeType) root[root.length++] = elements; else {
            var length = elements.length;
            if ("number" == typeof length && elements.window !== elements) {
                if (length) for (var i = 0; i < length; i++) root[root.length++] = elements[i];
            } else root[root.length++] = elements;
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType === NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [ name ]; element; ) {
            for (var i = 0, ii = names.length; i < ii; i++) if (isDefined(value = jqLite.data(element, names[i]))) return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
    }
    function jqLiteRemove(element, keepData) {
        keepData || jqLiteDealoc(element);
        var parent = element.parentNode;
        parent && parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action);
    }
    function jqLiteReady(fn) {
        function trigger() {
            window.document.removeEventListener("DOMContentLoaded", trigger), window.removeEventListener("load", trigger), 
            fn();
        }
        "complete" === window.document.readyState ? window.setTimeout(fn) : (window.document.addEventListener("DOMContentLoaded", trigger), 
        window.addEventListener("load", trigger));
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function() {
                        event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), 
                        originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                    };
                }
                event.isImmediatePropagationStopped = function() {
                    return !0 === event.immediatePropagationStopped;
                };
                var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                for (var i = 0; i < eventFnsLength; i++) event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i]);
            }
        };
        return eventHandler.elem = element, eventHandler;
    }
    function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
    }
    function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        related && (related === target || jqLiteContains.call(target, related)) || handler.call(target, event);
    }
    function $$jqLiteProvider() {
        this.$get = function() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
        var objType = typeof obj;
        return key = "function" === objType || "object" === objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
    }
    function NgMapShim() {
        this._keys = [], this._values = [], this._lastKey = NaN, this._lastIndex = -1;
    }
    function stringifyFn(fn) {
        return Function.prototype.toString.call(fn);
    }
    function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, "");
        return fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
    }
    function anonFn(fn) {
        var args = extractArgs(fn);
        return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, argDecl, last;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [], fn.length) {
                    if (strictDi) throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    argDecl = extractArgs(fn), forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        function supportObject(delegate) {
            return function(key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value);
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
            !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: !1 !== enforce ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), !1);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                if (!loadedModules.get(module)) {
                    loadedModules.set(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module), instanceInjector.modules[module] = moduleFn, 
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller), 
                    cache[serviceName];
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function injectionArgs(fn, locals, serviceName) {
                for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; i < length; i++) {
                    var key = $inject[i];
                    if ("string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                return args;
            }
            function isClass(func) {
                if (msie || "function" != typeof func) return !1;
                var result = func.$$ngIsClass;
                return isBoolean(result) || (result = func.$$ngIsClass = /^(?:class\b|constructor\()/.test(stringifyFn(func))), 
                result;
            }
            function invoke(fn, self, locals, serviceName) {
                "string" == typeof locals && (serviceName = locals, locals = null);
                var args = injectionArgs(fn, locals, serviceName);
                return isArray(fn) && (fn = fn[fn.length - 1]), isClass(fn) ? (args.unshift(null), 
                new (Function.prototype.bind.apply(fn, args))()) : fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var ctor = isArray(Type) ? Type[Type.length - 1] : Type, args = injectionArgs(Type, locals, serviceName);
                return args.unshift(null), new (Function.prototype.bind.apply(ctor, args))();
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
        strictDi = !0 === strictDi;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new NgMap(), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, void 0, serviceName);
        }), instanceInjector = protoInstanceInjector;
        providerCache["$injector" + providerSuffix] = {
            $get: valueFn(protoInstanceInjector)
        }, instanceInjector.modules = providerInjector.modules = createMap();
        var runBlocks = loadModules(modulesToLoad);
        return instanceInjector = protoInstanceInjector.get("$injector"), instanceInjector.strictDi = strictDi, 
        forEach(runBlocks, function(fn) {
            fn && instanceInjector.invoke(fn);
        }), instanceInjector;
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return Array.prototype.some.call(list, function(element) {
                    if ("a" === nodeName_(element)) return result = element, !0;
                }), result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                    var elem = offset[0], style = $window.getComputedStyle(elem);
                    offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom;
                } else isNumber(offset) || (offset = 0);
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else $window.scrollTo(0, 0);
            }
            function scroll(hash) {
                hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                var elm;
                hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null);
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function(newVal, oldVal) {
                newVal === oldVal && "" === newVal || jqLiteDocumentLoaded(function() {
                    $rootScope.$evalAsync(scroll);
                });
            }), scroll;
        } ];
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function splitClasses(classes) {
        isString(classes) && (classes = classes.split(" "));
        var obj = createMap();
        return forEach(classes, function(klass) {
            klass.length && (obj[klass] = !0);
        }), obj;
    }
    function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                if (0 === --outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return -1 === index ? "" : url.substr(index);
        }
        function cacheStateAndFireUrlChange() {
            pendingLocation = null, fireStateOrUrlChange();
        }
        function cacheState() {
            cachedState = getCurrentState(), cachedState = isUndefined(cachedState) ? null : cachedState, 
            equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState, 
            lastHistoryState = cachedState;
        }
        function fireStateOrUrlChange() {
            var prevLastHistoryState = lastHistoryState;
            cacheState(), lastBrowserUrl === self.url() && prevLastHistoryState === cachedState || (lastBrowserUrl = self.url(), 
            lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            }));
        }
        var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        }, self.notifyWhenNoOutstandingRequests = function(callback) {
            0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback);
        };
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = $sniffer.history ? function() {
            try {
                return history.state;
            } catch (e) {}
        } : noop;
        cacheState(), self.url = function(url, replace, state) {
            if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), 
            history !== window.history && (history = window.history), url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url), 
                replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url, 
                location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), 
                cacheState()), pendingLocation && (pendingLocation = url), self;
            }
            return pendingLocation || location.href.replace(/%27/g, "'");
        }, self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), 
            jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), 
            urlChangeListeners.push(callback), callback;
        }, self.$$applicationDestroyed = function() {
            jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
        }, self.$$checkUrlChange = fireStateOrUrlChange, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?:)?\/\/[^\/]*/, "") : "";
        }, self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
        }, self.defer.cancel = function(deferId) {
            return !!pendingDeferIds[deferId] && (delete pendingDeferIds[deferId], clearTimeout(deferId), 
            completeOutstandingRequest(noop), !0);
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry !== freshEnd && (staleEnd ? staleEnd === entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry !== prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (!isUndefined(value)) {
                            if (capacity < Number.MAX_VALUE) {
                                refresh(lruHash[key] || (lruHash[key] = {
                                    key: key
                                }));
                            }
                            return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                            value;
                        }
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry === freshEnd && (freshEnd = lruEntry.p), lruEntry === staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        key in data && (delete data[key], size--);
                    },
                    removeAll: function() {
                        data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null, stats = null, lruHash = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    function UNINITIALIZED_VALUE() {}
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/, bindings = createMap();
            return forEach(scope, function(definition, scopeName) {
                if (definition in bindingCache) return void (bindings[scopeName] = bindingCache[definition]);
                var match = definition.match(LOCAL_REGEXP);
                if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: "*" === match[2],
                    optional: "?" === match[3],
                    attrName: match[4] || scopeName
                }, match[4] && (bindingCache[definition] = bindings[scopeName]);
            }), bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
                isolateScope: null,
                bindToController: null
            };
            if (isObject(directive.scope) && (!0 === directive.bindToController ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), 
            bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), 
            isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), 
            bindings.bindToController && !directive.controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            return bindings;
        }
        function assertValidDirectiveName(name) {
            var letter = name.charAt(0);
            if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
            if (name !== name.trim()) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
        }
        function getDirectiveRequire(directive) {
            var require = directive.require || directive.controller && directive.name;
            return !isArray(require) && isObject(require) && forEach(require, function(value, key) {
                var match = value.match(REQUIRE_PREFIX_REGEXP);
                value.substring(match[0].length) || (require[key] = match[0] + key);
            }), require;
        }
        function getDirectiveRestrict(restrict, name) {
            if (restrict && (!isString(restrict) || !/[EACM]/.test(restrict))) throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
            return restrict || "EA";
        }
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/, bindingCache = createMap();
        this.directive = function registerDirective(name, directiveFactory) {
            return assertArg(name, "name"), assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertValidDirectiveName(name), 
            assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], 
            $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = getDirectiveRequire(directive), directive.restrict = getDirectiveRestrict(directive.restrict, name), 
                        directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.component = function(name, options) {
            function factory($injector) {
                function makeInjectable(fn) {
                    return isFunction(fn) || isArray(fn) ? function(tElement, tAttrs) {
                        return $injector.invoke(fn, this, {
                            $element: tElement,
                            $attrs: tAttrs
                        });
                    } : fn;
                }
                var template = options.template || options.templateUrl ? options.template : "", ddo = {
                    controller: controller,
                    controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                    template: makeInjectable(template),
                    templateUrl: makeInjectable(options.templateUrl),
                    transclude: options.transclude,
                    scope: {},
                    bindToController: options.bindings || {},
                    restrict: "E",
                    require: options.require
                };
                return forEach(options, function(val, key) {
                    "$" === key.charAt(0) && (ddo[key] = val);
                }), ddo;
            }
            var controller = options.controller || function() {};
            return forEach(options, function(val, key) {
                "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val));
            }), factory.$inject = [ "$injector" ], this.directive(name, factory);
        }, this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        };
        var debugInfoEnabled = !0;
        this.debugInfoEnabled = function(enabled) {
            return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
        };
        var preAssignBindingsEnabled = !1;
        this.preAssignBindingsEnabled = function(enabled) {
            return isDefined(enabled) ? (preAssignBindingsEnabled = enabled, this) : preAssignBindingsEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
            return arguments.length ? (TTL = value, this) : TTL;
        };
        var commentDirectivesEnabledConfig = !0;
        this.commentDirectivesEnabled = function(value) {
            return arguments.length ? (commentDirectivesEnabledConfig = value, this) : commentDirectivesEnabledConfig;
        };
        var cssClassDirectivesEnabledConfig = !0;
        this.cssClassDirectivesEnabled = function(value) {
            return arguments.length ? (cssClassDirectivesEnabledConfig = value, this) : cssClassDirectivesEnabledConfig;
        }, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
            function flushOnChangesQueue() {
                try {
                    if (!--onChangesTtl) throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                    $rootScope.$apply(function() {
                        for (var errors = [], i = 0, ii = onChangesQueue.length; i < ii; ++i) try {
                            onChangesQueue[i]();
                        } catch (e) {
                            errors.push(e);
                        }
                        if (onChangesQueue = void 0, errors.length) throw errors;
                    });
                } finally {
                    onChangesTtl++;
                }
            }
            function Attributes(element, attributesToCopy) {
                if (attributesToCopy) {
                    var i, l, key, keys = Object.keys(attributesToCopy);
                    for (i = 0, l = keys.length; i < l; i++) key = keys[i], this[key] = attributesToCopy[key];
                } else this.$attr = {};
                this.$$element = element;
            }
            function setSpecialAttr(element, attrName, value) {
                specialAttrHolder.innerHTML = "<span " + attrName + ">";
                var attributes = specialAttrHolder.firstChild.attributes, attribute = attributes[0];
                attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute);
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes));
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function(scope, cloneConnectFn, options) {
                    if (!$compileNodes) throw $compileMinErr("multilink", "This element has already been linked.");
                    assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new()), 
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), 
                    namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                    var $linkNode;
                    if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, 
                    transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), 
                    compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    cloneConnectFn || ($compileNodes = compositeLinkFn = null), $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                return node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html";
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], 
                        stableNodeList[idx] = nodeList[idx];
                    } else stableNodeList = nodeList;
                    for (i = 0, ii = linkFns.length; i < ii; ) node = stableNodeList[linkFns[i++]], 
                    nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
                    compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn);
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
                11 === msie && mergeConsecutiveTextNodes(nodeList, i, notLiveList), directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : void 0, ignoreDirective), 
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, 
                nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, 
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null;
            }
            function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                var sibling, node = nodeList[idx], parent = node.parentNode;
                if (node.nodeType === NODE_TYPE_TEXT) for (;(sibling = parent ? node.nextSibling : nodeList[idx + 1]) && sibling.nodeType === NODE_TYPE_TEXT; ) node.nodeValue = node.nodeValue + sibling.nodeValue, 
                sibling.parentNode && sibling.parentNode.removeChild(sibling), notLiveList && sibling === nodeList[idx + 1] && nodeList.splice(idx + 1, 1);
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), 
                    transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                }
                var boundSlots = boundTranscludeFn.$$slots = createMap();
                for (var slotName in transcludeFn.$$slots) transcludeFn.$$slots[slotName] ? boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : boundSlots[slotName] = null;
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, nodeName, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    nodeName = nodeName_(node), addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = !1, attrEndName = !1;
                        attr = nAttrs[j], name = attr.name, value = attr.value, ngAttrName = directiveNormalize(name), 
                        (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                            return letter.toUpperCase();
                        }));
                        var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                        multiElementMatch && directiveIsMultiElement(multiElementMatch[1]) && (attrStartName = name, 
                        attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), 
                        nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, !isNgAttr && attrs.hasOwnProperty(nName) || (attrs[nName] = value, 
                        getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), 
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    if ("input" === nodeName && "hidden" === node.getAttribute("type") && node.setAttribute("autocomplete", "off"), 
                    !cssClassDirectivesEnabled) break;
                    if (className = node.className, isObject(className) && (className = className.animVal), 
                    isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
                    addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    if (!commentDirectivesEnabled) break;
                    collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                }
                return directives.sort(byPriority), directives;
            }
            function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                try {
                    var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                    if (match) {
                        var nName = directiveNormalize(match[1]);
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2]));
                    }
                } catch (e) {}
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) do {
                    if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                    node.nodeType === NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, 
                    node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling;
                } while (depth > 0); else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function() {
                    return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext), 
                    $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                    pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                    post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                        var transcludeControllers;
                        if (isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn, 
                        cloneAttachFn = scope, scope = void 0), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
                        futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), 
                        !slotName) return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                        if (slotTranscludeFn) return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        if (isUndefined(slotTranscludeFn)) throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element));
                    }
                    var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                    compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), 
                    attrs = new Attributes($element, templateAttrs)), controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent), 
                    boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn, 
                    transcludeFn.isSlotFilled = function(slotName) {
                        return !!boundTranscludeFn.$$slots[slotName];
                    }), controllerDirectives && (elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)), 
                    newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), 
                    compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, 
                    scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective), 
                    scopeBindingInfo.removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches));
                    for (var name in elementControllers) {
                        var controllerDirective = controllerDirectives[name], controller = elementControllers[name], bindings = controllerDirective.$$bindings.bindToController;
                        if (preAssignBindingsEnabled) {
                            controller.bindingInfo = bindings ? initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective) : {};
                            var controllerResult = controller();
                            controllerResult !== controller.instance && (controller.instance = controllerResult, 
                            $element.data("$" + controllerDirective.name + "Controller", controllerResult), 
                            controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches(), 
                            controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective));
                        } else controller.instance = controller(), $element.data("$" + controllerDirective.name + "Controller", controller.instance), 
                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                    }
                    for (forEach(controllerDirectives, function(controllerDirective, name) {
                        var require = controllerDirective.require;
                        controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                    }), forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$onChanges)) try {
                            controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        if (isFunction(controllerInstance.$onInit)) try {
                            controllerInstance.$onInit();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        isFunction(controllerInstance.$doCheck) && (controllerScope.$watch(function() {
                            controllerInstance.$doCheck();
                        }), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", function() {
                            controllerInstance.$onDestroy();
                        });
                    }), i = 0, ii = preLinkFns.length; i < ii; i++) linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn), 
                    i = postLinkFns.length - 1; i >= 0; i--) linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        isFunction(controllerInstance.$postLink) && controllerInstance.$postLink();
                    });
                }
                previousCompileContext = previousCompileContext || {};
                for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0, 
                    terminalPriority > directive.priority) break;
                    if (directiveValue = directive.scope, directiveValue && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), 
                    newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), 
                    newScopeDirective = newScopeDirective || directive), directiveName = directive.name, 
                    !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                        for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                            mightHaveMultipleTransclusionError = !0;
                            break;
                        }
                        didScanForMultipleTransclusion = !0;
                    }
                    if (!directive.templateUrl && directive.controller && (controllerDirectives = controllerDirectives || createMap(), 
                    assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), directiveValue = directive.transclude) if (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" === directiveValue) hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                    $template[0].$$parentNode = $template[0].parentNode, childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }); else {
                        var slots = createMap();
                        if (isObject(directiveValue)) {
                            $template = [];
                            var slotMap = createMap(), filledSlots = createMap();
                            forEach(directiveValue, function(elementSelector, slotName) {
                                var optional = "?" === elementSelector.charAt(0);
                                elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName, 
                                slots[slotName] = null, filledSlots[slotName] = optional;
                            }), forEach($compileNode.contents(), function(node) {
                                var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || [], 
                                slots[slotName].push(node)) : $template.push(node);
                            }), forEach(filledSlots, function(filled, slotName) {
                                if (!filled) throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                            });
                            for (var slotName in slots) slots[slotName] && (slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn));
                        } else $template = jqLite(jqLiteClone(compileNode)).contents();
                        $compileNode.empty(), childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {
                            needsNewScope: directive.$$isolateScope || directive.$$newScope
                        }), childTranscludeFn.$$slots = slots;
                    }
                    if (directive.template) if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), 
                        compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective), 
                        directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directive.replace && (replaceDirective = directive), 
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                        var context = directive.$$originalDirective || directive;
                        isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && !0 === newScopeDirective.scope, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
            }
            function getControllers(directiveName, require, $element, elementControllers) {
                var value;
                if (isString(require)) {
                    var match = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(match[0].length), inheritType = match[1] || match[3], optional = "?" === match[2];
                    if ("^^" === inheritType ? $element = $element.parent() : (value = elementControllers && elementControllers[name], 
                    value = value && value.instance), !value) {
                        var dataName = "$" + name + "Controller";
                        value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                    }
                    if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                } else if (isArray(require)) {
                    value = [];
                    for (var i = 0, ii = require.length; i < ii; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                } else isObject(require) && (value = {}, forEach(require, function(controller, property) {
                    value[property] = getControllers(directiveName, controller, $element, elementControllers);
                }));
                return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                var elementControllers = createMap();
                for (var controllerKey in controllerDirectives) {
                    var directive = controllerDirectives[controllerKey], locals = {
                        $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                        $element: $element,
                        $attrs: attrs,
                        $transclude: transcludeFn
                    }, controller = directive.controller;
                    "@" === controller && (controller = attrs[directive.name]);
                    var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                    elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                }
                return elementControllers;
            }
            function markDirectiveScope(directives, isolateScope, newScope) {
                for (var j = 0, jj = directives.length; j < jj; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: isolateScope,
                    $$newScope: newScope
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) if (directive = directives[i], 
                (isUndefined(maxPriority) || maxPriority > directive.priority) && -1 !== directive.restrict.indexOf(location)) {
                    if (startAttrName && (directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                    })), !directive.$$bindings) {
                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                        isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope);
                    }
                    tDirectives.push(directive), match = directive;
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) if (directive = directives[i], 
                directive.multiElement) return !0;
                return !1;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr;
                forEach(dst, function(value, key) {
                    "$" !== key.charAt(0) && (src[key] && src[key] !== value && (value.length ? value += ("style" === key ? ";" : " ") + src[key] : value = src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]));
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                return $compileNode.empty(), $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), 
                        compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        }, replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0), 
                        directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                    forEach($rootElement, function(node, i) {
                        node === compileNode && ($rootElement[i] = $compileNode[0]);
                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (!scope.$$destroyed) {
                            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                var oldClasses = beforeTemplateLinkNode.className;
                                previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                            }
                            childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                        }
                    }
                    linkQueue = null;
                }).catch(function(error) {
                    error instanceof Error && $exceptionHandler(error);
                }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)));
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                        return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                            var parent = node.parent();
                            hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), 
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
            function wrapTemplate(type, template) {
                switch (type = lowercase(type || "html")) {
                  case "svg":
                  case "math":
                    var wrapper = window.document.createElement("div");
                    return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" === attrNormalizedName) return $sce.HTML;
                var tag = nodeName_(node);
                if ("src" === attrNormalizedName || "ngSrc" === attrNormalizedName) {
                    if (-1 === [ "img", "video", "audio", "source", "track" ].indexOf(tag)) return $sce.RESOURCE_URL;
                } else if ("xlinkHref" === attrNormalizedName || "form" === tag && "action" === attrNormalizedName || "link" === tag && "href" === attrNormalizedName) return $sce.RESOURCE_URL;
            }
            function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                var trustedContext = getTrustedContext(node, name), mustHaveExpression = !isNgAttr, allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr, interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                if (interpolateFn) {
                    if ("multiple" === name && "select" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = createMap()), newValue = attr[name];
                                    newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), 
                                    value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, 
                                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue !== oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; i < ii; i++) if ($rootElement[i] === firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                    j2++) j2 < jj ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = window.document.createDocumentFragment();
                for (i = 0; i < removeCount; i++) fragment.appendChild(elementsToRemove[i]);
                for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)), 
                jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")), 
                i = 1; i < removeCount; i++) delete elementsToRemove[i];
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                function recordChanges(key, currentValue, previousValue) {
                    isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue) && (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue), 
                    onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)), 
                    changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue));
                }
                function triggerOnChangesHook() {
                    destination.$onChanges(changes), changes = void 0;
                }
                var changes, removeWatchCollection = [], initialChanges = {};
                return forEach(bindings, function(definition, scopeName) {
                    var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName, optional = definition.optional;
                    switch (definition.mode) {
                      case "@":
                        optional || hasOwnProperty.call(attrs, attrName) || (destination[scopeName] = attrs[attrName] = void 0), 
                        removeWatch = attrs.$observe(attrName, function(value) {
                            if (isString(value) || isBoolean(value)) {
                                var oldValue = destination[scopeName];
                                recordChanges(scopeName, value, oldValue), destination[scopeName] = value;
                            }
                        }), attrs.$$observers[attrName].$$scope = scope, lastValue = attrs[attrName], isString(lastValue) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue), 
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "=":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : simpleCompare, 
                        parentSet = parentGet.assign || function() {
                            throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                        }, lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function(parentValue) {
                            return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), 
                            lastValue = parentValue;
                        };
                        parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), 
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "<":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]);
                        var deepWatch = parentGet.literal, initialValue = destination[scopeName] = parentGet(scope);
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                        removeWatch = scope.$watch(parentGet, function(newValue, oldValue) {
                            if (oldValue === newValue) {
                                if (oldValue === initialValue || deepWatch && equals(oldValue, initialValue)) return;
                                oldValue = initialValue;
                            }
                            recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue;
                        }, deepWatch), removeWatchCollection.push(removeWatch);
                        break;

                      case "&":
                        if ((parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop) === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                    }
                }), {
                    initialChanges: initialChanges,
                    removeWatches: removeWatchCollection.length && function() {
                        for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) removeWatchCollection[i]();
                    }
                };
            }
            var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/, specialAttrHolder = window.document.createElement("div"), commentDirectivesEnabled = commentDirectivesEnabledConfig, cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig, onChangesTtl = TTL;
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key;
                    if (booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, 
                    observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key]) || (this.$attr[key] = attrName = snake_case(key, "-")), 
                    "a" === (nodeName = nodeName_(this.$$element)) && ("href" === key || "xlinkHref" === key) || "img" === nodeName && "src" === key) this[key] = value = $$sanitizeUri(value, "src" === key); else if ("img" === nodeName && "srcset" === key && isDefined(value)) {
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = 2 * i;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), !0), result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), !0), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), 
                        this[key] = value = result;
                    }
                    !1 !== writeAttr && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : SIMPLE_ATTR_NAME.test(attrName) ? this.$$element.attr(attrName, value) : setSpecialAttr(this.$$element[0], attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key]);
                    }), function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" === startSymbol && "}}" === endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/, MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
            return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                var bindings = $element.data("$binding") || [];
                isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), 
                $element.data("$binding", bindings);
            } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                safeAddClass($element, "ng-binding");
            } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop, compile.$$createComment = function(directiveName, comment) {
                var content = "";
                return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")), 
                window.document.createComment(content);
            }, compile;
        } ];
    }
    function SimpleChange(previous, current) {
        this.previousValue = previous, this.currentValue = current;
    }
    function directiveNormalize(name) {
        return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, fnCamelCaseReplace);
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) return jqNodes;
        for (;i--; ) {
            var node = jqNodes[i];
            (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && "" === node.nodeValue.trim()) && splice.call(jqNodes, i, 1);
        }
        return jqNodes;
    }
    function identifierForController(controller, ident) {
        if (ident && isString(ident)) return ident;
        if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match) return match[3];
        }
    }
    function $ControllerProvider() {
        var controllers = {}, globals = !1;
        this.has = function(name) {
            return controllers.hasOwnProperty(name);
        }, this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.allowGlobals = function() {
            globals = !0;
        }, this.$get = [ "$injector", "$window", function($injector, $window) {
            function addIdentifier(locals, identifier, instance, name) {
                if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                locals.$scope[identifier] = instance;
            }
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                if (later = !0 === later, ident && isString(ident) && (identifier = ident), isString(expression)) {
                    if (!(match = expression.match(CNTRL_REG))) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                    if (constructor = match[1], identifier = identifier || match[3], !(expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || (globals ? getter($window, constructor, !0) : void 0))) throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                    assertArgFn(expression, constructor, !0);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    return instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                    extend(function() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, 
                        identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), 
                        instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $$IsDocumentHiddenProvider() {
        this.$get = [ "$document", "$rootScope", function($document, $rootScope) {
            function changeListener() {
                hidden = doc.hidden;
            }
            var doc = $document[0], hidden = doc && doc.hidden;
            return $document.on("visibilitychange", changeListener), $rootScope.$on("$destroy", function() {
                $document.off("visibilitychange", changeListener);
            }), function() {
                return hidden;
            };
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function serializeValue(v) {
        return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v;
    }
    function $HttpParamSerializerProvider() {
        this.$get = function() {
            return function(params) {
                if (!params) return "";
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || (isArray(value) ? forEach(value, function(v) {
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                    }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))));
                }), parts.join("&");
            };
        };
    }
    function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
            return function(params) {
                function serialize(toSerialize, prefix, topLevel) {
                    null === toSerialize || isUndefined(toSerialize) || (isArray(toSerialize) ? forEach(toSerialize, function(value, index) {
                        serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                    }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function(value, key) {
                        serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                    }) : parts.push(encodeUriQuery(prefix) + "=" + encodeUriQuery(serializeValue(toSerialize))));
                }
                if (!params) return "";
                var parts = [];
                return serialize(params, "", !0), parts.join("&");
            };
        };
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                if (contentType && 0 === contentType.indexOf(APPLICATION_JSON) || isJsonLike(tempData)) try {
                    data = fromJson(tempData);
                } catch (e) {
                    throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"', data, e);
                }
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        function fillInParsed(key, val) {
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
        }
        var i, parsed = createMap();
        return isString(headers) ? forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
        }) : isObject(headers) && forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
        }), parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(name) {
            if (headersObj || (headersObj = parseHeaders(headers)), name) {
                var value = headersObj[lowercase(name)];
                return void 0 === value && (value = null), value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
            data = fn(data, headers, status);
        }), data);
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d);
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer",
            jsonpCallbackParam: "callback"
        }, useApplyAsync = !1;
        this.useApplyAsync = function(value) {
            return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
            function $http(requestConfig) {
                function chainInterceptors(promise, interceptors) {
                    for (var i = 0, ii = interceptors.length; i < ii; ) {
                        var thenFn = interceptors[i++], rejectFn = interceptors[i++];
                        promise = promise.then(thenFn, rejectFn);
                    }
                    return interceptors.length = 0, promise;
                }
                function completeOutstandingRequest() {
                    $browser.$$completeOutstandingRequest(noop);
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    return forEach(headers, function(headerFn, header) {
                        isFunction(headerFn) ? null != (headerContent = headerFn(config)) && (processedHeaders[header] = headerContent) : processedHeaders[header] = headerFn;
                    }), processedHeaders;
                }
                function serverRequest(config) {
                    var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
                    sendReq(config, reqData).then(transformResponse, transformResponse);
                }
                function transformResponse(response) {
                    var resp = extend({}, response);
                    return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse), 
                    isSuccess(response.status) ? resp : $q.reject(resp);
                }
                if (!isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                if (!isString($sce.valueOf(requestConfig.url))) throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer,
                    jsonpCallbackParam: defaults.jsonpCallbackParam
                }, requestConfig);
                config.headers = function(config) {
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }(requestConfig), config.method = uppercase(config.method), config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer, 
                $browser.$$incOutstandingRequestCount();
                var requestInterceptors = [], responseInterceptors = [], promise = $q.resolve(config);
                return forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError);
                }), promise = chainInterceptors(promise, requestInterceptors), promise = promise.then(serverRequest), 
                promise = chainInterceptors(promise, responseInterceptors), promise = promise.finally(completeOutstandingRequest);
            }
            function sendReq(config, reqData) {
                function createApplyHandlers(eventHandlers) {
                    if (eventHandlers) {
                        var applyHandlers = {};
                        return forEach(eventHandlers, function(eventHandler, key) {
                            applyHandlers[key] = function(event) {
                                function callEventHandler() {
                                    eventHandler(event);
                                }
                                useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler);
                            };
                        }), applyHandlers;
                    }
                }
                function done(status, response, headersString, statusText) {
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText ]) : cache.remove(url)), 
                    useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), 
                    $rootScope.$$phase || $rootScope.$apply());
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = status >= -1 ? status : 0, (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, isJsonp = "jsonp" === lowercase(config.method), url = config.url;
                if (isJsonp ? url = $sce.getTrustedResourceUrl(url) : isString(url) || (url = $sce.valueOf(url)), 
                url = buildUrl(url, config.paramSerializer(config.params)), isJsonp && (url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam)), 
                $http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                !config.cache && !defaults.cache || !1 === config.cache || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), 
                cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK") : cache.put(url, promise)), 
                isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                }
                return promise;
            }
            function buildUrl(url, serializedParams) {
                return serializedParams.length > 0 && (url += (-1 === url.indexOf("?") ? "?" : "&") + serializedParams), 
                url;
            }
            function sanitizeJsonpCallbackParam(url, key) {
                if (/[&?][^=]+=JSON_CALLBACK/.test(url)) throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                if (new RegExp("[&?]" + key + "=").test(url)) throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', key, url);
                return url += (-1 === url.indexOf("?") ? "?" : "&") + key + "=JSON_CALLBACK";
            }
            var defaultCache = $cacheFactory("$http");
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            return forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            }), $http.pendingRequests = [], function(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }("get", "delete", "head", "jsonp"), function(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }("post", "put", "patch"), $http.defaults = defaults, $http;
        } ];
    }
    function $xhrFactoryProvider() {
        this.$get = function() {
            return function() {
                return new window.XMLHttpRequest();
            };
        };
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
            return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackPath, done) {
            url = url.replace("JSON_CALLBACK", callbackPath);
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                script.removeEventListener("load", callback), script.removeEventListener("error", callback), 
                rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks.wasCalled(callbackPath) || (event = {
                    type: "error"
                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
            }, script.addEventListener("load", callback), script.addEventListener("error", callback), 
            rawDocument.body.appendChild(script), callback;
        }
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
            function timeoutRequest() {
                jsonpDone && jsonpDone(), xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 
                callback(status, response, headersString, statusText);
            }
            if (url = url || $browser.url(), "jsonp" === lowercase(method)) var callbackPath = callbacks.createCallback(url), jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                var response = 200 === status && callbacks.getResponse(callbackPath);
                completeRequest(callback, status, response, "", text), callbacks.removeCallback(callbackPath);
            }); else {
                var xhr = createXhr(method, url);
                xhr.open(method, url, !0), forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value);
                }), xhr.onload = function() {
                    var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                    0 === status && (status = response ? 200 : "file" === urlResolve(url).protocol ? 404 : 0), 
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                if (xhr.onerror = requestError, xhr.onabort = requestError, xhr.ontimeout = requestError, 
                forEach(eventHandlers, function(value, key) {
                    xhr.addEventListener(key, value);
                }), forEach(uploadEventHandlers, function(value, key) {
                    xhr.upload.addEventListener(key, value);
                }), withCredentials && (xhr.withCredentials = !0), responseType) try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if ("json" !== responseType) throw e;
                }
                xhr.send(isUndefined(post) ? null : post);
            }
            if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout); else isPromiseLike(timeout) && timeout.then(timeoutRequest);
        };
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                var unwatch = scope.$watch(function(scope) {
                    return unwatch(), constantInterp(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                function parseStringifyInterceptor(value) {
                    try {
                        return value = getValue(value), allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }
                if (!text.length || -1 === text.indexOf(startSymbol)) {
                    var constantInterp;
                    if (!mustHaveExpression) {
                        constantInterp = valueFn(unescapeText(text)), constantInterp.exp = text, constantInterp.expressions = [], 
                        constantInterp.$$watchDelegate = constantWatchDelegate;
                    }
                    return constantInterp;
                }
                allOrNothing = !!allOrNothing;
                for (var startIndex, endIndex, exp, index = 0, expressions = [], parseFns = [], textLength = text.length, concat = [], expressionPositions = []; index < textLength; ) {
                    if (-1 === (startIndex = text.indexOf(startSymbol, index)) || -1 === (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                        index !== textLength && concat.push(unescapeText(text.substring(index)));
                        break;
                    }
                    index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), 
                    exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), 
                    parseFns.push($parse(exp, parseStringifyInterceptor)), index = endIndex + endSymbolLength, 
                    expressionPositions.push(concat.length), concat.push("");
                }
                if (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), 
                !mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    }, getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    return extend(function(context) {
                        var i = 0, ii = expressions.length, values = new Array(ii);
                        try {
                            for (;i < ii; i++) values[i] = parseFns[i](context);
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function(values, oldValues) {
                                var currValue = compute(values);
                                isFunction(listener) && listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), 
                                lastValue = currValue;
                            });
                        }
                    });
                }
            }
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", "$browser", function($rootScope, $window, $q, $$q, $browser) {
            function interval(fn, delay, count, invokeApply) {
                function callback() {
                    hasParams ? fn.apply(null, args) : fn(iteration);
                }
                var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return count = isDefined(count) ? count : 0, promise.$$intervalId = setInterval(function() {
                    skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++), 
                    count > 0 && iteration >= count && (deferred.resolve(iteration), clearInterval(promise.$$intervalId), 
                    delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
                }, delay), intervals[promise.$$intervalId] = deferred, promise;
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                return !!(promise && promise.$$intervalId in intervals) && (intervals[promise.$$intervalId].promise.catch(noop), 
                intervals[promise.$$intervalId].reject("canceled"), $window.clearInterval(promise.$$intervalId), 
                delete intervals[promise.$$intervalId], !0);
            }, interval;
        } ];
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(url, locationObj) {
        if (DOUBLE_SLASH_REGEX.test(url)) throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
        var prefixed = "/" !== url.charAt(0);
        prefixed && (url = "/" + url);
        var match = urlResolve(url);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), 
        locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
        locationObj.$$path && "/" !== locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function startsWith(str, search) {
        return str.slice(0, search.length) === search;
    }
    function stripBaseUrl(base, url) {
        if (startsWith(url, base)) return url.substr(base.length);
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 === index ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), 
        this.$$parse = function(url) {
            var pathUrl = stripBaseUrl(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1), 
            this.$$urlUpdatedByLocation = !0;
        }, this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var appUrl, prevAppUrl, rewrittenUrl;
            return isDefined(appUrl = stripBaseUrl(appBase, url)) ? (prevAppUrl = appUrl, rewrittenUrl = basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
            isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", 
            isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : (withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl), 
            isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)), parseAppUrl(withoutHashUrl, this), 
            this.$$path = function(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return startsWith(url, base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), 
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
            }(this.$$path, withoutHashUrl, appBase), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : ""), 
            this.$$urlUpdatedByLocation = !0;
        }, this.$$parseLinkUrl = function(url, relHref) {
            return stripHash(appBase) === stripHash(url) && (this.$$parse(url), !0);
        };
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var rewrittenUrl, appUrl;
            return appBase === stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url, 
            this.$$urlUpdatedByLocation = !0;
        };
    }
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "!", html5Mode = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), 
            isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) && (html5Mode.rewriteLinks = mode.rewriteLinks), 
            this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url(), oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state), $location.$$state = $browser.state();
                } catch (e) {
                    throw $location.url(oldUrl), $location.$$state = oldState, e;
                }
            }
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), 
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            $rootElement.on("click", function(event) {
                var rewriteLinks = html5Mode.rewriteLinks;
                if (rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 !== event.which && 2 !== event.button) {
                    for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    if (!isString(rewriteLinks) || !isUndefined(elm.attr(rewriteLinks))) {
                        var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                        isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                        IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
                        $location.absUrl() !== $browser.url() && ($rootScope.$apply(), $window.angular["ff-684208-preventDefault"] = !0));
                    }
                }
            }), trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl) && $browser.url($location.absUrl(), !0);
            var initializing = !0;
            return $browser.onUrlChange(function(newUrl, newState) {
                return startsWith(newUrl, appBaseNoFile) ? ($rootScope.$evalAsync(function() {
                    var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                    newUrl = trimEmptyHash(newUrl), $location.$$parse(newUrl), $location.$$state = newState, 
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, 
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, 
                    afterLocationChange(oldUrl, oldState)));
                }), void ($rootScope.$$phase || $rootScope.$digest())) : void ($window.location.href = newUrl);
            }), $rootScope.$watch(function() {
                if (initializing || $location.$$urlUpdatedByLocation) {
                    $location.$$urlUpdatedByLocation = !1;
                    var oldUrl = trimEmptyHash($browser.url()), newUrl = trimEmptyHash($location.absUrl()), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                    (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                        var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                        $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), 
                        afterLocationChange(oldUrl, oldState)));
                    }));
                }
                $location.$$replace = !1;
            }), $location;
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            function formatError(arg) {
                return arg instanceof Error && (arg.stack && formatStackTrace ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                return hasApply ? function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    }), logFn.apply(console, args);
                } : function(arg1, arg2) {
                    logFn(arg1, null == arg2 ? "" : arg2);
                };
            }
            var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments);
                    };
                }()
            };
        } ];
    }
    function getStringValue(name) {
        return name + "";
    }
    function ifDefined(v, d) {
        return void 0 !== v ? v : d;
    }
    function plusFn(l, r) {
        return void 0 === l ? r : void 0 === r ? l : l + r;
    }
    function isStateless($filter, filterName) {
        return !$filter(filterName).$stateful;
    }
    function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants, argsToWatch, isStatelessFilter;
        switch (ast.type) {
          case AST.Program:
            allConstants = !0, forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter), allConstants = allConstants && expr.expression.constant;
            }), ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = !0, ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter), ast.constant = ast.argument.constant, 
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter), findConstantAndWatchExpressions(ast.alternate, $filter), 
            findConstantAndWatchExpressions(ast.consequent, $filter), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, 
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = !1, ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter), ast.computed && findConstantAndWatchExpressions(ast.property, $filter), 
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), 
            ast.toWatch = [ ast ];
            break;

          case AST.CallExpression:
            isStatelessFilter = !!ast.filter && isStateless($filter, ast.callee.name), allConstants = isStatelessFilter, 
            argsToWatch = [], forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, 
                expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, 
                expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter), allConstants = allConstants && property.value.constant && !property.computed, 
                property.value.constant || argsToWatch.push.apply(argsToWatch, property.value.toWatch), 
                property.computed && (findConstantAndWatchExpressions(property.key, $filter), property.key.constant || argsToWatch.push.apply(argsToWatch, property.key.toWatch));
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
            ast.constant = !1, ast.toWatch = [];
            break;

          case AST.LocalsExpression:
            ast.constant = !1, ast.toWatch = [];
        }
    }
    function getInputs(body) {
        if (1 === body.length) {
            var lastExpression = body[0].expression, candidate = lastExpression.toWatch;
            return 1 !== candidate.length ? candidate : candidate[0] !== lastExpression ? candidate : void 0;
        }
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        if (1 === ast.body.length && isAssignable(ast.body[0].expression)) return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {
                type: AST.NGValueParameter
            },
            operator: "="
        };
    }
    function isLiteral(ast) {
        return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
        return ast.constant;
    }
    function ASTCompiler($filter) {
        this.$filter = $filter;
    }
    function ASTInterpreter($filter) {
        this.$filter = $filter;
    }
    function Parser(lexer, $filter, options) {
        this.ast = new AST(lexer, options), this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var identStart, identContinue, cache = createMap(), literals = {
            true: !0,
            false: !1,
            null: null,
            undefined: void 0
        };
        this.addLiteral = function(literalName, literalValue) {
            literals[literalName] = literalValue;
        }, this.setIdentifierFns = function(identifierStart, identifierContinue) {
            return identStart = identifierStart, identContinue = identifierContinue, this;
        }, this.$get = [ "$filter", function($filter) {
            function $parse(exp, interceptorFn) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    if (exp = exp.trim(), cacheKey = exp, !(parsedExpression = cache[cacheKey])) {
                        ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2));
                        parsedExpression = new Parser(new Lexer($parseOptions), $filter, $parseOptions).parse(exp), 
                        parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : oneTime ? (parsedExpression.oneTime = !0, 
                        parsedExpression.$$watchDelegate = oneTimeWatchDelegate) : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), 
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : !("object" == typeof newValue && "object" == typeof (newValue = getValueOf(newValue)) && !compareObjectIdentity) && (newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue);
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var lastResult, inputExpressions = parsedExpression.inputs;
                if (1 === inputExpressions.length) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    return inputExpressions = inputExpressions[0], scope.$watch(function(scope) {
                        var newInputValue = inputExpressions(scope);
                        return expressionInputDirtyCheck(newInputValue, oldInputValueOf, parsedExpression.literal) || (lastResult = parsedExpression(scope, void 0, void 0, [ newInputValue ]), 
                        oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; i < ii; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, 
                oldInputValues[i] = null;
                return scope.$watch(function(scope) {
                    for (var changed = !1, i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], parsedExpression.literal))) && (oldInputValues[i] = newInputValue, 
                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                    }
                    return changed && (lastResult = parsedExpression(scope, void 0, void 0, oldInputValues)), 
                    lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }
                function oneTimeListener(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener(value, old, scope), isDone(value) && scope.$$postDigest(function() {
                        isDone(lastValue) && unwatch();
                    });
                }
                var unwatch, lastValue, isDone = parsedExpression.literal ? isAllDefined : isDefined;
                return unwatch = parsedExpression.inputs ? inputsWatchDelegate(scope, oneTimeListener, objectEquality, parsedExpression, prettyPrintExpression) : scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);
            }
            function isAllDefined(value) {
                var allDefined = !0;
                return forEach(value, function(val) {
                    isDefined(val) || (allDefined = !1);
                }), allDefined;
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch = scope.$watch(function(scope) {
                    return unwatch(), parsedExpression(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                function regularInterceptedExpression(scope, locals, assign, inputs) {
                    var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value, scope, locals);
                }
                function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                    var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs), result = interceptorFn(value, scope, locals);
                    return isDone(value) ? result : value;
                }
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate, useInputs = !1, isDone = parsedExpression.literal ? isAllDefined : isDefined, fn = parsedExpression.oneTime ? oneTimeInterceptedExpression : regularInterceptedExpression;
                return fn.literal = parsedExpression.literal, fn.oneTime = parsedExpression.oneTime, 
                useInputs = !parsedExpression.inputs, watchDelegate && watchDelegate !== inputsWatchDelegate ? (fn.$$watchDelegate = watchDelegate, 
                fn.inputs = parsedExpression.inputs) : interceptorFn.$stateful || (fn.$$watchDelegate = inputsWatchDelegate, 
                fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ]), 
                fn;
            }
            var noUnsafeEval = csp().noUnsafeEval, $parseOptions = {
                csp: noUnsafeEval,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
            };
            return $parse;
        } ];
    }
    function $QProvider() {
        var errorOnUnhandledRejections = !0;
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ], this.errorOnUnhandledRejections = function(value) {
            return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
        };
    }
    function $$QProvider() {
        var errorOnUnhandledRejections = !0;
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ], this.errorOnUnhandledRejections = function(value) {
            return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
        };
    }
    function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
        function defer() {
            return new Deferred();
        }
        function Deferred() {
            var promise = this.promise = new Promise();
            this.resolve = function(val) {
                resolvePromise(promise, val);
            }, this.reject = function(reason) {
                rejectPromise(promise, reason);
            }, this.notify = function(progress) {
                notifyPromise(promise, progress);
            };
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending, state.processScheduled = !1, state.pending = void 0;
            try {
                for (var i = 0, ii = pending.length; i < ii; ++i) {
                    state.pur = !0, promise = pending[i][0], fn = pending[i][state.status];
                    try {
                        isFunction(fn) ? resolvePromise(promise, fn(state.value)) : 1 === state.status ? resolvePromise(promise, state.value) : rejectPromise(promise, state.value);
                    } catch (e) {
                        rejectPromise(promise, e);
                    }
                }
            } finally {
                --queueSize, errorOnUnhandledRejections && 0 === queueSize && nextTick(processChecks);
            }
        }
        function processChecks() {
            for (;!queueSize && checkQueue.length; ) {
                var toCheck = checkQueue.shift();
                if (!toCheck.pur) {
                    toCheck.pur = !0;
                    var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                    toCheck.value instanceof Error ? exceptionHandler(toCheck.value, errorMessage) : exceptionHandler(errorMessage);
                }
            }
        }
        function scheduleProcessQueue(state) {
            !errorOnUnhandledRejections || state.pending || 2 !== state.status || state.pur || (0 === queueSize && 0 === checkQueue.length && nextTick(processChecks), 
            checkQueue.push(state)), !state.processScheduled && state.pending && (state.processScheduled = !0, 
            ++queueSize, nextTick(function() {
                processQueue(state);
            }));
        }
        function resolvePromise(promise, val) {
            promise.$$state.status || (val === promise ? $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : $$resolve(promise, val));
        }
        function $$resolve(promise, val) {
            function doResolve(val) {
                done || (done = !0, $$resolve(promise, val));
            }
            function doReject(val) {
                done || (done = !0, $$reject(promise, val));
            }
            function doNotify(progress) {
                notifyPromise(promise, progress);
            }
            var then, done = !1;
            try {
                (isObject(val) || isFunction(val)) && (then = val.then), isFunction(then) ? (promise.$$state.status = -1, 
                then.call(val, doResolve, doReject, doNotify)) : (promise.$$state.value = val, promise.$$state.status = 1, 
                scheduleProcessQueue(promise.$$state));
            } catch (e) {
                doReject(e);
            }
        }
        function rejectPromise(promise, reason) {
            promise.$$state.status || $$reject(promise, reason);
        }
        function $$reject(promise, reason) {
            promise.$$state.value = reason, promise.$$state.status = 2, scheduleProcessQueue(promise.$$state);
        }
        function notifyPromise(promise, progress) {
            var callbacks = promise.$$state.pending;
            promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                for (var callback, result, i = 0, ii = callbacks.length; i < ii; i++) {
                    result = callbacks[i][0], callback = callbacks[i][3];
                    try {
                        notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                    } catch (e) {
                        exceptionHandler(e);
                    }
                }
            });
        }
        function reject(reason) {
            var result = new Promise();
            return rejectPromise(result, reason), result;
        }
        function handleCallback(value, resolver, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback());
            } catch (e) {
                return reject(e);
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                return resolver(value);
            }, reject) : resolver(value);
        }
        function when(value, callback, errback, progressBack) {
            var result = new Promise();
            return resolvePromise(result, value), result.then(callback, errback, progressBack);
        }
        function all(promises) {
            var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, when(promise).then(function(value) {
                    results[key] = value, --counter || resolvePromise(result, results);
                }, function(reason) {
                    rejectPromise(result, reason);
                });
            }), 0 === counter && resolvePromise(result, results), result;
        }
        function race(promises) {
            var deferred = defer();
            return forEach(promises, function(promise) {
                when(promise).then(deferred.resolve, deferred.reject);
            }), deferred.promise;
        }
        function $Q(resolver) {
            function resolveFn(value) {
                resolvePromise(promise, value);
            }
            function rejectFn(reason) {
                rejectPromise(promise, reason);
            }
            if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            var promise = new Promise();
            return resolver(resolveFn, rejectFn), promise;
        }
        var $qMinErr = minErr("$q", TypeError), queueSize = 0, checkQueue = [];
        extend(Promise.prototype, {
            then: function(onFulfilled, onRejected, progressBack) {
                if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) return this;
                var result = new Promise();
                return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]), 
                this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result;
            },
            catch: function(callback) {
                return this.then(null, callback);
            },
            finally: function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, resolve, callback);
                }, function(error) {
                    return handleCallback(error, reject, callback);
                }, progressBack);
            }
        });
        var resolve = when;
        return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when, 
        $Q.resolve = resolve, $Q.all = all, $Q.race = race, $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            return raf.supported = rafSupported, raf;
        } ];
    }
    function $RootScopeProvider() {
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), 
                this.$$ChildScope = null;
            }
            return ChildScope.prototype = parent, ChildScope;
        }
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value), TTL;
        }, this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = !0;
            }
            function cleanUpScope($scope) {
                9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)), 
                $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
            }
            function Scope() {
                this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                this.$root = this, this.$$destroyed = !1, this.$$listeners = {}, this.$$listenerCount = {}, 
                this.$$watchersCount = 0, this.$$isolateBindings = null;
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do {
                    current.$$watchersCount += count;
                } while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name];
                } while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                for (;applyAsyncQueue.length; ) try {
                    applyAsyncQueue.shift()();
                } catch (e) {
                    $exceptionHandler(e);
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                    $rootScope.$apply(flushApplyAsync);
                }));
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    return parent = parent || this, isolate ? (child = new Scope(), child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)), 
                    child = new this.$$ChildScope()), child.$parent = parent, child.$$prevSibling = parent.$$childTail, 
                    parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, 
                    (isolate || parent !== this) && child.$on("$destroy", destroyChildScope), child;
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    return lastDirtyWatch = null, isFunction(listener) || (watcher.fn = noop), array || (array = scope.$$watchers = [], 
                    array.$$digestWatchIndex = -1), array.unshift(watcher), array.$$digestWatchIndex++, 
                    incrementWatchersCount(this, 1), function() {
                        var index = arrayRemove(array, watcher);
                        index >= 0 && (incrementWatchersCount(scope, -1), index < array.$$digestWatchIndex && array.$$digestWatchIndex--), 
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    function watchGroupAction() {
                        changeReactionScheduled = !1, firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                    }
                    var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                    if (!watchExpressions.length) {
                        var shouldCall = !0;
                        return self.$evalAsync(function() {
                            shouldCall && listener(newValues, newValues, self);
                        }), function() {
                            shouldCall = !1;
                        };
                    }
                    return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                        newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    }) : (forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function(value, oldValue) {
                            newValues[i] = value, oldValues[i] = oldValue, changeReactionScheduled || (changeReactionScheduled = !0, 
                            self.$evalAsync(watchGroupAction));
                        });
                        deregisterFns.push(unwatchFn);
                    }), function() {
                        for (;deregisterFns.length; ) deregisterFns.shift()();
                    });
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, newItem, oldItem;
                        if (!isUndefined(newValue)) {
                            if (isObject(newValue)) if (isArrayLike(newValue)) {
                                oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
                                changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                                oldValue.length = oldLength = newLength);
                                for (var i = 0; i < newLength; i++) oldItem = oldValue[i], newItem = newValue[i], 
                                oldItem !== oldItem && newItem !== newItem || oldItem === newItem || (changeDetected++, 
                                oldValue[i] = newItem);
                            } else {
                                oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
                                newLength = 0;
                                for (key in newValue) hasOwnProperty.call(newValue, key) && (newLength++, newItem = newValue[key], 
                                oldItem = oldValue[key], key in oldValue ? oldItem !== oldItem && newItem !== newItem || oldItem === newItem || (changeDetected++, 
                                oldValue[key] = newItem) : (oldLength++, oldValue[key] = newItem, changeDetected++));
                                if (oldLength > newLength) {
                                    changeDetected++;
                                    for (key in oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, delete oldValue[key]);
                                }
                            } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                            return changeDetected;
                        }
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                        } else veryOldValue = newValue;
                    }
                    $watchCollectionInterceptor.$stateful = !0;
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, fn, get, watchers, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = this, watchLog = [];
                    beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), 
                    flushApplyAsync()), lastDirtyWatch = null;
                    do {
                        dirty = !1, current = target;
                        for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                            try {
                                asyncTask = asyncQueue[asyncQueuePosition], (fn = asyncTask.fn)(asyncTask.scope, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        asyncQueue.length = 0;
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) for (watchers.$$digestWatchIndex = watchers.length; watchers.$$digestWatchIndex--; ) try {
                                if (watch = watchers[watchers.$$digestWatchIndex]) if (get = watch.get, (value = get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                fn = watch.fn, fn(value, last === initWatchVal ? value : last, current), ttl < 5 && (logIdx = 4 - ttl, 
                                watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                    msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                    newVal: value,
                                    oldVal: last
                                }));
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueuePosition < postDigestQueue.length; ) try {
                        postDigestQueue[postDigestQueuePosition++]();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                    postDigestQueue.length = postDigestQueuePosition = 0, $browser.$$checkUrlChange();
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), 
                        incrementWatchersCount(this, -this.$$watchersCount);
                        for (var eventName in this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                        parent && parent.$$childHead === this && (parent.$$childHead = this.$$nextSibling), 
                        parent && parent.$$childTail === this && (parent.$$childTail = this.$$prevSibling), 
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, 
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return noop;
                        }, this.$$listeners = {}, this.$$nextSibling = null, cleanUpScope(this);
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                        asyncQueue.length && $rootScope.$digest();
                    }), asyncQueue.push({
                        scope: this,
                        fn: $parse(expr),
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        try {
                            return this.$eval(expr);
                        } finally {
                            clearPhase();
                        }
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression), expr = $parse(expr), scheduleApplyAsync();
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    var current = this;
                    do {
                        current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        -1 !== indexOfListener && (namedListeners[indexOfListener] = null, decrementListenerCount(self, 1, name));
                    };
                },
                $emit: function(name, args) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; i < length; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                        if (stopPropagation) return event.currentScope = null, event;
                        scope = scope.$parent;
                    } while (scope);
                    return event.currentScope = null, event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!target.$$listenerCount[name]) return event;
                    for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
                        i = 0, length = listeners.length; i < length; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event.currentScope = null, event;
                }
            };
            var $rootScope = new Scope(), asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [], postDigestQueuePosition = 0;
            return $rootScope;
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist;
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist;
        }, this.$get = function() {
            return function(uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    function snakeToCamel(name) {
        return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"), 
            new RegExp("^" + matcher + "$");
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
        }, this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
        }, this.$get = [ "$injector", function($injector) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href);
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = !0;
                    break;
                }
                if (allowed) for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                    allowed = !1;
                    break;
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue) return trustedValue;
                if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted) return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
                if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            var htmlSanitizer = function(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value), enabled;
        }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                    return sce.getTrusted(type, value);
                });
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            return bodyStyle && (transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle), 
            animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle)), {
                history: !(!hasHistoryPushState || android < 4 || boxee),
                hasEvent: function(event) {
                    if ("input" === event && msie) return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
            return val ? (httpOptions = val, this) : httpOptions;
        }, this.$get = [ "$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                function handleError(resp) {
                    return ignoreRequestError || (resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText), 
                    $exceptionHandler(resp)), $q.reject(resp);
                }
                handleRequestFn.totalPendingRequests++, isString(tpl) && !isUndefined($templateCache.get(tpl)) || (tpl = $sce.getTrustedResourceUrl(tpl));
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                return isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                    return transformer !== defaultHttpResponseTransform;
                }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null), 
                $http.get(tpl, extend({
                    cache: $templateCache,
                    transformResponse: transformResponse
                }, httpOptions)).finally(function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return $templateCache.put(tpl, response.data), response.data;
                }, handleError);
            }
            return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            return testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                return forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    dataBinding && forEach(dataBinding, function(bindingName) {
                        if (opt_exactMatch) {
                            new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)").test(bindingName) && matches.push(binding);
                        } else -1 !== bindingName.indexOf(expression) && matches.push(binding);
                    });
                }), matches;
            }, testability.findModels = function(element, expression, opt_exactMatch) {
                for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                    if (elements.length) return elements;
                }
            }, testability.getLocation = function() {
                return $location.url();
            }, testability.setLocation = function(url) {
                url !== $location.url() && ($location.url(url), $rootScope.$digest());
            }, testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            }, testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                var timeoutId, args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                return !!(promise && promise.$$timeoutId in deferreds) && (deferreds[promise.$$timeoutId].promise.catch(noop), 
                deferreds[promise.$$timeoutId].reject("canceled"), delete deferreds[promise.$$timeoutId], 
                $browser.defer.cancel(promise.$$timeoutId));
            }, timeout;
        } ];
    }
    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", href), {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
        function safeGetCookie(rawDocument) {
            try {
                return rawDocument.cookie || "";
            } catch (e) {
                return "";
            }
        }
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
        return function() {
            var cookieArray, cookie, i, index, name, currentCookieString = safeGetCookie(rawDocument);
            if (currentCookieString !== lastCookieString) for (lastCookieString = currentCookieString, 
            cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
            (index = cookie.indexOf("=")) > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), 
            isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
            return lastCookies;
        };
    }
    function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        var suffix = "Filter";
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator, anyPropertyKey) {
            if (!isArrayLike(array)) {
                if (null == array) return array;
                throw minErr("filter")("notarray", "Expected array but received: {0}", array);
            }
            anyPropertyKey = anyPropertyKey || "$";
            var predicateFn, matchAgainstAnyProp;
            switch (getTypeForFilter(expression)) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = !0;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
        return !0 === comparator ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
            return !(isUndefined(actual) || (null === actual || null === expected ? actual !== expected : isObject(expected) || isObject(actual) && !hasCustomToString(actual) || (actual = lowercase("" + actual), 
            expected = lowercase("" + expected), -1 === actual.indexOf(expected))));
        }), function(item) {
            return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
        };
    }
    function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
        if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
        if (isArray(actual)) return actual.some(function(item) {
            return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
        });
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) if (key.charAt && "$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0)) return !0;
                return !dontMatchWholeObject && deepCompare(actual, expected, comparator, anyPropertyKey, !1);
            }
            if ("object" === expectedType) {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                        var matchAnyProperty = key === anyPropertyKey;
                        if (!deepCompare(matchAnyProperty ? actual : actual[key], expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) return !1;
                    }
                }
                return !0;
            }
            return comparator(actual, expected);

          case "function":
            return !1;

          default:
            return comparator(actual, expected);
        }
    }
    function getTypeForFilter(val) {
        return null === val ? "null" : typeof val;
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac), 
            null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function parse(numStr) {
        var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
        for ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1 && (numStr = numStr.replace(DECIMAL_SEP, "")), 
        (i = numStr.search(/e/i)) > 0 ? (numberOfIntegerDigits < 0 && (numberOfIntegerDigits = i), 
        numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : numberOfIntegerDigits < 0 && (numberOfIntegerDigits = numStr.length), 
        i = 0; numStr.charAt(i) === ZERO_CHAR; i++) ;
        if (i === (zeros = numStr.length)) digits = [ 0 ], numberOfIntegerDigits = 1; else {
            for (zeros--; numStr.charAt(zeros) === ZERO_CHAR; ) zeros--;
            for (numberOfIntegerDigits -= i, digits = [], j = 0; i <= zeros; i++, j++) digits[j] = +numStr.charAt(i);
        }
        return numberOfIntegerDigits > MAX_DIGITS && (digits = digits.splice(0, MAX_DIGITS - 1), 
        exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
            d: digits,
            e: exponent,
            i: numberOfIntegerDigits
        };
    }
    function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d, fractionLen = digits.length - parsedNumber.i;
        fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i, digit = digits[roundAt];
        if (roundAt > 0) {
            digits.splice(Math.max(parsedNumber.i, roundAt));
            for (var j = roundAt; j < digits.length; j++) digits[j] = 0;
        } else {
            fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), 
            digits[0] = 0;
            for (var i = 1; i < roundAt; i++) digits[i] = 0;
        }
        if (digit >= 5) if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) digits.unshift(0), parsedNumber.i++;
            digits.unshift(1), parsedNumber.i++;
        } else digits[roundAt - 1]++;
        for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
            return d += carry, digits[i] = d % 10, Math.floor(d / 10);
        }, 0);
        carry && (digits.unshift(carry), parsedNumber.i++);
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isString(number) && !isNumber(number) || isNaN(number)) return "";
        var parsedNumber, isInfinity = !isFinite(number), isZero = !1, numStr = Math.abs(number) + "", formattedText = "";
        if (isInfinity) formattedText = ""; else {
            parsedNumber = parse(numStr), roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
            var digits = parsedNumber.d, integerLen = parsedNumber.i, exponent = parsedNumber.e, decimals = [];
            for (isZero = digits.reduce(function(isZero, d) {
                return isZero && !d;
            }, !0); integerLen < 0; ) digits.unshift(0), integerLen++;
            integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, 
            digits = [ 0 ]);
            var groups = [];
            for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize; ) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
            digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep), 
            decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent);
        }
        return number < 0 && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf;
    }
    function padNumber(num, digits, trim, negWrap) {
        var neg = "";
        for ((num < 0 || negWrap && num <= 0) && (negWrap ? num = 1 - num : (num = -num, 
        neg = "-")), num = "" + num; num.length < digits; ) num = ZERO_CHAR + num;
        return trim && (num = num.substr(num.length - digits)), neg + num;
    }
    function dateGetter(name, size, offset, trim, negWrap) {
        return offset = offset || 0, function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 === offset && (value = 12), 
            padNumber(value, size, trim, negWrap);
        };
    }
    function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
            var value = date["get" + name]();
            return formats[uppercase((standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "") + name)][value];
        };
    }
    function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset, paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs;
            return padNumber(1 + Math.round(diff / 6048e5), size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), 
                dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                var h = toInt(match[4] || 0) - tzHour, m = toInt(match[5] || 0) - tzMin, s = toInt(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
            }
            return string;
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date)), 
            isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
            for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
            format = parts.pop()) : (parts.push(format), format = null);
            var dateTimezoneOffset = date.getTimezoneOffset();
            return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), 
            date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            return isUndefined(spacing) && (spacing = 2), toJson(object, spacing);
        };
    }
    function limitToFilter() {
        return function(input, limit, begin) {
            return limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : toInt(limit), 
            isNumberNaN(limit) ? input : (isNumber(input) && (input = input.toString()), isArrayLike(input) ? (begin = !begin || isNaN(begin) ? 0 : toInt(begin), 
            begin = begin < 0 ? Math.max(0, input.length + begin) : begin, limit >= 0 ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input);
        };
    }
    function sliceFn(input, begin, end) {
        return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end);
    }
    function orderByFilter($parse) {
        function processPredicates(sortPredicates) {
            return sortPredicates.map(function(predicate) {
                var descending = 1, get = identity;
                if (isFunction(predicate)) get = predicate; else if (isString(predicate) && ("+" !== predicate.charAt(0) && "-" !== predicate.charAt(0) || (descending = "-" === predicate.charAt(0) ? -1 : 1, 
                predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate), 
                get.constant))) {
                    var key = get();
                    get = function(value) {
                        return value[key];
                    };
                }
                return {
                    get: get,
                    descending: descending
                };
            });
        }
        function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return !0;

              default:
                return !1;
            }
        }
        function objectValue(value) {
            return isFunction(value.valueOf) && (value = value.valueOf(), isPrimitive(value)) ? value : (hasCustomToString(value) && (value = value.toString(), 
            isPrimitive(value)), value);
        }
        function getPredicateValue(value, index) {
            var type = typeof value;
            return null === value ? (type = "string", value = "null") : "object" === type && (value = objectValue(value)), 
            {
                value: value,
                type: type,
                index: index
            };
        }
        function defaultCompare(v1, v2) {
            var result = 0, type1 = v1.type, type2 = v2.type;
            if (type1 === type2) {
                var value1 = v1.value, value2 = v2.value;
                "string" === type1 ? (value1 = value1.toLowerCase(), value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index), 
                isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value1 < value2 ? -1 : 1);
            } else result = type1 < type2 ? -1 : 1;
            return result;
        }
        return function(array, sortPredicate, reverseOrder, compareFn) {
            function getComparisonObject(value, index) {
                return {
                    value: value,
                    tieBreaker: {
                        value: index,
                        type: "number",
                        index: index
                    },
                    predicateValues: predicates.map(function(predicate) {
                        return getPredicateValue(predicate.get(value), index);
                    })
                };
            }
            function doComparison(v1, v2) {
                for (var i = 0, ii = predicates.length; i < ii; i++) {
                    var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                    if (result) return result * predicates[i].descending * descending;
                }
                return compare(v1.tieBreaker, v2.tieBreaker) * descending;
            }
            if (null == array) return array;
            if (!isArrayLike(array)) throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
            isArray(sortPredicate) || (sortPredicate = [ sortPredicate ]), 0 === sortPredicate.length && (sortPredicate = [ "+" ]);
            var predicates = processPredicates(sortPredicate), descending = reverseOrder ? -1 : 1, compare = isFunction(compareFn) ? compareFn : defaultCompare, compareValues = Array.prototype.map.call(array, getComparisonObject);
            return compareValues.sort(doComparison), array = compareValues.map(function(item) {
                return item.value;
            });
        };
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }), directive.restrict = directive.restrict || "AC", valueFn(directive);
    }
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    function FormController($element, $attrs, $scope, $animate, $interpolate) {
        this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0, 
        this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope), this.$dirty = !1, 
        this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1, 
        this.$$parentForm = nullFormCtrl, this.$$element = $element, this.$$animate = $animate, 
        setupValidity(this);
    }
    function setupValidity(instance) {
        instance.$$classCache = {}, instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
    }
    function addSetValidityMethod(context) {
        function createAndSet(ctrl, name, value, controller) {
            ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(ctrl, name, value, controller) {
            ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0);
        }
        function cachedToggleClass(ctrl, className, switchValue) {
            switchValue && !ctrl.$$classCache[className] ? (ctrl.$$animate.addClass(ctrl.$$element, className), 
            ctrl.$$classCache[className] = !0) : !switchValue && ctrl.$$classCache[className] && (ctrl.$$animate.removeClass(ctrl.$$element, className), 
            ctrl.$$classCache[className] = !1);
        }
        function toggleValidationCss(ctrl, validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, !0 === isValid), cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, !1 === isValid);
        }
        var clazz = context.clazz, set = context.set, unset = context.unset;
        clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
            isUndefined(state) ? createAndSet(this, "$pending", validationErrorKey, controller) : unsetAndCleanup(this, "$pending", validationErrorKey, controller), 
            isBoolean(state) ? state ? (unset(this.$error, validationErrorKey, controller), 
            set(this.$$success, validationErrorKey, controller)) : (set(this.$error, validationErrorKey, controller), 
            unset(this.$$success, validationErrorKey, controller)) : (unset(this.$error, validationErrorKey, controller), 
            unset(this.$$success, validationErrorKey, controller)), this.$pending ? (cachedToggleClass(this, PENDING_CLASS, !0), 
            this.$valid = this.$invalid = void 0, toggleValidationCss(this, "", null)) : (cachedToggleClass(this, PENDING_CLASS, !1), 
            this.$valid = isObjectEmpty(this.$error), this.$invalid = !this.$valid, toggleValidationCss(this, "", this.$valid));
            var combinedState;
            combinedState = this.$pending && this.$pending[validationErrorKey] ? void 0 : !this.$error[validationErrorKey] && (!!this.$$success[validationErrorKey] || null), 
            toggleValidationCss(this, validationErrorKey, combinedState), this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
        };
    }
    function isObjectEmpty(obj) {
        if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
        return !0;
    }
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function() {
                composing = !0;
            }), element.on("compositionend", function() {
                composing = !1, listener();
            });
        }
        var timeout, listener = function(ev) {
            if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                var value = element.val(), event = ev && ev.type;
                "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), 
                (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener); else {
            var deferListener = function(ev, input, origValue) {
                timeout || (timeout = $browser.defer(function() {
                    timeout = null, input && input.value === origValue || listener(ev);
                }));
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || 15 < key && key < 19 || 37 <= key && key <= 40 || deferListener(event, this, this.value);
            }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener);
        }
        element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
                var validity = this[VALIDITY_STATE_PROPERTY], origBadInput = validity.badInput, origTypeMismatch = validity.typeMismatch;
                timeout = $browser.defer(function() {
                    timeout = null, validity.badInput === origBadInput && validity.typeMismatch === origTypeMismatch || listener(ev);
                });
            }
        }), ctrl.$render = function() {
            var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
            element.val() !== value && element.val(value);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) return isoWeek;
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), 
                seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), 
                new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) return iso;
            if (isString(iso)) {
                if ('"' === iso.charAt(0) && '"' === iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), 
                ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                if (regexp.lastIndex = 0, parts = regexp.exec(iso)) return parts.shift(), map = date ? {
                    yyyy: date.getFullYear(),
                    MM: date.getMonth() + 1,
                    dd: date.getDate(),
                    HH: date.getHours(),
                    mm: date.getMinutes(),
                    ss: date.getSeconds(),
                    sss: date.getMilliseconds() / 1e3
                } : {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                }, forEach(parts, function(part, index) {
                    index < mapping.length && (map[mapping[index]] = +part);
                }), new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) && !isDate(val) ? parseDate(val) || void 0 : val;
            }
            badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var previousDate, timezone = ctrl && ctrl.$options.getOption("timezone");
            if (ctrl.$$parserName = type, ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    return timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), 
                    parsedDate;
                }
            }), ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                return isValidDate(value) ? (previousDate = value, previousDate && timezone && (previousDate = convertTimezoneToLocal(previousDate, timezone, !0)), 
                $filter("date")(value, format, timezone)) : (previousDate = null, "");
            }), isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                }, attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                }, attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        (ctrl.$$hasNativeValidators = isObject(node.validity)) && ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? void 0 : value;
        });
    }
    function numberFormatterParser(ctrl) {
        ctrl.$$parserName = "number", ctrl.$parsers.push(function(value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void 0;
        }), ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString();
            }
            return value;
        });
    }
    function parseNumberAttrVal(val) {
        return isDefined(val) && !isNumber(val) && (val = parseFloat(val)), isNumberNaN(val) ? void 0 : val;
    }
    function isNumberInteger(num) {
        return (0 | num) === num;
    }
    function countDecimals(num) {
        var numString = num.toString(), decimalSymbolIndex = numString.indexOf(".");
        if (-1 === decimalSymbolIndex) {
            if (-1 < num && num < 1) {
                var match = /e-(\d+)$/.exec(numString);
                if (match) return Number(match[1]);
            }
            return 0;
        }
        return numString.length - decimalSymbolIndex - 1;
    }
    function isValidForStep(viewValue, stepBase, step) {
        var value = Number(viewValue), isNonIntegerValue = !isNumberInteger(value), isNonIntegerStepBase = !isNumberInteger(stepBase), isNonIntegerStep = !isNumberInteger(step);
        if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
            var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0, stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0, stepDecimals = isNonIntegerStep ? countDecimals(step) : 0, decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals), multiplier = Math.pow(10, decimalCount);
            value *= multiplier, stepBase *= multiplier, step *= multiplier, isNonIntegerValue && (value = Math.round(value)), 
            isNonIntegerStepBase && (stepBase = Math.round(stepBase)), isNonIntegerStep && (step = Math.round(step));
        }
        return (value - stepBase) % step == 0;
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl), numberFormatterParser(ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var minVal, maxVal;
        if ((isDefined(attr.min) || attr.ngMin) && (ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
        }, attr.$observe("min", function(val) {
            minVal = parseNumberAttrVal(val), ctrl.$validate();
        })), (isDefined(attr.max) || attr.ngMax) && (ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
        }, attr.$observe("max", function(val) {
            maxVal = parseNumberAttrVal(val), ctrl.$validate();
        })), isDefined(attr.step) || attr.ngStep) {
            var stepVal;
            ctrl.$validators.step = function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
            }, attr.$observe("step", function(val) {
                stepVal = parseNumberAttrVal(val), ctrl.$validate();
            });
        }
    }
    function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        function setInitialValueAndObserver(htmlAttrName, changeFn) {
            element.attr(htmlAttrName, attr[htmlAttrName]), attr.$observe(htmlAttrName, changeFn);
        }
        function minChange(val) {
            if (minVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue)) if (supportsRange) {
                var elVal = element.val();
                minVal > elVal && (elVal = minVal, element.val(elVal)), ctrl.$setViewValue(elVal);
            } else ctrl.$validate();
        }
        function maxChange(val) {
            if (maxVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue)) if (supportsRange) {
                var elVal = element.val();
                maxVal < elVal && (element.val(maxVal), elVal = maxVal < minVal ? minVal : maxVal), 
                ctrl.$setViewValue(elVal);
            } else ctrl.$validate();
        }
        function stepChange(val) {
            stepVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue) || (supportsRange && ctrl.$viewValue !== element.val() ? ctrl.$setViewValue(element.val()) : ctrl.$validate());
        }
        badInputChecker(scope, element, attr, ctrl), numberFormatterParser(ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var supportsRange = ctrl.$$hasNativeValidators && "range" === element[0].type, minVal = supportsRange ? 0 : void 0, maxVal = supportsRange ? 100 : void 0, stepVal = supportsRange ? 1 : void 0, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step), originalRender = ctrl.$render;
        ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function() {
            originalRender(), ctrl.$setViewValue(element.val());
        } : originalRender, hasMinAttr && (ctrl.$validators.min = supportsRange ? function() {
            return !0;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
        }, setInitialValueAndObserver("min", minChange)), hasMaxAttr && (ctrl.$validators.max = supportsRange ? function() {
            return !0;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
        }, setInitialValueAndObserver("max", maxChange)), hasStepAttr && (ctrl.$validators.step = supportsRange ? function() {
            return !validity.stepMismatch;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
        }, setInitialValueAndObserver("step", stepChange));
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "url", ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "email", ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        var doTrim = !attr.ngTrim || "false" !== trim(attr.ngTrim);
        isUndefined(attr.name) && element.attr("name", nextUid());
        var listener = function(ev) {
            var value;
            element[0].checked && (value = attr.value, doTrim && (value = trim(value)), ctrl.$setViewValue(value, ev && ev.type));
        };
        element.on("click", listener), ctrl.$render = function() {
            var value = attr.value;
            doTrim && (value = trim(value)), element[0].checked = value === ctrl.$viewValue;
        }, attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            if (parseFn = $parse(expression), !parseFn.constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener), ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        }, ctrl.$isEmpty = function(value) {
            return !1 === value;
        }, ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        }), ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    function classDirective(name, selector) {
        function arrayDifference(tokens1, tokens2) {
            if (!tokens1 || !tokens1.length) return [];
            if (!tokens2 || !tokens2.length) return tokens1;
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
                for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
                values.push(token);
            }
            return values;
        }
        function split(classString) {
            return classString && classString.split(" ");
        }
        function toClassString(classValue) {
            var classString = classValue;
            return isArray(classValue) ? classString = classValue.map(toClassString).join(" ") : isObject(classValue) && (classString = Object.keys(classValue).filter(function(key) {
                return classValue[key];
            }).join(" ")), classString;
        }
        name = "ngClass" + name;
        var indexWatchExpression;
        return [ "$parse", function($parse) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classString) {
                        classString = digestClassCounts(split(classString), 1), attr.$addClass(classString);
                    }
                    function removeClasses(classString) {
                        classString = digestClassCounts(split(classString), -1), attr.$removeClass(classString);
                    }
                    function updateClasses(oldClassString, newClassString) {
                        var oldClassArray = split(oldClassString), newClassArray = split(newClassString), toRemoveArray = arrayDifference(oldClassArray, newClassArray), toAddArray = arrayDifference(newClassArray, oldClassArray), toRemoveString = digestClassCounts(toRemoveArray, -1), toAddString = digestClassCounts(toAddArray, 1);
                        attr.$addClass(toAddString), attr.$removeClass(toRemoveString);
                    }
                    function digestClassCounts(classArray, count) {
                        var classesToUpdate = [];
                        return forEach(classArray, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                        }), classesToUpdate.join(" ");
                    }
                    function ngClassIndexWatchAction(newModulo) {
                        newModulo === selector ? addClasses(oldClassString) : removeClasses(oldClassString), 
                        oldModulo = newModulo;
                    }
                    function ngClassWatchAction(newClassString) {
                        isString(newClassString) || (newClassString = toClassString(newClassString)), oldModulo === selector && updateClasses(oldClassString, newClassString), 
                        oldClassString = newClassString;
                    }
                    var oldClassString, classCounts = element.data("$classCounts"), oldModulo = !0;
                    classCounts || (classCounts = createMap(), element.data("$classCounts", classCounts)), 
                    "ngClass" !== name && (indexWatchExpression || (indexWatchExpression = $parse("$index", function($index) {
                        return 1 & $index;
                    })), scope.$watch(indexWatchExpression, ngClassIndexWatchAction)), scope.$watch($parse(attr[name], toClassString), ngClassWatchAction);
                }
            };
        } ];
    }
    function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, 
        this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], 
        this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, 
        this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, 
        this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope), 
        this.$$parentForm = nullFormCtrl, this.$options = defaultModelOptions, this.$$parsedNgModel = $parse($attr.ngModel), 
        this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel, 
        this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0, 
        this.$$currentValidationRunId = 0, Object.defineProperty(this, "$$scope", {
            value: $scope
        }), this.$$attr = $attr, this.$$element = $element, this.$$animate = $animate, this.$$timeout = $timeout, 
        this.$$parse = $parse, this.$$q = $q, this.$$exceptionHandler = $exceptionHandler, 
        setupValidity(this), setupModelWatcher(this);
    }
    function setupModelWatcher(ctrl) {
        ctrl.$$scope.$watch(function(scope) {
            var modelValue = ctrl.$$ngModelGet(scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue, ctrl.$$parserValid = void 0;
                for (var formatters = ctrl.$formatters, idx = formatters.length, viewValue = modelValue; idx--; ) viewValue = formatters[idx](viewValue);
                ctrl.$viewValue !== viewValue && (ctrl.$$updateEmptyClasses(viewValue), ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue, 
                ctrl.$render(), ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop));
            }
            return modelValue;
        });
    }
    function ModelOptions(options) {
        this.$$options = options;
    }
    function defaults(dst, src) {
        forEach(src, function(value, key) {
            isDefined(dst[key]) || (dst[key] = value);
        });
    }
    function setOptionSelectedStatus(optionEl, value) {
        optionEl.prop("selected", value), optionEl.attr("selected", value);
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", hasOwnProperty = Object.prototype.hasOwnProperty, minErrConfig = {
        objectMaxDepth: 5
    }, lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0));
        }) : s;
    }, manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0));
        }) : s;
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    msie = window.document.documentMode;
    var isNumberNaN = Number.isNaN || function(num) {
        return num !== num;
    };
    noop.$inject = [], identity.$inject = [];
    var isArray = Array.isArray, TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/, trim = function(value) {
        return isString(value) ? value.trim() : value;
    }, escapeForRegexp = function(s) {
        return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, csp = function() {
        if (!isDefined(csp.rules)) {
            var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
            if (ngCspElement) {
                var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                csp.rules = {
                    noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
                    noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
                };
            } else csp.rules = {
                noUnsafeEval: function() {
                    try {
                        return new Function(""), !1;
                    } catch (e) {
                        return !0;
                    }
                }(),
                noInlineStyle: !1
            };
        }
        return csp.rules;
    }, jq = function() {
        if (isDefined(jq.name_)) return jq.name_;
        var el, i, prefix, name, ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) if (prefix = ngAttrPrefixes[i], el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
            name = el.getAttribute(prefix + "jq");
            break;
        }
        return jq.name_ = name;
    }, ALL_COLONS = /:/g, ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ], isAutoBootstrapAllowed = function(document) {
        var script = document.currentScript;
        if (!script) return !0;
        if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) return !1;
        var attributes = script.attributes;
        return [ attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href") ].every(function(src) {
            if (!src) return !0;
            if (!src.value) return !1;
            var link = document.createElement("a");
            if (link.href = src.value, document.location.origin === link.origin) return !0;
            switch (link.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "blob:":
              case "file:":
              case "data:":
                return !0;

              default:
                return !1;
            }
        });
    }(window.document), SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
        full: "1.6.4",
        major: 1,
        minor: 6,
        dot: 4,
        codeName: "phenomenal-footnote"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1;
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    var DASH_LOWERCASE_REGEXP = /-([a-z])/g, MS_HACK_REGEXP = /^-ms-/, MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:-]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(16 & this.compareDocumentPosition(arg));
    }, JQLitePrototype = JQLite.prototype = {
        ready: jqLiteReady,
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = !0;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern",
        ngStep: "step"
    };
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: function(nodes) {
            for (var i = 0, ii = nodes.length; i < ii; i++) jqLiteRemoveData(nodes[i]);
        }
    }, function(fn, name) {
        JQLite[name] = fn;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            return name = cssKebabToCamel(name), isDefined(value) ? void (element.style[name] = value) : element.style[name];
        },
        attr: function(element, name, value) {
            var ret, nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_TEXT && 2 !== nodeType && nodeType !== NODE_TYPE_COMMENT && element.getAttribute) {
                var lowercasedName = lowercase(name), isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                return isDefined(value) ? void (null === value || !1 === value && isBooleanAttr ? element.removeAttribute(name) : element.setAttribute(name, isBooleanAttr ? lowercasedName : value)) : (ret = element.getAttribute(name), 
                isBooleanAttr && null !== ret && (ret = lowercasedName), null === ret ? void 0 : ret);
            }
        },
        prop: function(element, name, value) {
            return isDefined(value) ? void (element[name] = value) : element[name];
        },
        text: function() {
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
            return getText.$dv = "", getText;
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void (element.innerHTML = value));
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && isUndefined(2 === fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; j < jj; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
            for (i = 0; i < nodeCount; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        on: function(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) {
                var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                handle || (handle = expandoStore.handle = createEventHandler(element, events));
                for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ], i = types.length, addHandler = function(type, specialHandlerWrapper, noEventListener) {
                    var eventFns = events[type];
                    eventFns || (eventFns = events[type] = [], eventFns.specialHandlerWrapper = specialHandlerWrapper, 
                    "$destroy" === type || noEventListener || element.addEventListener(type, handle)), 
                    eventFns.push(fn);
                }; i--; ) type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper), 
                addHandler(type, void 0, !0)) : addHandler(type);
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                node = new JQLite(node);
                for (var i = 0, ii = node.length; i < ii; i++) {
                    var child = node[i];
                    element.appendChild(child);
                }
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, !0);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            if (parent) {
                newElement = new JQLite(newElement);
                for (var i = 0, ii = newElement.length; i < ii; i++) {
                    var node = newElement[i];
                    parent.insertBefore(node, index.nextSibling), index = node;
                }
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
            eventFns && (dummyEvent = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return !0 === this.defaultPrevented;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return !0 === this.immediatePropagationStopped;
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), 
            handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ], 
            forEach(eventFnsCopy, function(fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
            }));
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; i < ii; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
            isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this;
        };
    }), JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
    var nanKey = Object.create(null);
    NgMapShim.prototype = {
        _idx: function(key) {
            return key === this._lastKey ? this._lastIndex : (this._lastKey = key, this._lastIndex = this._keys.indexOf(key), 
            this._lastIndex);
        },
        _transformKey: function(key) {
            return isNumberNaN(key) ? nanKey : key;
        },
        get: function(key) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            if (-1 !== idx) return this._values[idx];
        },
        set: function(key, value) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            -1 === idx && (idx = this._lastIndex = this._keys.length), this._keys[idx] = key, 
            this._values[idx] = value;
        },
        delete: function(key) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            return -1 !== idx && (this._keys.splice(idx, 1), this._values.splice(idx, 1), this._lastKey = NaN, 
            this._lastIndex = -1, !0);
        }
    };
    var NgMap = NgMapShim, $$MapProvider = [ function() {
        this.$get = [ function() {
            return NgMap;
        } ];
    } ], ARROW_ARG = /^([^(]+?)=>/, FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
    createInjector.$$annotate = annotate;
    var $animateMinErr = minErr("$animate"), ELEMENT_NODE = 1, $$CoreAnimateJsProvider = function() {
        this.$get = noop;
    }, $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new NgMap(), postDigestElements = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
            function updateData(data, classes, value) {
                var changed = !1;
                return classes && (classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], 
                forEach(classes, function(className) {
                    className && (changed = !0, data[className] = value);
                })), changed;
            }
            function handleCSSClassChanges() {
                forEach(postDigestElements, function(element) {
                    var data = postDigestQueue.get(element);
                    if (data) {
                        var existing = splitClasses(element.attr("class")), toAdd = "", toRemove = "";
                        forEach(data, function(status, className) {
                            status !== !!existing[className] && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className);
                        }), forEach(element, function(elm) {
                            toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove);
                        }), postDigestQueue.delete(element);
                    }
                }), postDigestElements.length = 0;
            }
            function addRemoveClassesPostDigest(element, add, remove) {
                var data = postDigestQueue.get(element) || {}, classesAdded = updateData(data, add, !0), classesRemoved = updateData(data, remove, !1);
                (classesAdded || classesRemoved) && (postDigestQueue.set(element, data), postDigestElements.push(element), 
                1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges));
            }
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function(element, event, options, domOperation) {
                    domOperation && domOperation(), options = options || {}, options.from && element.css(options.from), 
                    options.to && element.css(options.to), (options.addClass || options.removeClass) && addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                    var runner = new $$AnimateRunner();
                    return runner.complete(), runner;
                }
            };
        } ];
    }, $AnimateProvider = [ "$provide", function($provide) {
        var provider = this, classNameFilter = null;
        this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
            if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            var key = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.classNameFilter = function(expression) {
            if (1 === arguments.length && (classNameFilter = expression instanceof RegExp ? expression : null)) {
                if (new RegExp("[(\\s|\\/)]ng-animate[(\\s|\\/)]").test(classNameFilter.toString())) throw classNameFilter = null, 
                $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', "ng-animate");
            }
            return classNameFilter;
        }, this.$get = [ "$$animateQueue", function($$animateQueue) {
            function domInsert(element, parentElement, afterElement) {
                if (afterElement) {
                    var afterNode = extractElementNode(afterElement);
                    !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null);
                }
                afterElement ? afterElement.after(element) : parentElement.prepend(element);
            }
            return {
                on: $$animateQueue.on,
                off: $$animateQueue.off,
                pin: $$animateQueue.pin,
                enabled: $$animateQueue.enabled,
                cancel: function(runner) {
                    runner.end && runner.end();
                },
                enter: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                },
                move: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                },
                leave: function(element, options) {
                    return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                        element.remove();
                    });
                },
                addClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addclass, className), 
                    $$animateQueue.push(element, "addClass", options);
                },
                removeClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.removeClass = mergeClasses(options.removeClass, className), 
                    $$animateQueue.push(element, "removeClass", options);
                },
                setClass: function(element, add, remove, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addClass, add), 
                    options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options);
                },
                animate: function(element, from, to, className, options) {
                    return options = prepareAnimateOptions(options), options.from = options.from ? extend(options.from, from) : from, 
                    options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", 
                    options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options);
                }
            };
        } ];
    } ], $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = [ "$$rAF", function($$rAF) {
            function waitForTick(fn) {
                waitQueue.push(fn), waitQueue.length > 1 || $$rAF(function() {
                    for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                    waitQueue = [];
                });
            }
            var waitQueue = [];
            return function() {
                var passed = !1;
                return waitForTick(function() {
                    passed = !0;
                }), function(callback) {
                    passed ? callback() : waitForTick(callback);
                };
            };
        } ];
    }, $$AnimateRunnerFactoryProvider = function() {
        this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
            function AnimateRunner(host) {
                this.setHost(host);
                var rafTick = $$animateAsyncRun(), timeoutTick = function(fn) {
                    $timeout(fn, 0, !1);
                };
                this._doneCallbacks = [], this._tick = function(fn) {
                    $$isDocumentHidden() ? timeoutTick(fn) : rafTick(fn);
                }, this._state = 0;
            }
            return AnimateRunner.chain = function(chain, callback) {
                function next() {
                    return index === chain.length ? void callback(!0) : void chain[index](function(response) {
                        return !1 === response ? void callback(!1) : (index++, void next());
                    });
                }
                var index = 0;
                next();
            }, AnimateRunner.all = function(runners, callback) {
                function onProgress(response) {
                    status = status && response, ++count === runners.length && callback(status);
                }
                var count = 0, status = !0;
                forEach(runners, function(runner) {
                    runner.done(onProgress);
                });
            }, AnimateRunner.prototype = {
                setHost: function(host) {
                    this.host = host || {};
                },
                done: function(fn) {
                    2 === this._state ? fn() : this._doneCallbacks.push(fn);
                },
                progress: noop,
                getPromise: function() {
                    if (!this.promise) {
                        var self = this;
                        this.promise = $q(function(resolve, reject) {
                            self.done(function(status) {
                                !1 === status ? reject() : resolve();
                            });
                        });
                    }
                    return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                    return this.getPromise().then(resolveHandler, rejectHandler);
                },
                catch: function(handler) {
                    return this.getPromise().catch(handler);
                },
                finally: function(handler) {
                    return this.getPromise().finally(handler);
                },
                pause: function() {
                    this.host.pause && this.host.pause();
                },
                resume: function() {
                    this.host.resume && this.host.resume();
                },
                end: function() {
                    this.host.end && this.host.end(), this._resolve(!0);
                },
                cancel: function() {
                    this.host.cancel && this.host.cancel(), this._resolve(!1);
                },
                complete: function(response) {
                    var self = this;
                    0 === self._state && (self._state = 1, self._tick(function() {
                        self._resolve(response);
                    }));
                },
                _resolve: function(response) {
                    2 !== this._state && (forEach(this._doneCallbacks, function(fn) {
                        fn(response);
                    }), this._doneCallbacks.length = 0, this._state = 2);
                }
            }, AnimateRunner;
        } ];
    }, $CoreAnimateCssProvider = function() {
        this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
            return function(element, initialOptions) {
                function run() {
                    return $$rAF(function() {
                        applyAnimationContents(), closed || runner.complete(), closed = !0;
                    }), runner;
                }
                function applyAnimationContents() {
                    options.addClass && (element.addClass(options.addClass), options.addClass = null), 
                    options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null), 
                    options.to && (element.css(options.to), options.to = null);
                }
                var options = initialOptions || {};
                options.$$prepared || (options = copy(options)), options.cleanupStyles && (options.from = options.to = null), 
                options.from && (element.css(options.from), options.from = null);
                var closed, runner = new $$AnimateRunner();
                return {
                    start: run,
                    end: run
                };
            };
        } ];
    }, $compileMinErr = minErr("$compile"), _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ], SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
    };
    var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i, SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g, $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/, $$ForceReflowProvider = function() {
        this.$get = [ "$document", function($document) {
            return function(domNode) {
                return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, 
                domNode.offsetWidth + 1;
            };
        } ];
    }, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    }, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    }, JSON_PROTECTION_PREFIX = /^\)]\}',?\n/, $httpMinErr = minErr("$http"), $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
    $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
    }, $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    var $jsonpCallbacksProvider = function() {
        this.$get = function() {
            function createCallback(callbackId) {
                var callback = function(data) {
                    callback.data = data, callback.called = !0;
                };
                return callback.id = callbackId, callback;
            }
            var callbacks = angular.callbacks, callbackMap = {};
            return {
                createCallback: function(url) {
                    var callbackId = "_" + (callbacks.$$counter++).toString(36), callbackPath = "angular.callbacks." + callbackId, callback = createCallback(callbackId);
                    return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath;
                },
                wasCalled: function(callbackPath) {
                    return callbackMap[callbackPath].called;
                },
                getResponse: function(callbackPath) {
                    return callbackMap[callbackPath].data;
                },
                removeCallback: function(callbackPath) {
                    var callback = callbackMap[callbackPath];
                    delete callbacks[callback.id], delete callbackMap[callbackPath];
                }
            };
        };
    }, PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location"), DOUBLE_SLASH_REGEX = /^\s*[\\\/]{2,}/, locationPrototype = {
        $$absUrl: "",
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), 
            this.hash(match[5] || ""), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return path = null !== path ? path.toString() : "", "/" === path.charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    search = copy(search, {}), forEach(search, function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return null !== hash ? hash.toString() : "";
        }),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = isUndefined(state) ? null : state, this.$$urlUpdatedByLocation = !0, 
            this;
        };
    });
    var $parseMinErr = minErr("$parse"), objectValueOf = {}.constructor.prototype.valueOf, OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = !0;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "\t",
        v: "\v",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                    index: this.index,
                    text: ch
                }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                    var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: !0
                        }), this.index += token.length;
                    } else this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return -1 !== chars.indexOf(ch);
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length && this.text.charAt(this.index + num);
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && "string" == typeof ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "\t" === ch || "\n" === ch || "\v" === ch || "" === ch;
        },
        isIdentifierStart: function(ch) {
            return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || "$" === ch;
        },
        isIdentifierContinue: function(ch) {
            return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
            return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
            return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
        },
        peekMultichar: function() {
            var ch = this.text.charAt(this.index), peek = this.peek();
            if (!peek) return ch;
            var cp1 = ch.charCodeAt(0), cp2 = peek.charCodeAt(0);
            return cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343 ? ch + peek : ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." === ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" === ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" === number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" !== number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: !0,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            for (this.index += this.peekMultichar().length; this.index < this.text.length; ) {
                var ch = this.peekMultichar();
                if (!this.isIdentifierContinue(ch)) break;
                this.index += ch.length;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: !0
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                        this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        string += ESCAPE[ch] || ch;
                    }
                    escape = !1;
                } else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: !0,
                        value: string
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function(lexer, options) {
        this.lexer = lexer, this.options = options;
    };
    AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", 
    AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", 
    AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", 
    AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", 
    AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", 
    AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", 
    AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter", 
    AST.prototype = {
        ast: function(text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.program();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value;
        },
        program: function() {
            for (var body = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: AST.Program,
                body: body
            };
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var left = this.expression(); this.expect("|"); ) left = this.filter(left);
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            if (this.expect("=")) {
                if (!isAssignable(result)) throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                result = {
                    type: AST.AssignmentExpression,
                    left: result,
                    right: this.assignment(),
                    operator: "="
                };
            }
            return result;
        },
        ternary: function() {
            var alternate, consequent, test = this.logicalOR();
            return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), 
            {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
            }) : test;
        },
        logicalOR: function() {
            for (var left = this.logicalAND(); this.expect("||"); ) left = {
                type: AST.LogicalExpression,
                operator: "||",
                left: left,
                right: this.logicalAND()
            };
            return left;
        },
        logicalAND: function() {
            for (var left = this.equality(); this.expect("&&"); ) left = {
                type: AST.LogicalExpression,
                operator: "&&",
                left: left,
                right: this.equality()
            };
            return left;
        },
        equality: function() {
            for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.relational()
            };
            return left;
        },
        relational: function() {
            for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.additive()
            };
            return left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.multiplicative()
            };
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.unary()
            };
            return left;
        },
        unary: function() {
            var token;
            return (token = this.expect("+", "-", "!")) ? {
                type: AST.UnaryExpression,
                operator: token.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var primary;
            this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                type: AST.Literal,
                value: this.options.literals[this.consume().text]
            } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var next; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === next.text ? (primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === next.text ? primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return primary;
        },
        filter: function(baseExpression) {
            for (var args = [ baseExpression ], result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: !0
            }; this.expect(":"); ) args.push(this.expression());
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (")" !== this.peekToken().text) do {
                args.push(this.filterChain());
            } while (this.expect(","));
            return args;
        },
        identifier: function() {
            var token = this.consume();
            return token.identifier || this.throwError("is not a valid identifier", token), 
            {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                elements.push(this.expression());
            } while (this.expect(","));
            return this.consume("]"), {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var property, properties = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                property = {
                    type: AST.Property,
                    kind: "init"
                }, this.peek().constant ? (property.key = this.constant(), property.computed = !1, 
                this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(), 
                property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["), 
                property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"), 
                property.value = this.expression()) : this.throwError("invalid key", this.peek()), 
                properties.push(property);
            } while (this.expect(","));
            return this.consume("}"), {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), 
            token;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return !!token && (this.tokens.shift(), token);
        },
        selfReferential: {
            this: {
                type: AST.ThisExpression
            },
            $locals: {
                type: AST.LocalsExpression
            }
        }
    }, ASTCompiler.prototype = {
        compile: function(ast) {
            var self = this;
            this.state = {
                nextId: 0,
                filters: {},
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            }, findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, extra = "";
            if (this.stage = "assign", assignable = assignableAST(ast)) {
                this.state.computing = "assign";
                var result = this.nextId();
                this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self.stage = "inputs", forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                }, self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push(fnKey), 
                watch.watchId = key;
            }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;", fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
            return this.state = this.stage = void 0, fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [], fns = this.state.inputs, self = this;
            return forEach(fns, function(name) {
                result.push("var " + name + "=" + self.generateFunction(name, "s"));
            }), fns.length && result.push("fn.inputs=[" + fns.join(",") + "];"), result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [], self = this;
            return forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            }), parts.length ? "var " + parts.join(",") + ";" : "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, args, expression, computed, self = this;
            if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(), 
            void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, void 0, void 0, function(expr) {
                        right = expr;
                    }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right);
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(intoId || expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, void 0, void 0, function(expr) {
                    right = expr;
                }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), 
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, void 0, void 0, function(expr) {
                    left = expr;
                }), this.recurse(ast.right, void 0, void 0, function(expr) {
                    right = expr;
                }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", 
                this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), 
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), 
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), 
                nameId.computed = !1, nameId.name = ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if_("inputs" === self.stage || "s", function() {
                        create && 1 !== create && self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), 
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), 
                self.recurse(ast.object, left, void 0, function() {
                    self.if_(self.notNull(left), function() {
                        ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), 
                        create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), 
                        expression = self.computedMember(left, right), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !0, nameId.name = right)) : (create && 1 !== create && self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), 
                        expression = self.nonComputedMember(left, ast.property.name), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !1, nameId.name = ast.property.name));
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), 
                args = [], forEach(ast.arguments, function(expr) {
                    var argument = self.nextId();
                    self.recurse(expr, argument), args.push(argument);
                }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), 
                recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function() {
                    self.if_(self.notNull(right), function() {
                        forEach(ast.arguments, function(expr) {
                            self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                                args.push(argument);
                            });
                        }), expression = left.name ? self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")" : right + "(" + args.join(",") + ")", 
                        self.assign(intoId, expression);
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }));
                break;

              case AST.AssignmentExpression:
                right = this.nextId(), left = {}, this.recurse(ast.left, void 0, left, function() {
                    self.if_(self.notNull(left.context), function() {
                        self.recurse(ast.right, right), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, 
                        self.assign(intoId, expression), recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [], forEach(ast.elements, function(expr) {
                    self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                        args.push(argument);
                    });
                }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(intoId || expression);
                break;

              case AST.ObjectExpression:
                args = [], computed = !1, forEach(ast.properties, function(property) {
                    property.computed && (computed = !0);
                }), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, function(property) {
                    property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, 
                    right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right);
                })) : (forEach(ast.properties, function(property) {
                    self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, function(expr) {
                        args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                    });
                }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), recursionFn(intoId || expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s"), recursionFn(intoId || "s");
                break;

              case AST.LocalsExpression:
                this.assign(intoId, "l"), recursionFn(intoId || "l");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v"), recursionFn(intoId || "v");
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property, own = this.current().own;
            return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), 
            own[key];
        },
        assign: function(id, value) {
            if (id) return this.current().body.push(id, "=", value, ";"), id;
        },
        filter: function(filterName) {
            return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), 
            this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        return_: function(id) {
            this.current().body.push("return ", id, ";");
        },
        if_: function(test, alternate, consequent) {
            if (!0 === test) alternate(); else {
                var body = this.current().body;
                body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), 
                consequent(), body.push("}"));
            }
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        isNull: function(expression) {
            return expression + "==null";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/, UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
            return SAFE_IDENTIFIER.test(right) ? left + "." + right : left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right);
        },
        getStringValue: function(item) {
            this.assign(item, "getStringValue(" + item + ")");
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (!0 === value) return "true";
            if (!1 === value) return "false";
            if (null === value) return "null";
            if (void 0 === value) return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            return skip || this.current().vars.push(id + (init ? "=" + init : "")), id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    }, ASTInterpreter.prototype = {
        compile: function(ast) {
            var self = this;
            findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, assign;
            (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
            var inputs, toWatch = getInputs(ast.body);
            toWatch && (inputs = [], forEach(toWatch, function(watch, key) {
                var input = self.recurse(watch);
                watch.input = input, inputs.push(input), watch.watchId = key;
            }));
            var expressions = [];
            forEach(ast.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            var fn = 0 === ast.body.length ? noop : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                var lastValue;
                return forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                }), lastValue;
            };
            return assign && (fn.assign = function(scope, value, locals) {
                return assign(scope, locals, value);
            }), inputs && (fn.inputs = inputs), fn;
        },
        recurse: function(ast, context, create) {
            var left, right, args, self = this;
            if (ast.input) return this.inputs(ast.input, ast.watchId);
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
              case AST.LogicalExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                return self.identifier(ast.name, context, create);

              case AST.MemberExpression:
                return left = this.recurse(ast.object, !1, !!create), ast.computed || (right = ast.property.name), 
                ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);

              case AST.CallExpression:
                return args = [], forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), 
                ast.filter ? function(scope, locals, assign, inputs) {
                    for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                    var value = right.apply(void 0, values, inputs);
                    return context ? {
                        context: void 0,
                        name: void 0,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var value, rhs = right(scope, locals, assign, inputs);
                    if (null != rhs.value) {
                        for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                        value = rhs.value.apply(rhs.context, values);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs);
                    return lhs.context[lhs.name] = rhs, context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                return args = [], forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                }), function(scope, locals, assign, inputs) {
                    for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                return args = [], forEach(ast.properties, function(property) {
                    property.computed ? args.push({
                        key: self.recurse(property.key),
                        computed: !0,
                        value: self.recurse(property.value)
                    }) : args.push({
                        key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                        computed: !1,
                        value: self.recurse(property.value)
                    });
                }), function(scope, locals, assign, inputs) {
                    for (var value = {}, i = 0; i < args.length; ++i) args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.LocalsExpression:
                return function(scope, locals) {
                    return context ? {
                        value: locals
                    } : locals;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? +arg : 0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? -arg : -0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = !argument(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = plusFn(lhs, rhs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
                var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: void 0,
                    name: void 0,
                    value: value
                } : value;
            };
        },
        identifier: function(name, context, create) {
            return function(scope, locals, assign, inputs) {
                var base = locals && name in locals ? locals : scope;
                create && 1 !== create && base && null == base[name] && (base[name] = {});
                var value = base ? base[name] : void 0;
                return context ? {
                    context: base,
                    name: name,
                    value: value
                } : value;
            };
        },
        computedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var rhs, value, lhs = left(scope, locals, assign, inputs);
                return null != lhs && (rhs = right(scope, locals, assign, inputs), rhs = getStringValue(rhs), 
                create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), value = lhs[rhs]), 
                context ? {
                    context: lhs,
                    name: rhs,
                    value: value
                } : value;
            };
        },
        nonComputedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                create && 1 !== create && lhs && null == lhs[right] && (lhs[right] = {});
                var value = null != lhs ? lhs[right] : void 0;
                return context ? {
                    context: lhs,
                    name: right,
                    value: value
                } : value;
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                return inputs ? inputs[watchId] : input(scope, value, locals);
            };
        }
    }, Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            var ast = this.ast.ast(text), fn = this.astCompiler.compile(ast);
            return fn.literal = isLiteral(ast), fn.constant = isConstant(ast), fn;
        }
    };
    var $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g, $templateRequestMinErr = minErr("$compile"), urlParsingNode = window.document.createElement("a"), originUrl = urlResolve(window.location.href);
    $$CookieReader.$inject = [ "$document" ], $FilterProvider.$inject = [ "$provide" ];
    var MAX_DIGITS = 22, DECIMAL_SEP = ".", ZERO_CHAR = "0";
    currencyFilter.$inject = [ "$locale" ], numberFilter.$inject = [ "$locale" ];
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4, 0, !1, !0),
        yy: dateGetter("FullYear", 2, 0, !0, !0),
        y: dateGetter("FullYear", 1, 0, !1, !0),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        LLLL: dateStrGetter("Month", !1, !0),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    }, DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref) return function(scope, element) {
                if ("a" === element[0].nodeName.toLowerCase()) {
                    var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        element.attr(href) || event.preventDefault();
                    });
                }
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function(value) {
                attr.$set(attrName, !!value);
            });
        }
        if ("multiple" !== propName) {
            var normalized = directiveNormalize("ng-" + attrName), linkFn = defaultLinkFn;
            "checked" === propName && (linkFn = function(scope, element, attr) {
                attr.ngModel !== attr[normalized] && defaultLinkFn(scope, element, attr);
            }), ngAttributeAliasDirectives[normalized] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: linkFn
                };
            };
        }
    }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" === attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                    }
                    scope.$watch(attr[ngAttr], function(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
                        return value ? (attr.$set(name, value), void (msie && propName && element.prop(propName, attr[name]))) : void ("href" === attrName && attr.$set(name, null));
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, PENDING_CLASS = "ng-pending";
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ], 
    FormController.prototype = {
        $rollbackViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$rollbackViewValue();
            });
        },
        $commitViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$commitViewValue();
            });
        },
        $addControl: function(control) {
            assertNotHasOwnProperty(control.$name, "input"), this.$$controls.push(control), 
            control.$name && (this[control.$name] = control), control.$$parentForm = this;
        },
        $$renameControl: function(control, newName) {
            var oldName = control.$name;
            this[oldName] === control && delete this[oldName], this[newName] = control, control.$name = newName;
        },
        $removeControl: function(control) {
            control.$name && this[control.$name] === control && delete this[control.$name], 
            forEach(this.$pending, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), forEach(this.$error, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), forEach(this.$$success, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), arrayRemove(this.$$controls, control), control.$$parentForm = nullFormCtrl;
        },
        $setDirty: function() {
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), 
            this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty();
        },
        $setPristine: function() {
            this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " ng-submitted"), 
            this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, forEach(this.$$controls, function(control) {
                control.$setPristine();
            });
        },
        $setUntouched: function() {
            forEach(this.$$controls, function(control) {
                control.$setUntouched();
            });
        },
        $setSubmitted: function() {
            this.$$animate.addClass(this.$$element, "ng-submitted"), this.$submitted = !0, this.$$parentForm.$setSubmitted();
        }
    }, addSetValidityMethod({
        clazz: FormController,
        set: function(object, property, controller) {
            var list = object[property];
            if (list) {
                -1 === list.indexOf(controller) && list.push(controller);
            } else object[property] = [ controller ];
        },
        unset: function(object, property, controller) {
            var list = object[property];
            list && (arrayRemove(list, controller), 0 === list.length && delete object[property]);
        }
    });
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", "$parse", function($timeout, $parse) {
            function getSetter(expression) {
                return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop;
            }
            return {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: FormController,
                compile: function(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : !(!isNgForm || !attr.ngForm) && "ngForm";
                    return {
                        pre: function(scope, formElement, attr, ctrls) {
                            var controller = ctrls[0];
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue(), controller.$setSubmitted();
                                    }), event.preventDefault();
                                };
                                formElement[0].addEventListener("submit", handleFormSubmission), formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        formElement[0].removeEventListener("submit", handleFormSubmission);
                                    }, 0, !1);
                                });
                            }
                            (ctrls[1] || controller.$$parentForm).$addControl(controller);
                            var setter = nameAttr ? getSetter(controller.$name) : noop;
                            nameAttr && (setter(scope, controller), attr.$observe(nameAttr, function(newValue) {
                                controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue), 
                                (setter = getSetter(controller.$name))(scope, controller));
                            })), formElement.on("$destroy", function() {
                                controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
        } ];
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4,})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown", PARTIAL_VALIDATION_TYPES = createMap();
    forEach("date,datetime-local,month,time,week".split(","), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = !0;
    });
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        range: rangeInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }, inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                }
            }
        };
    } ], CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
        function updateElementValue(element, attr, value) {
            var propValue = isDefined(value) ? value : 9 === msie ? "" : null;
            element.prop("value", propValue), attr.$set("value", value);
        }
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    updateElementValue(elm, attr, scope.$eval(attr.ngValue));
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        updateElementValue(elm, attr, value);
                    });
                };
            }
        };
    }, ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                        element.textContent = stringify(value);
                    });
                };
            }
        };
    } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], 
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = isUndefined(value) ? "" : value;
                    });
                };
            }
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(val) {
                    return $sce.valueOf(val);
                });
                return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                        var value = ngBindHtmlGetter(scope);
                        element.html($sce.getTrustedHtml(value) || "");
                    });
                };
            }
        };
    } ], ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    }), ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", void 0), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {}, forceAsyncEvents = {
        blur: !0,
        focus: !0
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName]);
                    return function(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback);
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    value ? childScope || $transclude(function(clone, newScope) {
                        childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    }) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), 
                    $animate.leave(previousElements).done(function(response) {
                        !1 !== response && (previousElements = null);
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement).done(function(response) {
                            !1 !== response && (previousElement = null);
                        }), previousElement = currentElement, currentElement = null);
                    };
                    scope.$watch(srcExp, function(src) {
                        var afterAnimation = function(response) {
                            !1 === response || !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }, thisChangeId = ++changeCounter;
                        src ? ($templateRequest(src, !0).then(function(response) {
                            if (!scope.$$destroyed && thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(), $animate.enter(clone, null, $element).done(afterAnimation);
                                });
                                currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), 
                                scope.$eval(onloadExp);
                            }
                        }, function() {
                            scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(), 
                            scope.$emit("$includeContentError", src));
                        }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), 
                        ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                return toString.call($element[0]).match(/SVG/) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function(clone) {
                    $element.append(clone);
                }, {
                    futureParentElement: $element
                })) : ($element.html(ctrl.template), void $compile($element.contents())(scope));
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = attr.ngList || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trimValues ? trim(value) : value);
                        }), list;
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                    if (isArray(value)) return value.join(ngList);
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", ngModelMinErr = minErr("ngModel");
    NgModelController.$inject = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate" ], 
    NgModelController.prototype = {
        $$initGetterSetters: function() {
            if (this.$options.getOption("getterSetter")) {
                var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                this.$$ngModelGet = function($scope) {
                    var modelValue = this.$$parsedNgModel($scope);
                    return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue;
                }, this.$$ngModelSet = function($scope, newValue) {
                    isFunction(this.$$parsedNgModel($scope)) ? invokeModelSetter($scope, {
                        $$$p: newValue
                    }) : this.$$parsedNgModelAssign($scope, newValue);
                };
            } else if (!this.$$parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
        },
        $render: noop,
        $isEmpty: function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value;
        },
        $$updateEmptyClasses: function(value) {
            this.$isEmpty(value) ? (this.$$animate.removeClass(this.$$element, "ng-not-empty"), 
            this.$$animate.addClass(this.$$element, "ng-empty")) : (this.$$animate.removeClass(this.$$element, "ng-empty"), 
            this.$$animate.addClass(this.$$element, "ng-not-empty"));
        },
        $setPristine: function() {
            this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, DIRTY_CLASS), 
            this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
        },
        $setDirty: function() {
            this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), 
            this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$$parentForm.$setDirty();
        },
        $setUntouched: function() {
            this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, "ng-untouched", "ng-touched");
        },
        $setTouched: function() {
            this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, "ng-touched", "ng-untouched");
        },
        $rollbackViewValue: function() {
            this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue, 
            this.$render();
        },
        $validate: function() {
            if (!isNumberNaN(this.$modelValue)) {
                var viewValue = this.$$lastCommittedViewValue, modelValue = this.$$rawModelValue, prevValid = this.$valid, prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid"), that = this;
                this.$$runValidators(modelValue, viewValue, function(allValid) {
                    allowInvalid || prevValid === allValid || (that.$modelValue = allValid ? modelValue : void 0, 
                    that.$modelValue !== prevModelValue && that.$$writeModelToScope());
                });
            }
        },
        $$runValidators: function(modelValue, viewValue, doneCallback) {
            function setValidity(name, isValid) {
                localValidationRunId === that.$$currentValidationRunId && that.$setValidity(name, isValid);
            }
            function validationDone(allValid) {
                localValidationRunId === that.$$currentValidationRunId && doneCallback(allValid);
            }
            this.$$currentValidationRunId++;
            var localValidationRunId = this.$$currentValidationRunId, that = this;
            return function() {
                var errorKey = that.$$parserName || "parse";
                return isUndefined(that.$$parserValid) ? (setValidity(errorKey, null), !0) : (that.$$parserValid || (forEach(that.$validators, function(v, name) {
                    setValidity(name, null);
                }), forEach(that.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                })), setValidity(errorKey, that.$$parserValid), that.$$parserValid);
            }() && function() {
                var syncValidatorsValid = !0;
                return forEach(that.$validators, function(validator, name) {
                    var result = Boolean(validator(modelValue, viewValue));
                    syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
                }), !!syncValidatorsValid || (forEach(that.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                }), !1);
            }() ? void function() {
                var validatorPromises = [], allValid = !0;
                forEach(that.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    setValidity(name, void 0), validatorPromises.push(promise.then(function() {
                        setValidity(name, !0);
                    }, function() {
                        allValid = !1, setValidity(name, !1);
                    }));
                }), validatorPromises.length ? that.$$q.all(validatorPromises).then(function() {
                    validationDone(allValid);
                }, noop) : validationDone(!0);
            }() : void validationDone(!1);
        },
        $commitViewValue: function() {
            var viewValue = this.$viewValue;
            this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== viewValue || "" === viewValue && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(viewValue), 
            this.$$lastCommittedViewValue = viewValue, this.$pristine && this.$setDirty(), this.$$parseAndValidate());
        },
        $$parseAndValidate: function() {
            function writeToModelIfNeeded() {
                that.$modelValue !== prevModelValue && that.$$writeModelToScope();
            }
            var viewValue = this.$$lastCommittedViewValue, modelValue = viewValue, that = this;
            if (this.$$parserValid = !isUndefined(modelValue) || void 0, this.$$parserValid) for (var i = 0; i < this.$parsers.length; i++) if (modelValue = this.$parsers[i](modelValue), 
            isUndefined(modelValue)) {
                this.$$parserValid = !1;
                break;
            }
            isNumberNaN(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
            var prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid");
            this.$$rawModelValue = modelValue, allowInvalid && (this.$modelValue = modelValue, 
            writeToModelIfNeeded()), this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
                allowInvalid || (that.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded());
            });
        },
        $$writeModelToScope: function() {
            this.$$ngModelSet(this.$$scope, this.$modelValue), forEach(this.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    this.$$exceptionHandler(e);
                }
            }, this);
        },
        $setViewValue: function(value, trigger) {
            this.$viewValue = value, this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(trigger);
        },
        $$debounceViewValueCommit: function(trigger) {
            var debounceDelay = this.$options.getOption("debounce");
            isNumber(debounceDelay[trigger]) ? debounceDelay = debounceDelay[trigger] : isNumber(debounceDelay.default) && (debounceDelay = debounceDelay.default), 
            this.$$timeout.cancel(this.$$pendingDebounce);
            var that = this;
            debounceDelay > 0 ? this.$$pendingDebounce = this.$$timeout(function() {
                that.$commitViewValue();
            }, debounceDelay) : this.$$scope.$root.$$phase ? this.$commitViewValue() : this.$$scope.$apply(function() {
                that.$commitViewValue();
            });
        },
        $overrideModelOptions: function(options) {
            this.$options = this.$options.createChild(options);
        }
    }, addSetValidityMethod({
        clazz: NgModelController,
        set: function(object, property) {
            object[property] = !0;
        },
        unset: function(object, property) {
            delete object[property];
        }
    });
    var defaultModelOptions, ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function(element) {
                return element.addClass(PRISTINE_CLASS).addClass("ng-untouched").addClass(VALID_CLASS), 
                {
                    pre: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                        optionsCtrl && (modelCtrl.$options = optionsCtrl.$options), modelCtrl.$$initGetterSetters(), 
                        formCtrl.$addControl(modelCtrl), attr.$observe("name", function(newValue) {
                            modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                        }), scope.$on("$destroy", function() {
                            modelCtrl.$$parentForm.$removeControl(modelCtrl);
                        });
                    },
                    post: function(scope, element, attr, ctrls) {
                        function setTouched() {
                            modelCtrl.$setTouched();
                        }
                        var modelCtrl = ctrls[0];
                        modelCtrl.$options.getOption("updateOn") && element.on(modelCtrl.$options.getOption("updateOn"), function(ev) {
                            modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                        }), element.on("blur", function() {
                            modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(setTouched) : scope.$apply(setTouched));
                        });
                    }
                };
            }
        };
    } ], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    ModelOptions.prototype = {
        getOption: function(name) {
            return this.$$options[name];
        },
        createChild: function(options) {
            var inheritAll = !1;
            return options = extend({}, options), forEach(options, function(option, key) {
                "$inherit" === option ? "*" === key ? inheritAll = !0 : (options[key] = this.$$options[key], 
                "updateOn" === key && (options.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === key && (options.updateOnDefault = !1, 
                options[key] = trim(option.replace(DEFAULT_REGEXP, function() {
                    return options.updateOnDefault = !0, " ";
                })));
            }, this), inheritAll && (delete options["*"], defaults(options, this.$$options)), 
            defaults(options, defaultModelOptions.$$options), new ModelOptions(options);
        }
    }, defaultModelOptions = new ModelOptions({
        updateOn: "",
        updateOnDefault: !0,
        debounce: 0,
        getterSetter: !1,
        allowInvalid: !1,
        timezone: null
    });
    var ngModelOptionsDirective = function() {
        function NgModelOptionsController($attrs, $scope) {
            this.$$attrs = $attrs, this.$$scope = $scope;
        }
        return NgModelOptionsController.$inject = [ "$attrs", "$scope" ], NgModelOptionsController.prototype = {
            $onInit: function() {
                var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions, modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                this.$options = parentOptions.createChild(modelOptionsDefinition);
            }
        }, {
            restrict: "A",
            priority: 10,
            require: {
                parentCtrl: "?^^ngModelOptions"
            },
            bindToController: !0,
            controller: NgModelOptionsController
        };
    }, ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, 
                this.group = group, this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else {
                    optionValuesKeys = [];
                    for (var itemKey in optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                }
                return optionValuesKeys;
            }
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), selectAsFn = selectAs && $parse(selectAs), viewValueFn = selectAsFn || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function(value, locals) {
                return trackByFn(scope, locals);
            } : function(value) {
                return hashKey(value);
            }, getTrackByValue = function(value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function(value, key) {
                return locals[keyName] = key, locals[valueName] = value, locals;
            } : function(value) {
                return locals[valueName] = value, locals;
            };
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function(optionValues) {
                    var watchedArray = [];
                    optionValues = optionValues || [];
                    for (var optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), selectValue = getTrackByValueFn(value, locals);
                        if (watchedArray.push(selectValue), match[2] || match[1]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    }
                    return watchedArray;
                }),
                getOptions: function() {
                    for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), viewValue = viewValueFn(scope, locals), selectValue = getTrackByValueFn(viewValue, locals), label = displayFn(scope, locals), group = groupByFn(scope, locals), disabled = disableWhenFn(scope, locals), optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem), selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function(option) {
                            return trackBy ? copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
            function addOptionElement(option, parent) {
                var optionElement = optionTemplate.cloneNode(!1);
                parent.appendChild(optionElement), updateOptionElement(option, optionElement);
            }
            function getAndUpdateSelectedOption(viewValue) {
                var option = options.getOptionFromViewValue(viewValue), element = option && option.element;
                return element && !element.selected && (element.selected = !0), option;
            }
            function updateOptionElement(option, element) {
                option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label, 
                element.textContent = option.label), element.value = option.selectValue;
            }
            function updateOptions() {
                var previousValue = options && selectCtrl.readValue();
                if (options) for (var i = options.items.length - 1; i >= 0; i--) {
                    var option = options.items[i];
                    jqLiteRemove(isDefined(option.group) ? option.element.parentNode : option.element);
                }
                options = ngOptions.getOptions();
                var groupElementMap = {};
                if (providedEmptyOption && selectElement.prepend(selectCtrl.emptyOption), options.items.forEach(function(option) {
                    var groupElement;
                    isDefined(option.group) ? (groupElement = groupElementMap[option.group], groupElement || (groupElement = optGroupTemplate.cloneNode(!1), 
                    listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group, 
                    groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment);
                }), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                    var nextValue = selectCtrl.readValue();
                    (ngOptions.trackBy || multiple ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), 
                    ngModelCtrl.$render());
                }
            }
            for (var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) if ("" === children[i].value) {
                selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = children.eq(i);
                break;
            }
            var providedEmptyOption = !!selectCtrl.emptyOption;
            jqLite(optionTemplate.cloneNode(!1)).val("?");
            var options, ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope), listFragment = $document[0].createDocumentFragment();
            selectCtrl.generateUnknownOptionValue = function(val) {
                return "?";
            }, multiple ? (selectCtrl.writeValue = function(values) {
                var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                options.items.forEach(function(option) {
                    option.element.selected && !includes(selectedOptions, option) && (option.element.selected = !1);
                });
            }, selectCtrl.readValue = function() {
                var selectedValues = selectElement.val() || [], selections = [];
                return forEach(selectedValues, function(value) {
                    var option = options.selectValueMap[value];
                    option && !option.disabled && selections.push(options.getViewValueFromOption(option));
                }), selections;
            }, ngOptions.trackBy && scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                });
            }, function() {
                ngModelCtrl.$render();
            })) : (selectCtrl.writeValue = function(value) {
                var selectedOption = options.selectValueMap[selectElement.val()], option = options.getOptionFromViewValue(value);
                selectedOption && selectedOption.element.removeAttribute("selected"), option ? (selectElement[0].value !== option.selectValue && (selectCtrl.removeUnknownOption(), 
                selectCtrl.unselectEmptyOption(), selectElement[0].value = option.selectValue, option.element.selected = !0), 
                option.element.setAttribute("selected", "selected")) : providedEmptyOption ? selectCtrl.selectEmptyOption() : selectCtrl.unknownOption.parent().length ? selectCtrl.updateUnknownOption(value) : selectCtrl.renderUnknownOption(value);
            }, selectCtrl.readValue = function() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                return selectedOption && !selectedOption.disabled ? (selectCtrl.unselectEmptyOption(), 
                selectCtrl.removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null;
            }, ngOptions.trackBy && scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
            }, function() {
                ngModelCtrl.$render();
            })), providedEmptyOption && (selectCtrl.emptyOption.remove(), $compile(selectCtrl.emptyOption)(scope), 
            selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT ? (selectCtrl.hasEmptyOption = !1, 
            selectCtrl.registerOption = function(optionScope, optionEl) {
                "" === optionEl.val() && (selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = optionEl, 
                selectCtrl.emptyOption.removeClass("ng-scope"), ngModelCtrl.$render(), optionEl.on("$destroy", function() {
                    selectCtrl.hasEmptyOption = !1, selectCtrl.emptyOption = void 0;
                }));
            }) : selectCtrl.emptyOption.removeClass("ng-scope")), selectElement.empty(), updateOptions(), 
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
        }
        var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "ngModel" ],
            link: {
                pre: function(scope, selectElement, attr, ctrls) {
                    ctrls[0].registerOption = noop;
                },
                post: ngOptionsPostLink
            }
        };
    } ], ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function(scope, element, attr) {
                function updateElementText(newText) {
                    element.text(newText || "");
                }
                var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                }), scope.$watch(numberExp, function(newVal) {
                    var count = parseFloat(newVal), countIsNaN = isNumberNaN(count);
                    if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), 
                    !(count === lastCount || countIsNaN && isNumberNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), 
                        watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), 
                        lastCount = count;
                    }
                });
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
        var ngRepeatMinErr = minErr("ngRepeat"), updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, 
            scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), 
            scope.$odd = !(scope.$even = 0 == (1 & index));
        }, getBlockStart = function(block) {
            return block.clone[0];
        }, getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function($element, $attr) {
                var expression = $attr.ngRepeat, ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                if (!(match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/))) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {
                    $id: hashKey
                };
                return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function(key) {
                    return key;
                }), function($scope, $element, $attr, ctrl, $transclude) {
                    trackByExpGetter && (trackByIdExpFn = function(key, value, index) {
                        return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                        hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                    });
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function(collection) {
                        var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                        if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, 
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                            for (var itemKey in collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                        }
                        for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), 
                        index = 0; index < collectionLength; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], trackById = trackByIdFn(key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], 
                        delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                            if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                block && block.scope && (lastBlockMap[block.id] = block);
                            }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            nextBlockOrder[index] = {
                                id: trackById,
                                scope: void 0,
                                clone: void 0
                            }, nextBlockMap[trackById] = !0;
                        }
                        for (var blockKey in lastBlockMap) {
                            if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), 
                            $animate.leave(elementsToRemove), elementsToRemove[0].parentNode) for (index = 0, 
                            length = elementsToRemove.length; index < length; index++) elementsToRemove[index].$$NG_REMOVED = !0;
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], block = nextBlockOrder[index], block.scope) {
                            nextNode = previousNode;
                            do {
                                nextNode = nextNode.nextSibling;
                            } while (nextNode && nextNode.$$NG_REMOVED);
                            getBlockStart(block) !== nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode), 
                            previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        } else $transclude(function(clone, scope) {
                            block.scope = scope;
                            var endNode = ngRepeatEndComment.cloneNode(!1);
                            clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode, 
                            block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        });
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ], ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function(value) {
                    $animate[value ? "removeClass" : "addClass"](element, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function(value) {
                    $animate[value ? "addClass" : "removeClass"](element, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        }, !0);
    }), ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function(array, index) {
                    return function(response) {
                        !1 !== response && array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function(value) {
                    for (var i, ii; previousLeaveAnimations.length; ) $animate.cancel(previousLeaveAnimations.pop());
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        (previousLeaveAnimations[i] = $animate.leave(selected)).done(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                        selectedTransclude.transclude(function(caseElement, selectedScope) {
                            selectedScopes.push(selectedScope);
                            var anchor = selectedTransclude.element;
                            caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                            var block = {
                                clone: caseElement
                            };
                            selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    });
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attrs, ctrl, $transclude) {
            forEach(attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                return array[index - 1] !== element;
            }), function(whenCase) {
                ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [], ctrl.cases["!" + whenCase].push({
                    transclude: $transclude,
                    element: element
                });
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeMinErr = minErr("ngTransclude"), ngTranscludeDirective = [ "$compile", function($compile) {
        return {
            restrict: "EAC",
            terminal: !0,
            compile: function(tElement) {
                var fallbackLinkFn = $compile(tElement.contents());
                return tElement.empty(), function($scope, $element, $attrs, controller, $transclude) {
                    function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                        clone.length && notWhitespace(clone) ? $element.append(clone) : (useFallbackContent(), 
                        transcludedScope.$destroy());
                    }
                    function useFallbackContent() {
                        fallbackLinkFn($scope, function(clone) {
                            $element.append(clone);
                        });
                    }
                    function notWhitespace(nodes) {
                        for (var i = 0, ii = nodes.length; i < ii; i++) {
                            var node = nodes[i];
                            if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) return !0;
                        }
                    }
                    if (!$transclude) throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                    $attrs.ngTransclude === $attrs.$attr.ngTransclude && ($attrs.ngTransclude = "");
                    var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                    $transclude(ngTranscludeCloneAttachFn, null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent();
                };
            }
        };
    } ], scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" === attr.type) {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ], noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    }, SelectController = [ "$element", "$scope", function($element, $scope) {
        function scheduleRender() {
            renderScheduled || (renderScheduled = !0, $scope.$$postDigest(function() {
                renderScheduled = !1, self.ngModelCtrl.$render();
            }));
        }
        function scheduleViewValueUpdate(renderAfter) {
            updateScheduled || (updateScheduled = !0, $scope.$$postDigest(function() {
                $scope.$$destroyed || (updateScheduled = !1, self.ngModelCtrl.$setViewValue(self.readValue()), 
                renderAfter && self.ngModelCtrl.$render());
            }));
        }
        var self = this, optionsMap = new NgMap();
        self.selectValueMap = {}, self.ngModelCtrl = noopNgModelController, self.multiple = !1, 
        self.unknownOption = jqLite(window.document.createElement("option")), self.hasEmptyOption = !1, 
        self.emptyOption = void 0, self.renderUnknownOption = function(val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), setOptionSelectedStatus(self.unknownOption, !0), 
            $element.val(unknownVal);
        }, self.updateUnknownOption = function(val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal), setOptionSelectedStatus(self.unknownOption, !0), 
            $element.val(unknownVal);
        }, self.generateUnknownOptionValue = function(val) {
            return "? " + hashKey(val) + " ?";
        }, self.removeUnknownOption = function() {
            self.unknownOption.parent() && self.unknownOption.remove();
        }, self.selectEmptyOption = function() {
            self.emptyOption && ($element.val(""), setOptionSelectedStatus(self.emptyOption, !0));
        }, self.unselectEmptyOption = function() {
            self.hasEmptyOption && self.emptyOption.removeAttr("selected");
        }, $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        }), self.readValue = function() {
            var val = $element.val(), realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
            return self.hasOption(realVal) ? realVal : null;
        }, self.writeValue = function(value) {
            var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
            if (currentlySelectedOption && setOptionSelectedStatus(jqLite(currentlySelectedOption), !1), 
            self.hasOption(value)) {
                self.removeUnknownOption();
                var hashedVal = hashKey(value);
                $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                var selectedOption = $element[0].options[$element[0].selectedIndex];
                setOptionSelectedStatus(jqLite(selectedOption), !0);
            } else null == value && self.emptyOption ? (self.removeUnknownOption(), self.selectEmptyOption()) : self.unknownOption.parent().length ? self.updateUnknownOption(value) : self.renderUnknownOption(value);
        }, self.addOption = function(value, element) {
            if (element[0].nodeType !== NODE_TYPE_COMMENT) {
                assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.hasEmptyOption = !0, 
                self.emptyOption = element);
                var count = optionsMap.get(value) || 0;
                optionsMap.set(value, count + 1), scheduleRender();
            }
        }, self.removeOption = function(value) {
            var count = optionsMap.get(value);
            count && (1 === count ? (optionsMap.delete(value), "" === value && (self.hasEmptyOption = !1, 
            self.emptyOption = void 0)) : optionsMap.set(value, count - 1));
        }, self.hasOption = function(value) {
            return !!optionsMap.get(value);
        };
        var renderScheduled = !1, updateScheduled = !1;
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
            if (optionAttrs.$attr.ngValue) {
                var oldVal, hashedVal = NaN;
                optionAttrs.$observe("value", function(newVal) {
                    var removal, previouslySelected = optionElement.prop("selected");
                    isDefined(hashedVal) && (self.removeOption(oldVal), delete self.selectValueMap[hashedVal], 
                    removal = !0), hashedVal = hashKey(newVal), oldVal = newVal, self.selectValueMap[hashedVal] = newVal, 
                    self.addOption(newVal, optionElement), optionElement.attr("value", hashedVal), removal && previouslySelected && scheduleViewValueUpdate();
                });
            } else interpolateValueFn ? optionAttrs.$observe("value", function(newVal) {
                self.readValue();
                var removal, previouslySelected = optionElement.prop("selected");
                isDefined(oldVal) && (self.removeOption(oldVal), removal = !0), oldVal = newVal, 
                self.addOption(newVal, optionElement), removal && previouslySelected && scheduleViewValueUpdate();
            }) : interpolateTextFn ? optionScope.$watch(interpolateTextFn, function(newVal, oldVal) {
                optionAttrs.$set("value", newVal);
                var previouslySelected = optionElement.prop("selected");
                oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement), 
                oldVal && previouslySelected && scheduleViewValueUpdate();
            }) : self.addOption(optionAttrs.value, optionElement);
            optionAttrs.$observe("disabled", function(newVal) {
                ("true" === newVal || newVal && optionElement.prop("selected")) && (self.multiple ? scheduleViewValueUpdate(!0) : (self.ngModelCtrl.$setViewValue(null), 
                self.ngModelCtrl.$render()));
            }), optionElement.on("$destroy", function() {
                var currentValue = self.readValue(), removeValue = optionAttrs.value;
                self.removeOption(removeValue), scheduleRender(), (self.multiple && currentValue && -1 !== currentValue.indexOf(removeValue) || currentValue === removeValue) && scheduleViewValueUpdate(!0);
            });
        };
    } ], selectDirective = function() {
        function selectPreLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) return void (selectCtrl.registerOption = noop);
            if (selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", function() {
                selectCtrl.removeUnknownOption(), scope.$apply(function() {
                    ngModelCtrl.$setViewValue(selectCtrl.readValue());
                });
            }), attr.multiple) {
                selectCtrl.multiple = !0, selectCtrl.readValue = function() {
                    var array = [];
                    return forEach(element.find("option"), function(option) {
                        if (option.selected && !option.disabled) {
                            var val = option.value;
                            array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                        }
                    }), array;
                }, selectCtrl.writeValue = function(value) {
                    forEach(element.find("option"), function(option) {
                        var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                        shouldBeSelected !== option.selected && setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                    });
                };
                var lastView, lastViewRef = NaN;
                scope.$watch(function() {
                    lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), 
                    ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue;
                }), ngModelCtrl.$isEmpty = function(value) {
                    return !value || 0 === value.length;
                };
            }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                var selectCtrl = ctrls[0];
                ngModelCtrl.$render = function() {
                    selectCtrl.writeValue(ngModelCtrl.$viewValue);
                };
            }
        }
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            priority: 1,
            link: {
                pre: selectPreLink,
                post: selectPostLink
            }
        };
    }, optionDirective = [ "$interpolate", function($interpolate) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                var interpolateValueFn, interpolateTextFn;
                return isDefined(attr.ngValue) || (isDefined(attr.value) ? interpolateValueFn = $interpolate(attr.value, !0) : (interpolateTextFn = $interpolate(element.text(), !0)) || attr.$set("value", element.text())), 
                function(scope, element, attr) {
                    var parent = element.parent(), selectCtrl = parent.data("$selectController") || parent.parent().data("$selectController");
                    selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                };
            }
        };
    } ], requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                ctrl && (attr.required = !0, ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                }, attr.$observe("required", function() {
                    ctrl.$validate();
                }));
            }
        };
    }, patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function(regex) {
                        if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")), 
                        regex && !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        regexp = regex || void 0, ctrl.$validate();
                    }), ctrl.$validators.pattern = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                    };
                }
            }
        };
    }, maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var maxlength = -1;
                    attr.$observe("maxlength", function(value) {
                        var intVal = toInt(value);
                        maxlength = isNumberNaN(intVal) ? -1 : intVal, ctrl.$validate();
                    }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                        return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                    };
                }
            }
        };
    }, minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var minlength = 0;
                    attr.$observe("minlength", function(value) {
                        minlength = toInt(value) || 0, ctrl.$validate();
                    }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                    };
                }
            }
        };
    };
    window.angular.bootstrap ? window.console && console.log("WARNING: Tried to load angular more than once.") : (function() {
        var originalCleanData;
        if (!bindJQueryFired) {
            var jqName = jq();
            jQuery = isUndefined(jqName) ? window.jQuery : jqName ? window[jqName] : void 0, 
            jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            }), originalCleanData = jQuery.cleanData, jQuery.cleanData = function(elems) {
                for (var events, elem, i = 0; null != (elem = elems[i]); i++) (events = jQuery._data(elem, "events")) && events.$destroy && jQuery(elem).triggerHandler("$destroy");
                originalCleanData(elems);
            }) : jqLite = JQLite, angular.element = jqLite, bindJQueryFired = !0;
        }
    }(), function(angular) {
        extend(angular, {
            errorHandlingConfig: errorHandlingConfig,
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            merge: merge,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                $$counter: 0
            },
            getTestability: getTestability,
            reloadWithDebugInfo: reloadWithDebugInfo,
            $$minErr: minErr,
            $$csp: csp,
            $$encodeUriSegment: encodeUriSegment,
            $$encodeUriQuery: encodeUriQuery,
            $$stringify: stringify
        }), angularModule = setupModuleLoader(window), angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $$isDocumentHidden: $$IsDocumentHiddenProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$Map: $$MapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        } ]).info({
            angularVersion: "1.6.4"
        });
    }(angular), angular.module("ngLocale", [], [ "$provide", function($provide) {
        function getDecimals(n) {
            n += "";
            var i = n.indexOf(".");
            return -1 == i ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
            var v = opt_precision;
            void 0 === v && (v = Math.min(getDecimals(n), 3));
            var base = Math.pow(10, v);
            return {
                v: v,
                f: (n * base | 0) % base
            };
        }
        var PLURAL_CATEGORY = {
            ZERO: "zero",
            ONE: "one",
            TWO: "two",
            FEW: "few",
            MANY: "many",
            OTHER: "other"
        };
        $provide.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                short: "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            localeID: "en_US",
            pluralCat: function(n, opt_precision) {
                var i = 0 | n, vf = getVF(n, opt_precision);
                return 1 == i && 0 == vf.v ? PLURAL_CATEGORY.ONE : PLURAL_CATEGORY.OTHER;
            }
        });
    } ]), jqLite(function() {
        angularInit(window.document, bootstrap);
    }));
}(window), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'), 
define("angular", [ "jquery" ], function() {}), define("routes", [], function() {
    return {
        defaultRoutePath: "/404",
        routes: {
            "/": {
                templateUrl: "views/HomeCtrl.05d2cad9.html",
                controller: "HomeCtrl",
                controllerAs: "home"
            },
            "/auth/login": {
                templateUrl: "views/LoginCtrl.e8700b89.html",
                controller: "LoginCtrl",
                controllerAs: "login"
            },
            "/auth/register": {
                templateUrl: "views/RegisterCtrl.1cfcd7ef.html",
                controller: "RegisterCtrl",
                controllerAs: "register"
            },
            "/auth/forgot-pass": {
                templateUrl: "views/ForgotPassCtrl.2d25b30d.html",
                controller: "ForgotPassCtrl",
                controllerAs: "pass"
            },
            "/auth/reset-pass": {
                templateUrl: "views/ResetPassCtrl.0c21f22f.html",
                controller: "ResetPassCtrl",
                controllerAs: "reset"
            },
            "/profile/details": {
                templateUrl: "views/ProfileCtrl.ced3f4be.html",
                controller: "ProfileCtrl",
                controllerAs: "profile",
                controllers: [ "ScoreCtrl" ]
            },
            "/store/sell/details": {
                templateUrl: "views/SellCtrl.f337a0ac.html",
                controller: "SellCtrl",
                controllerAs: "sell"
            },
            "/store/sell/images/:id": {
                templateUrl: "views/ImagesCtrl.34a90eef.html",
                controller: "ImagesCtrl",
                controllerAs: "images"
            },
            "/store/items/all": {
                templateUrl: "views/AllCtrl.5b243264.html",
                controller: "AllCtrl",
                controllerAs: "all"
            },
            "/store/items/:id": {
                templateUrl: "views/ItemCtrl.3d7cfa39.html",
                controller: "ItemCtrl",
                controllerAs: "item"
            },
            "/store/item/:id/details": {
                templateUrl: "views/EditCtrl.239a98ce.html",
                controller: "EditCtrl",
                controllerAs: "edit"
            },
            "/id/:username/:role": {
                templateUrl: "views/IdCtrl.37273038.html",
                controller: "IdCtrl",
                controllerAs: "id"
            },
            "/403": {
                templateUrl: "views/403.4d73f3f4.html",
                controller: "ForbiddenCtrl",
                controllerAs: "forbiddenCtrl"
            },
            "/404": {
                templateUrl: "views/404.00a778e8.html",
                controller: "NotFoundCtrl",
                controllerAs: "notFoundCtrl"
            }
        }
    };
}), define("services/dependencyResolverFor", [], function() {
    return function(dependencies) {
        return console.log("dependencyResolverFor", dependencies), {
            resolver: [ "$q", "$rootScope", function($q, $rootScope) {
                var deferred = $q.defer();
                return require(dependencies, function() {
                    console.log("resolved", dependencies), deferred.resolve(), $rootScope.$apply(function() {});
                }, function(err) {
                    console.log(err), console.log(err.requireModules), _.each(err.requireModules, requirejs.undef);
                }), deferred.promise;
            } ]
        };
    };
}), define("services/protectedRoute", [], function() {
    return function(route) {
        return {
            resolver: [ "$q", "$rootScope", "$location", "AuthService", "ItemService", function($q, $rootScope, $location, AuthService, ItemService) {
                var deferred = $q.defer();
                return console.log("protected route"), route.protected ? (console.log("checking authentication state"), 
                AuthService.isTokenValid() ? deferred.resolve() : (AuthService.syncWithLocalStorage().then(function(profile) {
                    $q.when(route.protected.call({
                        $q: $q,
                        $rootScope: $rootScope,
                        $location: $location,
                        AuthService: AuthService,
                        ItemService: ItemService
                    }, profile)).then(function(path) {
                        return console.log(path), isFinite(path) ? $location.path("/" + path) : _.isString(path) && $location.path(path), 
                        console.log($location.path()), deferred.resolve();
                    }, function(err) {
                        return deferred.resolve();
                    });
                }, function(error) {
                    console.log(error);
                }), deferred.promise)) : (console.log("route is not protected"), deferred.resolve());
            } ]
        };
    };
}), define("i18n/i18nLoader", [], function() {
    var userLang, listOfSupportedLanguages = [ "en", "es" ];
    return "object" == typeof navigator && (userLang = navigator.language || navigator.userLanguage, 
    userLang = userLang.split("-")[0]), (void 0 === userLang || listOfSupportedLanguages.indexOf(userLang) < 0) && (userLang = "en"), 
    {
        load: function(name, require, load) {
            require([ "i18n/messages_" + userLang ], function(value) {
                return load(value), value;
            });
        }
    };
}), define("i18n/messages_en", [], function() {
    return {
        "403.headline": "Access Denied",
        "403.home": "Home",
        "404.headline": "Resource not found",
        "404.home": "Home",
        "500.headline": "Ups, we may have done something wrong",
        "500.home": "Home",
        "Digits.SellForm.price": "Item cant be free or cost more than a thousand million",
        "Email.ProfileForm.email": "Email format is invalid",
        "Email.RegisterForm.email": "Email format is invalid",
        "Email.SellForm.email": "Email format is invalid",
        "EmailExists.ProfileForm.email": "Email already exists",
        "EmailExists.RegisterForm.email": "Email already exists",
        "EmailNotExists.PasswordRecoveryForm.email": "Email does not exist in our records",
        "Max.SellForm.price": "Price can't be higher than ${1}",
        "Min.SellForm.price": "Price must be at least ${1}",
        "NotEmpty.CommentForm.content": "Review can't be empty",
        "NotEmpty.ProfileForm.email": "Email cant be empty",
        "NotEmpty.RegisterForm.email": "Email cant be empty",
        "NotEmpty.SellForm.email": "Email is required",
        "NotNull.SellForm.price": "Price is required",
        "PasswordMatch.ChangePasswordForm.repeatPassword": "Passwords do not match",
        "PasswordMatch.RegisterForm.repeatPassword": "Passwords do not match",
        "Pattern.RoleForm.slug": "Slug name must have uppercase letters, numbers, '-' or '_' without spaces",
        "Size.CategoryForm.name": "Name must have between {min} y {max} characters",
        "Size.CommentForm.content": "Review must have up to {max} characters",
        "Size.CommentForm.contentFixed": "Review must have up to 300 characters",
        "Size.RegisterForm.firstName": "Your name must have between {min} y {max} characters",
        "Size.RegisterForm.lastName": "Your last name must have between {min} y {max} characters",
        "Size.RegisterForm.password": "Your password must have between {min} y {max} characters",
        "Size.RegisterForm.username": "Your username must have between {min} y {max} characters",
        "Size.RoleForm.name": "Role name must have between {min} and {max} characters",
        "Size.RoleForm.slug": "Slug name must have between {min} and {max} characters",
        "Size.SellForm.name": "Item name must have between {min} and {max} characters",
        "UsernameExists.RegisterForm.username": "Username already exists",
        "WrongPassword.ChangePasswordForm.oldPassword": "This was not your password",
        "admin.categories.create.action": "Create",
        "admin.categories.create.cancel": "Cancel",
        "admin.categories.create.headline": "Create Category",
        "admin.categories.create.name": "Name",
        "admin.categories.create.success": "Successful Creation",
        "admin.categories.create.successInfo": "This window will close automatically",
        "admin.categories.rename.action": "Rename",
        "admin.categories.rename.headline": "Renaming category",
        "admin.categories.rename.name": "Name",
        "admin.categories.rename.success": "Successful update",
        "admin.categories.rename.successInfo": "This window will close automatically",
        "admin.category.add": "New Sub-Category",
        "admin.category.headline": "Categories",
        "admin.category.rename": "Rename",
        "admin.index.categories": "Categories",
        "admin.index.headline": "Dashboard",
        "admin.index.items": "Items",
        "admin.index.users": "Users",
        "admin.roles.add": "Add",
        "admin.roles.create.headline": "Create Role",
        "admin.roles.create.name": "Name",
        "admin.roles.default": "Default",
        "admin.roles.defaultFail": "The role could not be made default",
        "admin.roles.defaultSuccess": "Default role has been changed",
        "admin.roles.headline": "Roles",
        "admin.roles.isDefault": "Default role",
        "admin.roles.makeDefault": "Make Default",
        "admin.roles.name": "Name",
        "admin.sidebar.roles": "Roles",
        "admin.users.add": "Add",
        "admin.users.create.email": "Email",
        "admin.users.create.headline": "Create User",
        "admin.users.create.lastName": "Last Name",
        "admin.users.create.mainRole": "Main Role",
        "admin.users.create.name": "First Name",
        "admin.users.create.password": "Password",
        "admin.users.create.repeatPassword": "Repeat Password",
        "admin.users.create.username": "Username",
        "admin.users.edit.add": "Add",
        "admin.users.edit.addRole": "New Role",
        "admin.users.edit.headline": "Roles",
        "admin.users.editRoles": "Edit Roles",
        "admin.users.email": "Email",
        "admin.users.headline": "Users",
        "admin.users.lastName": "Last Name",
        "admin.users.name": "First Name",
        "admin.users.roles": "Roles",
        "admin.users.username": "Username",
        "auth.forgotpass.success.message": "Check your mailbox",
        "auth.forgotpass.success.title": "Email has been sent",
        "edit.action": "Edit",
        "edit.details": "Details",
        "edit.details.categoryChosen": "You chose:",
        "edit.headline": "Editing",
        "edit.images": "Images",
        "index.categories": "Categories",
        "index.favourite.empty": "You dont have any favourites, add them to see them",
        "index.favourite.remove": "Remove",
        "index.favourite.title": "Favourites",
        "index.favourite.viewAll": "See All",
        "index.headline": "What do you wish to buy?",
        "index.login": "Login",
        "index.promoted": "Best Selling",
        "index.register": "Register",
        "index.search": "Search",
        "index.sell": "Sell",
        "index.user.items": "My Items",
        "index.user.logout": "Logout",
        "index.user.profile": "My Profile",
        "index.user.purchases": "My Purchases",
        "index.user.sales": "My Sales",
        "item.bought.underRevision": "Your purchase is under revision by the seller.",
        "item.bought.viewStatus": "Click here to see its status",
        "item.buy": "Buy",
        "item.comment": "Review",
        "item.commentAction": "Review",
        "item.commentEmpty": "No reviews yet",
        "item.comments": "Review",
        "item.description": "Description",
        "item.favourite": "Mark as favourite",
        "item.item": "Item Status",
        "item.new": "New",
        "item.notifications.draft.message": "This item is a draft. Click here to edit",
        "item.notifications.draft.title": "This is a draft",
        "item.notifications.paused.alternative": "Or click here to edit",
        "item.notifications.paused.message": "This publication is paused. Click here to resume it",
        "item.notifications.paused.title": "This publication is paused",
        "item.seller": "Seller",
        "item.seller.publications": "Items from the same seller",
        "item.sold": "sold",
        "item.used": "Used",
        "login.error.error": "Error!",
        "login.error.wrongData": "Wrong username or password",
        "login.field.password": "Password",
        "login.field.rememberMe": "Remember me",
        "login.field.user": "Username",
        "login.form.noUserQuestion": "Still don't have a user?",
        "login.form.register": "Register",
        "login.recover.help": "Enter your e-mail and we will send you intructions to recover your password",
        "login.recover.invalidLink": "The link is not valid",
        "login.recover.maxTime": "You have at most 3 hours to renew your password",
        "login.recover.question": "Did you forget your password?",
        "login.recover.recover": "Recover",
        "login.recover.recoverIt": "Recover it",
        "login.submit.login": "Sign in",
        "profile.account.form.email": "Email",
        "profile.account.form.lastName": "Last Name",
        "profile.account.form.name": "First Name",
        "profile.account.form.update": "Update",
        "profile.account.form.username": "Username",
        "profile.account.title": "Account",
        "profile.favourites.table.item": "Item",
        "profile.favourites.table.search": "Search",
        "profile.favourites.table.seller": "Seller",
        "profile.favourites.title": "Favourites",
        "profile.items.active": "Active Publications",
        "profile.items.all": "All Publications",
        "profile.items.drafts": "Drafts",
        "profile.items.paused": "Paused Publications",
        "profile.items.table.edit": "Edit",
        "profile.items.table.edit_images": "Edit Images",
        "profile.items.table.item": "Item",
        "profile.items.table.name": "Name",
        "profile.items.table.pause": "Pause Publication",
        "profile.items.table.picture": "Picture",
        "profile.items.table.price": "Price",
        "profile.items.table.publish": "Publish",
        "profile.items.table.resume": "Resume Publication",
        "profile.items.table.search": "Search",
        "profile.items.table.sold": "Sold",
        "profile.items.table.status": "Status",
        "profile.items.title": "Published Items",
        "profile.modal.scores.buyer": "Buyer",
        "profile.modal.scores.close": "Close",
        "profile.modal.scores.error": "Error",
        "profile.modal.scores.lowerBuyer": "buyer",
        "profile.modal.scores.lowerSeller": "seller",
        "profile.modal.scores.score": "Score",
        "profile.modal.scores.scoreBuyer": "Do you wish to score the buyer now?",
        "profile.modal.scores.scoresFrom": "Score from",
        "profile.modal.scores.scoringTo": "Scoring",
        "profile.modal.scores.seller": "Seller",
        "profile.modal.scores.stillNoScore": "This sale is yet to be scored",
        "profile.modal.scores.success": "Score was successfully submitted",
        "profile.modal.scores.title": "Seeing Scores",
        "profile.modal.scores.toScore": "Score",
        "profile.modal.scores.voidContent": "Empty content",
        "profile.modal.scores.yourScore": "Your score",
        "profile.password.form.current": "Current Password",
        "profile.password.form.new": "New Password",
        "profile.password.form.repeat": "Repeat New Password",
        "profile.password.title": "Password",
        "profile.public.buyer": "buyer",
        "profile.public.nopurchases": "has not bought any item yet",
        "profile.public.nosales": "has not sold an item yet",
        "profile.public.score.buyer": "Score as a buyer",
        "profile.public.score.buyer.acceptance": "Acceptance score",
        "profile.public.score.buyer.acceptedPurchases": "Approved Purchases",
        "profile.public.score.buyer.rejectedPurchases": "Rejected Purchases",
        "profile.public.score.seller": "Score as a seller",
        "profile.public.score.seller.approvedSales": "Approved Sales",
        "profile.public.score.seller.recommendation": "Recommendation score",
        "profile.public.score.seller.rejectedSales": "Rejected Sales",
        "profile.public.seller": "seller",
        "profile.public.seller.items": "Published Items",
        "profile.public.viewProfileOf": "View profile as a",
        "profile.purchases.approved": "Approved Purchases",
        "profile.purchases.declined": "Declined Purchases",
        "profile.purchases.pending": "Pending Purchases",
        "profile.purchases.seeScores": "See scores",
        "profile.purchases.seller": "Seller",
        "profile.purchases.table.date": "Date",
        "profile.purchases.table.item": "Item",
        "profile.purchases.table.score": "Score",
        "profile.purchases.table.search": "Search",
        "profile.purchases.table.seller": "Seller",
        "profile.purchases.title": "Purchases",
        "profile.sales.approved": "Approved Sales",
        "profile.sales.danger": "REJECT",
        "profile.sales.declined": "Declined Sales",
        "profile.sales.nothing": "Nothing Found",
        "profile.sales.pending": "Pending Sales",
        "profile.sales.seeScores": "See scores",
        "profile.sales.sell.approve": "approve",
        "profile.sales.sell.approved": "Purchase Approved",
        "profile.sales.sell.approving": "approving your sell",
        "profile.sales.sell.confirmation": "Are you sure you want to",
        "profile.sales.sell.confirmation2": "this purchase?",
        "profile.sales.sell.error": "There was a problem",
        "profile.sales.sell.pause": "pause",
        "profile.sales.sell.pauseBtn": "Pause Publication",
        "profile.sales.sell.pausing": "pausing your publication",
        "profile.sales.sell.publishConfirmation": "Are your sure you wish to publish this item?",
        "profile.sales.sell.published": "Published",
        "profile.sales.sell.publishing": "publishing your item",
        "profile.sales.sell.reject": "reject",
        "profile.sales.sell.rejected": "Purchase Rejected",
        "profile.sales.sell.rejecting": "rejecting your sale",
        "profile.sales.sell.resume": "resume",
        "profile.sales.sell.resumeBtn": "Resume Publication",
        "profile.sales.sell.resuming": "resuming your publication",
        "profile.sales.sell.success": "Your action was successfully executed",
        "profile.sales.success": "APPROVE",
        "profile.sales.table.buyer": "Buyer",
        "profile.sales.table.date": "Date",
        "profile.sales.table.item": "Item",
        "profile.sales.table.score": "Scores",
        "profile.sales.table.search": "Search",
        "profile.sales.title": "Sales",
        "register.form.createAccount": "Create Account",
        "register.form.hasAccount": "Already have an account?",
        "register.form.login": "Click here",
        "register.form.mail": "E-mail",
        "register.form.name": "Name",
        "register.form.repeatPassword": "Repeat password",
        "register.form.surname": "Surname",
        "search.filters.applied": "Applied Filters",
        "search.filters.categories": "Categories",
        "search.filters.categories.apply": "Apply",
        "search.filters.order.alphabetic": "Alphabetic",
        "search.filters.order.by": "Order by",
        "search.filters.order.priceAsc": "Lowest Price",
        "search.filters.order.priceDesc": "Highest Price",
        "search.filters.order.recentAsc": "Least Recent",
        "search.filters.order.recentDesc": "Most Recent",
        "search.filters.order.soldAsc": "Least Sold",
        "search.filters.order.soldDesc": "Most Sold",
        "search.filters.pagination.modifiers.amount": "Items",
        "search.filters.pagination.modifiers.of": "of",
        "search.filters.pagination.modifiers.perPage": "results per page",
        "search.filters.pagination.modifiers.showing": "Showing",
        "search.filters.pagination.pagers.first": "First",
        "search.filters.pagination.pagers.last": "Last",
        "search.filters.pagination.pagers.next": "Next",
        "search.filters.pagination.pagers.previous": "Previous",
        "search.filters.price": "Price",
        "search.filters.price.between": "Between {{minPrice}} and {{maxPrice}}",
        "search.filters.price.from": "From {{minPrice}}",
        "search.filters.price.max": "Max",
        "search.filters.price.min": "Min",
        "search.filters.price.to": "Up to {{maxPrice}}",
        "search.none": "No items found for this search",
        "search.searchResults": "Search Results",
        "sell.back": "Go Back",
        "sell.skip": "Skip",
        "sell.edit.details.success": "Congratulations! Your item was successfully updated.",
        "sell.edit.return": "Return to My Items",
        "sell.field.category": "Category",
        "sell.field.contactEmail": "Contact Email",
        "sell.field.description": "Description",
        "sell.field.name": "Name",
        "sell.field.pictures": "Pictures",
        "sell.field.price": "Price",
        "sell.field.publish": "Publish Now",
        "sell.field.radio.no": "No",
        "sell.field.radio.yes": "Yes",
        "sell.field.status.new": "New",
        "sell.field.status.title": "Status",
        "sell.field.status.used": "Used",
        "sell.field.used": "Used",
        "sell.headline": "Sell An Item",
        "sell.image.upload.drag": "Drag your images or click to select them",
        "sell.image.upload.headline": "Upload pictures for",
        "sell.ok": "Submit and Upload Images",
        "sell.okImages": "Upload Images",
        "sell.pickCategory": "Please pick a category",
        "successMessages.buyItem.error": "Purchase was not successful",
        "successMessages.buyItem.success": "Congratulations! You have successfully purchased the item",
        "successMessages.changePassword.content": "Your credentials have been modified",
        "successMessages.changePassword.contentFail": "Your credentials have not beeen modified",
        "successMessages.changePassword.title": "Congratulations",
        "successMessages.changePassword.titleFail": "We're sorry",
        "successMessages.publishItem.action": "Publish another one",
        "successMessages.publishItem.content": "Your item has been published successfully",
        "successMessages.publishItem.content2": "Your item has been saved successfully",
        "successMessages.publishItem.title": "Congratulations",
        "successMessages.toggleFavourite.addError": "We were unable to add item to favourites",
        "successMessages.toggleFavourite.addSuccess": "Item has been added to favourites",
        "successMessages.toggleFavourite.removeError": "We were unable to remove item from favourites",
        "successMessages.toggleFavourite.removeSuccess": "Item has been removed from favourites",
        "ng.messages.logoutSuccessful": "Logout Successful",
        "ng.messages.loginSuccessful": "Login Successful",
        "ng.messages.loginError": "Incorrect username or password",
        "ng.messages.editSuccess": "Item successfully updated",
        "ng.messages.editError": "An error ocurred updating this item",
        "ng.messages.imageSuccess": "Images have uploaded successfully",
        "ng.messages.imageError": "An error ocurred uploading the images",
        "ng.messages.reviewSuccess": "Your review has been submitted",
        "ng.messages.reviewError": "An error ocurred submitting your review",
        "ng.messagess.emailSuccess": "Email was successfully updated",
        "ng.messagess.emailError": "An error ocurred updating yor email",
        "ng.messagess.passwordSuccess": "Password was successfully updated",
        "ng.messagess.passwordError": "An error ocurred updating yor password",
        "ng.messagess.itemSuccess": "Publication was successfully updated",
        "ng.messagess.itemError": "An error ocurred updating yor publication",
        "ng.messages.purchaseSuccess": "Purchase successfully approved",
        "ng.messagess.purchaseError": "There was an error approving your purchase",
        "ng.messages.purchaseSuccess2": "Purchase successfully declined",
        "ng.messagess.purchaseError2": "There was an error declining your purchase",
        "mg.messages.registerSuccess": "Register successful",
        "mg.messages.registerError": "There was an error during registration"
    };
}), function(window, angular) {
    "use strict";
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
        }
        return dst || src;
    }
    function $RouteProvider() {
        function inherit(parent, extra) {
            return angular.extend(Object.create(parent), extra);
        }
        function pathRegExp(path, opts) {
            var insensitive = opts.caseInsensitiveMatch, ret = {
                originalPath: path,
                regexp: path
            }, keys = ret.keys = [];
            return path = path.replace(/([().])/g, "\\$1").replace(/(\/)?:(\w+)(\*\?|[?*])?/g, function(_, slash, key, option) {
                var optional = "?" === option || "*?" === option ? "?" : null, star = "*" === option || "*?" === option ? "*" : null;
                return keys.push({
                    name: key,
                    optional: !!optional
                }), slash = slash || "", (optional ? "" : slash) + "(?:" + (optional ? slash : "") + (star && "(.+?)" || "([^/]+)") + (optional || "") + ")" + (optional || "");
            }).replace(/([\/$*])/g, "\\$1"), ret.regexp = new RegExp("^" + path + "$", insensitive ? "i" : ""), 
            ret;
        }
        isArray = angular.isArray, isObject = angular.isObject, isDefined = angular.isDefined, 
        noop = angular.noop;
        var routes = {};
        this.when = function(path, route) {
            var routeCopy = shallowCopy(route);
            if (angular.isUndefined(routeCopy.reloadOnSearch) && (routeCopy.reloadOnSearch = !0), 
            angular.isUndefined(routeCopy.caseInsensitiveMatch) && (routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch), 
            routes[path] = angular.extend(routeCopy, path && pathRegExp(path, routeCopy)), path) {
                var redirectPath = "/" === path[path.length - 1] ? path.substr(0, path.length - 1) : path + "/";
                routes[redirectPath] = angular.extend({
                    redirectTo: path
                }, pathRegExp(redirectPath, routeCopy));
            }
            return this;
        }, this.caseInsensitiveMatch = !1, this.otherwise = function(params) {
            return "string" == typeof params && (params = {
                redirectTo: params
            }), this.when(null, params), this;
        }, isEagerInstantiationEnabled = !0, this.eagerInstantiationEnabled = function(enabled) {
            return isDefined(enabled) ? (isEagerInstantiationEnabled = enabled, this) : isEagerInstantiationEnabled;
        }, this.$get = [ "$rootScope", "$location", "$routeParams", "$q", "$injector", "$templateRequest", "$sce", "$browser", function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce, $browser) {
            function switchRouteMatcher(on, route) {
                var keys = route.keys, params = {};
                if (!route.regexp) return null;
                var m = route.regexp.exec(on);
                if (!m) return null;
                for (var i = 1, len = m.length; i < len; ++i) {
                    var key = keys[i - 1], val = m[i];
                    key && val && (params[key.name] = val);
                }
                return params;
            }
            function prepareRoute($locationEvent) {
                var lastRoute = $route.current;
                preparedRoute = parseRoute(), (preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route && angular.equals(preparedRoute.pathParams, lastRoute.pathParams) && !preparedRoute.reloadOnSearch && !forceReload) || !lastRoute && !preparedRoute || $rootScope.$broadcast("$routeChangeStart", preparedRoute, lastRoute).defaultPrevented && $locationEvent && $locationEvent.preventDefault();
            }
            function commitRoute() {
                var lastRoute = $route.current, nextRoute = preparedRoute;
                if (preparedRouteIsUpdateOnly) lastRoute.params = nextRoute.params, angular.copy(lastRoute.params, $routeParams), 
                $rootScope.$broadcast("$routeUpdate", lastRoute); else if (nextRoute || lastRoute) {
                    forceReload = !1, $route.current = nextRoute;
                    var nextRoutePromise = $q.resolve(nextRoute);
                    $browser.$$incOutstandingRequestCount(), nextRoutePromise.then(getRedirectionData).then(handlePossibleRedirection).then(function(keepProcessingRoute) {
                        return keepProcessingRoute && nextRoutePromise.then(resolveLocals).then(function(locals) {
                            nextRoute === $route.current && (nextRoute && (nextRoute.locals = locals, angular.copy(nextRoute.params, $routeParams)), 
                            $rootScope.$broadcast("$routeChangeSuccess", nextRoute, lastRoute));
                        });
                    }).catch(function(error) {
                        nextRoute === $route.current && $rootScope.$broadcast("$routeChangeError", nextRoute, lastRoute, error);
                    }).finally(function() {
                        $browser.$$completeOutstandingRequest(noop);
                    });
                }
            }
            function getRedirectionData(route) {
                var data = {
                    route: route,
                    hasRedirection: !1
                };
                if (route) if (route.redirectTo) if (angular.isString(route.redirectTo)) data.path = interpolate(route.redirectTo, route.params), 
                data.search = route.params, data.hasRedirection = !0; else {
                    var oldPath = $location.path(), oldSearch = $location.search(), newUrl = route.redirectTo(route.pathParams, oldPath, oldSearch);
                    angular.isDefined(newUrl) && (data.url = newUrl, data.hasRedirection = !0);
                } else if (route.resolveRedirectTo) return $q.resolve($injector.invoke(route.resolveRedirectTo)).then(function(newUrl) {
                    return angular.isDefined(newUrl) && (data.url = newUrl, data.hasRedirection = !0), 
                    data;
                });
                return data;
            }
            function handlePossibleRedirection(data) {
                var keepProcessingRoute = !0;
                if (data.route !== $route.current) keepProcessingRoute = !1; else if (data.hasRedirection) {
                    var oldUrl = $location.url(), newUrl = data.url;
                    newUrl ? $location.url(newUrl).replace() : newUrl = $location.path(data.path).search(data.search).replace().url(), 
                    newUrl !== oldUrl && (keepProcessingRoute = !1);
                }
                return keepProcessingRoute;
            }
            function resolveLocals(route) {
                if (route) {
                    var locals = angular.extend({}, route.resolve);
                    angular.forEach(locals, function(value, key) {
                        locals[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value, null, null, key);
                    });
                    var template = getTemplateFor(route);
                    return angular.isDefined(template) && (locals.$template = template), $q.all(locals);
                }
            }
            function getTemplateFor(route) {
                var template, templateUrl;
                return angular.isDefined(template = route.template) ? angular.isFunction(template) && (template = template(route.params)) : angular.isDefined(templateUrl = route.templateUrl) && (angular.isFunction(templateUrl) && (templateUrl = templateUrl(route.params)), 
                angular.isDefined(templateUrl) && (route.loadedTemplateUrl = $sce.valueOf(templateUrl), 
                template = $templateRequest(templateUrl))), template;
            }
            function parseRoute() {
                var params, match;
                return angular.forEach(routes, function(route, path) {
                    !match && (params = switchRouteMatcher($location.path(), route)) && (match = inherit(route, {
                        params: angular.extend({}, $location.search(), params),
                        pathParams: params
                    }), match.$$route = route);
                }), match || routes[null] && inherit(routes[null], {
                    params: {},
                    pathParams: {}
                });
            }
            function interpolate(string, params) {
                var result = [];
                return angular.forEach((string || "").split(":"), function(segment, i) {
                    if (0 === i) result.push(segment); else {
                        var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/), key = segmentMatch[1];
                        result.push(params[key]), result.push(segmentMatch[2] || ""), delete params[key];
                    }
                }), result.join("");
            }
            var preparedRoute, preparedRouteIsUpdateOnly, forceReload = !1, $route = {
                routes: routes,
                reload: function() {
                    forceReload = !0;
                    var fakeLocationEvent = {
                        defaultPrevented: !1,
                        preventDefault: function() {
                            this.defaultPrevented = !0, forceReload = !1;
                        }
                    };
                    $rootScope.$evalAsync(function() {
                        prepareRoute(fakeLocationEvent), fakeLocationEvent.defaultPrevented || commitRoute();
                    });
                },
                updateParams: function(newParams) {
                    if (!this.current || !this.current.$$route) throw $routeMinErr("norout", "Tried updating route when with no current route");
                    newParams = angular.extend({}, this.current.params, newParams), $location.path(interpolate(this.current.$$route.originalPath, newParams)), 
                    $location.search(newParams);
                }
            };
            return $rootScope.$on("$locationChangeStart", prepareRoute), $rootScope.$on("$locationChangeSuccess", commitRoute), 
            $route;
        } ];
    }
    function instantiateRoute($injector) {
        isEagerInstantiationEnabled && $injector.get("$route");
    }
    function $RouteParamsProvider() {
        this.$get = function() {
            return {};
        };
    }
    function ngViewFactory($route, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            link: function(scope, $element, attr, ctrl, $transclude) {
                function cleanupLastView() {
                    previousLeaveAnimation && ($animate.cancel(previousLeaveAnimation), previousLeaveAnimation = null), 
                    currentScope && (currentScope.$destroy(), currentScope = null), currentElement && (previousLeaveAnimation = $animate.leave(currentElement), 
                    previousLeaveAnimation.done(function(response) {
                        !1 !== response && (previousLeaveAnimation = null);
                    }), currentElement = null);
                }
                function update() {
                    var locals = $route.current && $route.current.locals, template = locals && locals.$template;
                    if (angular.isDefined(template)) {
                        var newScope = scope.$new(), current = $route.current, clone = $transclude(newScope, function(clone) {
                            $animate.enter(clone, null, currentElement || $element).done(function(response) {
                                !1 === response || !angular.isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                            }), cleanupLastView();
                        });
                        currentElement = clone, currentScope = current.scope = newScope, currentScope.$emit("$viewContentLoaded"), 
                        currentScope.$eval(onloadExp);
                    } else cleanupLastView();
                }
                var currentScope, currentElement, previousLeaveAnimation, autoScrollExp = attr.autoscroll, onloadExp = attr.onload || "";
                scope.$on("$routeChangeSuccess", update), update();
            }
        };
    }
    function ngViewFillContentFactory($compile, $controller, $route) {
        return {
            restrict: "ECA",
            priority: -400,
            link: function(scope, $element) {
                var current = $route.current, locals = current.locals;
                $element.html(locals.$template);
                var link = $compile($element.contents());
                if (current.controller) {
                    locals.$scope = scope;
                    var controller = $controller(current.controller, locals);
                    current.controllerAs && (scope[current.controllerAs] = controller), $element.data("$ngControllerController", controller), 
                    $element.children().data("$ngControllerController", controller);
                }
                scope[current.resolveAs || "$resolve"] = locals, link(scope);
            }
        };
    }
    var isArray, isObject, isDefined, noop, isEagerInstantiationEnabled, ngRouteModule = angular.module("ngRoute", []).info({
        angularVersion: "1.6.4"
    }).provider("$route", $RouteProvider).run(instantiateRoute), $routeMinErr = angular.$$minErr("ngRoute");
    instantiateRoute.$inject = [ "$injector" ], ngRouteModule.provider("$routeParams", $RouteParamsProvider), 
    ngRouteModule.directive("ngView", ngViewFactory), ngRouteModule.directive("ngView", ngViewFillContentFactory), 
    ngViewFactory.$inject = [ "$route", "$anchorScroll", "$animate" ], ngViewFillContentFactory.$inject = [ "$compile", "$controller", "$route" ];
}(window, window.angular), define("angular-route", [ "angular" ], function() {}), 
function($) {
    "use strict";
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.modal"), options = $.extend({}, Modal.DEFAULTS, $this.data(), "object" == typeof option && option);
            data || $this.data("bs.modal", data = new Modal(this, options)), "string" == typeof option ? data[option](_relatedTarget) : options.show && data.show(_relatedTarget);
        });
    }
    var Modal = function(element, options) {
        this.options = options, this.$body = $(document.body), this.$element = $(element), 
        this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, 
        this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, 
        this.options.remote && this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
            this.$element.trigger("loaded.bs.modal");
        }, this));
    };
    Modal.VERSION = "3.3.7", Modal.TRANSITION_DURATION = 300, Modal.BACKDROP_TRANSITION_DURATION = 150, 
    Modal.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    }, Modal.prototype.show = function(_relatedTarget) {
        var that = this, e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, 
        this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), 
        this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this)), 
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                $(e.target).is(that.$element) && (that.ignoreBackdropClick = !0);
            });
        }), this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            that.$element.parent().length || that.$element.appendTo(that.$body), that.$element.show().scrollTop(0), 
            that.adjustDialog(), transition && that.$element[0].offsetWidth, that.$element.addClass("in"), 
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        }));
    }, Modal.prototype.hide = function(e) {
        e && e.preventDefault(), e = $.Event("hide.bs.modal"), this.$element.trigger(e), 
        this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), 
        $(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), 
        this.$dialog.off("mousedown.dismiss.bs.modal"), $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal());
    }, Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            document === e.target || this.$element[0] === e.target || this.$element.has(e.target).length || this.$element.trigger("focus");
        }, this));
    }, Modal.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
            27 == e.which && this.hide();
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal");
    }, Modal.prototype.resize = function() {
        this.isShown ? $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this)) : $(window).off("resize.bs.modal");
    }, Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide(), this.backdrop(function() {
            that.$body.removeClass("modal-open"), that.resetAdjustments(), that.resetScrollbar(), 
            that.$element.trigger("hidden.bs.modal");
        });
    }, Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
    }, Modal.prototype.backdrop = function(callback) {
        var that = this, animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            if (this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body), 
            this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
                return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (e.target === e.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()));
            }, this)), doAnimate && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), 
            !callback) return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop(), callback && callback();
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else callback && callback();
    }, Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
    }, Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    }, Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    }, Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth, this.scrollbarWidth = this.measureScrollbar();
    }, Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
    }, Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad);
    }, Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure", this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        return this.$body[0].removeChild(scrollDiv), scrollbarWidth;
    };
    var old = $.fn.modal;
    $.fn.modal = Plugin, $.fn.modal.Constructor = Modal, $.fn.modal.noConflict = function() {
        return $.fn.modal = old, this;
    }, $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this), href = $this.attr("href"), $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, "")), option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        $this.is("a") && e.preventDefault(), $target.one("show.bs.modal", function(showEvent) {
            showEvent.isDefaultPrevented() || $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        }), Plugin.call($target, option, this);
    });
}(jQuery), define("modal", [ "jquery" ], function() {}), "undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");

+function($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || 1 == version[0] && 9 == version[1] && version[2] < 1 || version[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4");
}(jQuery), function($) {
    "use strict";
    function transitionEnd() {
        var el = document.createElement("bootstrap"), transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) if (void 0 !== el.style[name]) return {
            end: transEndEventNames[name]
        };
        return !1;
    }
    $.fn.emulateTransitionEnd = function(duration) {
        var called = !1, $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = !0;
        });
        var callback = function() {
            called || $($el).trigger($.support.transition.end);
        };
        return setTimeout(callback, duration), this;
    }, $(function() {
        $.support.transition = transitionEnd(), $.support.transition && ($.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        });
    });
}(jQuery), function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.alert");
            data || $this.data("bs.alert", data = new Alert(this)), "string" == typeof option && data[option].call($this);
        });
    }
    var dismiss = '[data-dismiss="alert"]', Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.VERSION = "3.3.7", Alert.TRANSITION_DURATION = 150, Alert.prototype.close = function(e) {
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove();
        }
        var $this = $(this), selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = $("#" === selector ? [] : selector);
        e && e.preventDefault(), $parent.length || ($parent = $this.closest(".alert")), 
        $parent.trigger(e = $.Event("close.bs.alert")), e.isDefaultPrevented() || ($parent.removeClass("in"), 
        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement());
    };
    var old = $.fn.alert;
    $.fn.alert = Plugin, $.fn.alert.Constructor = Alert, $.fn.alert.noConflict = function() {
        return $.fn.alert = old, this;
    }, $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery), function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.button"), options = "object" == typeof option && option;
            data || $this.data("bs.button", data = new Button(this, options)), "toggle" == option ? data.toggle() : option && data.setState(option);
        });
    }
    var Button = function(element, options) {
        this.$element = $(element), this.options = $.extend({}, Button.DEFAULTS, options), 
        this.isLoading = !1;
    };
    Button.VERSION = "3.3.7", Button.DEFAULTS = {
        loadingText: "loading..."
    }, Button.prototype.setState = function(state) {
        var d = "disabled", $el = this.$element, val = $el.is("input") ? "val" : "html", data = $el.data();
        state += "Text", null == data.resetText && $el.data("resetText", $el[val]()), setTimeout($.proxy(function() {
            $el[val](null == data[state] ? this.options[state] : data[state]), "loadingText" == state ? (this.isLoading = !0, 
            $el.addClass(d).attr(d, d).prop(d, !0)) : this.isLoading && (this.isLoading = !1, 
            $el.removeClass(d).removeAttr(d).prop(d, !1));
        }, this), 0);
    }, Button.prototype.toggle = function() {
        var changed = !0, $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            "radio" == $input.prop("type") ? ($input.prop("checked") && (changed = !1), $parent.find(".active").removeClass("active"), 
            this.$element.addClass("active")) : "checkbox" == $input.prop("type") && ($input.prop("checked") !== this.$element.hasClass("active") && (changed = !1), 
            this.$element.toggleClass("active")), $input.prop("checked", this.$element.hasClass("active")), 
            changed && $input.trigger("change");
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active");
    };
    var old = $.fn.button;
    $.fn.button = Plugin, $.fn.button.Constructor = Button, $.fn.button.noConflict = function() {
        return $.fn.button = old, this;
    }, $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle"), $(e.target).is('input[type="radio"], input[type="checkbox"]') || (e.preventDefault(), 
        $btn.is("input,button") ? $btn.trigger("focus") : $btn.find("input:visible,button:visible").first().trigger("focus"));
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery), function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.carousel"), options = $.extend({}, Carousel.DEFAULTS, $this.data(), "object" == typeof option && option), action = "string" == typeof option ? option : options.slide;
            data || $this.data("bs.carousel", data = new Carousel(this, options)), "number" == typeof option ? data.to(option) : action ? data[action]() : options.interval && data.pause().cycle();
        });
    }
    var Carousel = function(element, options) {
        this.$element = $(element), this.$indicators = this.$element.find(".carousel-indicators"), 
        this.options = options, this.paused = null, this.sliding = null, this.interval = null, 
        this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this)), 
        "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
    };
    Carousel.VERSION = "3.3.7", Carousel.TRANSITION_DURATION = 600, Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, Carousel.prototype.keydown = function(e) {
        if (!/input|textarea/i.test(e.target.tagName)) {
            switch (e.which) {
              case 37:
                this.prev();
                break;

              case 39:
                this.next();
                break;

              default:
                return;
            }
            e.preventDefault();
        }
    }, Carousel.prototype.cycle = function(e) {
        return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval)), 
        this;
    }, Carousel.prototype.getItemIndex = function(item) {
        return this.$items = item.parent().children(".item"), this.$items.index(item || this.$active);
    }, Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        if (("prev" == direction && 0 === activeIndex || "next" == direction && activeIndex == this.$items.length - 1) && !this.options.wrap) return active;
        var delta = "prev" == direction ? -1 : 1, itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
    }, Carousel.prototype.to = function(pos) {
        var that = this, activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (!(pos > this.$items.length - 1 || pos < 0)) return this.sliding ? this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        }) : activeIndex == pos ? this.pause().cycle() : this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos));
    }, Carousel.prototype.pause = function(e) {
        return e || (this.paused = !0), this.$element.find(".next, .prev").length && $.support.transition && (this.$element.trigger($.support.transition.end), 
        this.cycle(!0)), this.interval = clearInterval(this.interval), this;
    }, Carousel.prototype.next = function() {
        if (!this.sliding) return this.slide("next");
    }, Carousel.prototype.prev = function() {
        if (!this.sliding) return this.slide("prev");
    }, Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active"), $next = next || this.getItemForDirection(type, $active), isCycling = this.interval, direction = "next" == type ? "left" : "right", that = this;
        if ($next.hasClass("active")) return this.sliding = !1;
        var relatedTarget = $next[0], slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if (this.$element.trigger(slideEvent), !slideEvent.isDefaultPrevented()) {
            if (this.sliding = !0, isCycling && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
                $nextIndicator && $nextIndicator.addClass("active");
            }
            var slidEvent = $.Event("slid.bs.carousel", {
                relatedTarget: relatedTarget,
                direction: direction
            });
            return $.support.transition && this.$element.hasClass("slide") ? ($next.addClass(type), 
            $next[0].offsetWidth, $active.addClass(direction), $next.addClass(direction), $active.one("bsTransitionEnd", function() {
                $next.removeClass([ type, direction ].join(" ")).addClass("active"), $active.removeClass([ "active", direction ].join(" ")), 
                that.sliding = !1, setTimeout(function() {
                    that.$element.trigger(slidEvent);
                }, 0);
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION)) : ($active.removeClass("active"), 
            $next.addClass("active"), this.sliding = !1, this.$element.trigger(slidEvent)), 
            isCycling && this.cycle(), this;
        }
    };
    var old = $.fn.carousel;
    $.fn.carousel = Plugin, $.fn.carousel.Constructor = Carousel, $.fn.carousel.noConflict = function() {
        return $.fn.carousel = old, this;
    };
    var clickHandler = function(e) {
        var href, $this = $(this), $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        if ($target.hasClass("carousel")) {
            var options = $.extend({}, $target.data(), $this.data()), slideIndex = $this.attr("data-slide-to");
            slideIndex && (options.interval = !1), Plugin.call($target, options), slideIndex && $target.data("bs.carousel").to(slideIndex), 
            e.preventDefault();
        }
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler), 
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data());
        });
    });
}(jQuery), function($) {
    "use strict";
    function getTargetFromTrigger($trigger) {
        var href, target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        return $(target);
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.collapse"), options = $.extend({}, Collapse.DEFAULTS, $this.data(), "object" == typeof option && option);
            !data && options.toggle && /show|hide/.test(option) && (options.toggle = !1), data || $this.data("bs.collapse", data = new Collapse(this, options)), 
            "string" == typeof option && data[option]();
        });
    }
    var Collapse = function(element, options) {
        this.$element = $(element), this.options = $.extend({}, Collapse.DEFAULTS, options), 
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],[data-toggle="collapse"][data-target="#' + element.id + '"]'), 
        this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), 
        this.options.toggle && this.toggle();
    };
    Collapse.VERSION = "3.3.7", Collapse.TRANSITION_DURATION = 350, Collapse.DEFAULTS = {
        toggle: !0
    }, Collapse.prototype.dimension = function() {
        return this.$element.hasClass("width") ? "width" : "height";
    }, Collapse.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var activesData, actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(actives && actives.length && (activesData = actives.data("bs.collapse")) && activesData.transitioning)) {
                var startEvent = $.Event("show.bs.collapse");
                if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                    actives && actives.length && (Plugin.call(actives, "hide"), activesData || actives.data("bs.collapse", null));
                    var dimension = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", !0), 
                    this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var complete = function() {
                        this.$element.removeClass("collapsing").addClass("collapse in")[dimension](""), 
                        this.transitioning = 0, this.$element.trigger("shown.bs.collapse");
                    };
                    if (!$.support.transition) return complete.call(this);
                    var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
                    this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
                }
            }
        }
    }, Collapse.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var startEvent = $.Event("hide.bs.collapse");
            if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                var dimension = this.dimension();
                this.$element[dimension](this.$element[dimension]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), 
                this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                var complete = function() {
                    this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
                };
                return $.support.transition ? void this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION) : complete.call(this);
            }
        }
    }, Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    }, Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    }, Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen), $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    var old = $.fn.collapse;
    $.fn.collapse = Plugin, $.fn.collapse.Constructor = Collapse, $.fn.collapse.noConflict = function() {
        return $.fn.collapse = old, this;
    }, $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        $this.attr("data-target") || e.preventDefault();
        var $target = getTargetFromTrigger($this), data = $target.data("bs.collapse"), option = data ? "toggle" : $this.data();
        Plugin.call($target, option);
    });
}(jQuery), function($) {
    "use strict";
    function getParent($this) {
        var selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"), selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    function clearMenus(e) {
        e && 3 === e.which || ($(backdrop).remove(), $(toggle).each(function() {
            var $this = $(this), $parent = getParent($this), relatedTarget = {
                relatedTarget: this
            };
            $parent.hasClass("open") && (e && "click" == e.type && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target) || ($parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget)), 
            e.isDefaultPrevented() || ($this.attr("aria-expanded", "false"), $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget)))));
        }));
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.dropdown");
            data || $this.data("bs.dropdown", data = new Dropdown(this)), "string" == typeof option && data[option].call($this);
        });
    }
    var backdrop = ".dropdown-backdrop", toggle = '[data-toggle="dropdown"]', Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.VERSION = "3.3.7", Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if (!$this.is(".disabled, :disabled")) {
            var $parent = getParent($this), isActive = $parent.hasClass("open");
            if (clearMenus(), !isActive) {
                "ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length && $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
                var relatedTarget = {
                    relatedTarget: this
                };
                if ($parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget)), e.isDefaultPrevented()) return;
                $this.trigger("focus").attr("aria-expanded", "true"), $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget));
            }
            return !1;
        }
    }, Dropdown.prototype.keydown = function(e) {
        if (/(38|40|27|32)/.test(e.which) && !/input|textarea/i.test(e.target.tagName)) {
            var $this = $(this);
            if (e.preventDefault(), e.stopPropagation(), !$this.is(".disabled, :disabled")) {
                var $parent = getParent($this), isActive = $parent.hasClass("open");
                if (!isActive && 27 != e.which || isActive && 27 == e.which) return 27 == e.which && $parent.find(toggle).trigger("focus"), 
                $this.trigger("click");
                var $items = $parent.find(".dropdown-menu li:not(.disabled):visible a");
                if ($items.length) {
                    var index = $items.index(e.target);
                    38 == e.which && index > 0 && index--, 40 == e.which && index < $items.length - 1 && index++, 
                    ~index || (index = 0), $items.eq(index).trigger("focus");
                }
            }
        }
    };
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin, $.fn.dropdown.Constructor = Dropdown, $.fn.dropdown.noConflict = function() {
        return $.fn.dropdown = old, this;
    }, $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown);
}(jQuery), function($) {
    "use strict";
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.modal"), options = $.extend({}, Modal.DEFAULTS, $this.data(), "object" == typeof option && option);
            data || $this.data("bs.modal", data = new Modal(this, options)), "string" == typeof option ? data[option](_relatedTarget) : options.show && data.show(_relatedTarget);
        });
    }
    var Modal = function(element, options) {
        this.options = options, this.$body = $(document.body), this.$element = $(element), 
        this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, 
        this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, 
        this.options.remote && this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
            this.$element.trigger("loaded.bs.modal");
        }, this));
    };
    Modal.VERSION = "3.3.7", Modal.TRANSITION_DURATION = 300, Modal.BACKDROP_TRANSITION_DURATION = 150, 
    Modal.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    }, Modal.prototype.show = function(_relatedTarget) {
        var that = this, e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, 
        this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), 
        this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this)), 
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                $(e.target).is(that.$element) && (that.ignoreBackdropClick = !0);
            });
        }), this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            that.$element.parent().length || that.$element.appendTo(that.$body), that.$element.show().scrollTop(0), 
            that.adjustDialog(), transition && that.$element[0].offsetWidth, that.$element.addClass("in"), 
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        }));
    }, Modal.prototype.hide = function(e) {
        e && e.preventDefault(), e = $.Event("hide.bs.modal"), this.$element.trigger(e), 
        this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), 
        $(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), 
        this.$dialog.off("mousedown.dismiss.bs.modal"), $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal());
    }, Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            document === e.target || this.$element[0] === e.target || this.$element.has(e.target).length || this.$element.trigger("focus");
        }, this));
    }, Modal.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
            27 == e.which && this.hide();
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal");
    }, Modal.prototype.resize = function() {
        this.isShown ? $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this)) : $(window).off("resize.bs.modal");
    }, Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide(), this.backdrop(function() {
            that.$body.removeClass("modal-open"), that.resetAdjustments(), that.resetScrollbar(), 
            that.$element.trigger("hidden.bs.modal");
        });
    }, Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
    }, Modal.prototype.backdrop = function(callback) {
        var that = this, animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            if (this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body), 
            this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
                return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (e.target === e.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()));
            }, this)), doAnimate && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), 
            !callback) return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop(), callback && callback();
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else callback && callback();
    }, Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
    }, Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    }, Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    }, Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth, this.scrollbarWidth = this.measureScrollbar();
    }, Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
    }, Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad);
    }, Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure", this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        return this.$body[0].removeChild(scrollDiv), scrollbarWidth;
    };
    var old = $.fn.modal;
    $.fn.modal = Plugin, $.fn.modal.Constructor = Modal, $.fn.modal.noConflict = function() {
        return $.fn.modal = old, this;
    }, $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this), href = $this.attr("href"), $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, "")), option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        $this.is("a") && e.preventDefault(), $target.one("show.bs.modal", function(showEvent) {
            showEvent.isDefaultPrevented() || $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        }), Plugin.call($target, option, this);
    });
}(jQuery), function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.tooltip"), options = "object" == typeof option && option;
            !data && /destroy|hide/.test(option) || (data || $this.data("bs.tooltip", data = new Tooltip(this, options)), 
            "string" == typeof option && data[option]());
        });
    }
    var Tooltip = function(element, options) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, 
        this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", element, options);
    };
    Tooltip.VERSION = "3.3.7", Tooltip.TRANSITION_DURATION = 150, Tooltip.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {
            selector: "body",
            padding: 0
        }
    }, Tooltip.prototype.init = function(type, element, options) {
        if (this.enabled = !0, this.type = type, this.$element = $(element), this.options = this.getOptions(options), 
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), 
        this.inState = {
            click: !1,
            hover: !1,
            focus: !1
        }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var triggers = this.options.trigger.split(" "), i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if ("click" == trigger) this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this)); else if ("manual" != trigger) {
                var eventIn = "hover" == trigger ? "mouseenter" : "focusin", eventOut = "hover" == trigger ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this)), 
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    }, Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    }, Tooltip.prototype.getOptions = function(options) {
        return options = $.extend({}, this.getDefaults(), this.$element.data(), options), 
        options.delay && "number" == typeof options.delay && (options.delay = {
            show: options.delay,
            hide: options.delay
        }), options;
    }, Tooltip.prototype.getDelegateOptions = function() {
        var options = {}, defaults = this.getDefaults();
        return this._options && $.each(this._options, function(key, value) {
            defaults[key] != value && (options[key] = value);
        }), options;
    }, Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        return self || (self = new this.constructor(obj.currentTarget, this.getDelegateOptions()), 
        $(obj.currentTarget).data("bs." + this.type, self)), obj instanceof $.Event && (self.inState["focusin" == obj.type ? "focus" : "hover"] = !0), 
        self.tip().hasClass("in") || "in" == self.hoverState ? void (self.hoverState = "in") : (clearTimeout(self.timeout), 
        self.hoverState = "in", self.options.delay && self.options.delay.show ? void (self.timeout = setTimeout(function() {
            "in" == self.hoverState && self.show();
        }, self.options.delay.show)) : self.show());
    }, Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) if (this.inState[key]) return !0;
        return !1;
    }, Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (self || (self = new this.constructor(obj.currentTarget, this.getDelegateOptions()), 
        $(obj.currentTarget).data("bs." + this.type, self)), obj instanceof $.Event && (self.inState["focusout" == obj.type ? "focus" : "hover"] = !1), 
        !self.isInStateTrue()) return clearTimeout(self.timeout), self.hoverState = "out", 
        self.options.delay && self.options.delay.hide ? void (self.timeout = setTimeout(function() {
            "out" == self.hoverState && self.hide();
        }, self.options.delay.hide)) : self.hide();
    }, Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom) return;
            var that = this, $tip = this.tip(), tipId = this.getUID(this.type);
            this.setContent(), $tip.attr("id", tipId), this.$element.attr("aria-describedby", tipId), 
            this.options.animation && $tip.addClass("fade");
            var placement = "function" == typeof this.options.placement ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement, autoToken = /\s?auto?\s?/i, autoPlace = autoToken.test(placement);
            autoPlace && (placement = placement.replace(autoToken, "") || "top"), $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this), this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element), 
            this.$element.trigger("inserted.bs." + this.type);
            var pos = this.getPosition(), actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement, viewportDim = this.getPosition(this.$viewport);
                placement = "bottom" == placement && pos.bottom + actualHeight > viewportDim.bottom ? "top" : "top" == placement && pos.top - actualHeight < viewportDim.top ? "bottom" : "right" == placement && pos.right + actualWidth > viewportDim.width ? "left" : "left" == placement && pos.left - actualWidth < viewportDim.left ? "right" : placement, 
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type), that.hoverState = null, "out" == prevHoverState && that.leave(that);
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
    }, Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip(), width = $tip[0].offsetWidth, height = $tip[0].offsetHeight, marginTop = parseInt($tip.css("margin-top"), 10), marginLeft = parseInt($tip.css("margin-left"), 10);
        isNaN(marginTop) && (marginTop = 0), isNaN(marginLeft) && (marginLeft = 0), offset.top += marginTop, 
        offset.left += marginLeft, $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0), $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
        "top" == placement && actualHeight != height && (offset.top = offset.top + height - actualHeight);
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        delta.left ? offset.left += delta.left : offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement), arrowDelta = isVertical ? 2 * delta.left - width + actualWidth : 2 * delta.top - height + actualHeight, arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset), this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    }, Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "");
    }, Tooltip.prototype.setContent = function() {
        var $tip = this.tip(), title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title), $tip.removeClass("fade in top bottom left right");
    }, Tooltip.prototype.hide = function(callback) {
        function complete() {
            "in" != that.hoverState && $tip.detach(), that.$element && that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type), 
            callback && callback();
        }
        var that = this, $tip = $(this.$tip), e = $.Event("hide.bs." + this.type);
        if (this.$element.trigger(e), !e.isDefaultPrevented()) return $tip.removeClass("in"), 
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete(), 
        this.hoverState = null, this;
    }, Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        ($e.attr("title") || "string" != typeof $e.attr("data-original-title")) && $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
    }, Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    }, Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0], isBody = "BODY" == el.tagName, elRect = el.getBoundingClientRect();
        null == elRect.width && (elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
        }));
        var isSvg = window.SVGElement && el instanceof window.SVGElement, elOffset = isBody ? {
            top: 0,
            left: 0
        } : isSvg ? null : $element.offset(), scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        }, outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    }, Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return "bottom" == placement ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "top" == placement ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "left" == placement ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    }, Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0, viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll, bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            topEdgeOffset < viewportDimensions.top ? delta.top = viewportDimensions.top - topEdgeOffset : bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height && (delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset);
        } else {
            var leftEdgeOffset = pos.left - viewportPadding, rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            leftEdgeOffset < viewportDimensions.left ? delta.left = viewportDimensions.left - leftEdgeOffset : rightEdgeOffset > viewportDimensions.right && (delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset);
        }
        return delta;
    }, Tooltip.prototype.getTitle = function() {
        var $e = this.$element, o = this.options;
        return $e.attr("data-original-title") || ("function" == typeof o.title ? o.title.call($e[0]) : o.title);
    }, Tooltip.prototype.getUID = function(prefix) {
        do {
            prefix += ~~(1e6 * Math.random());
        } while (document.getElementById(prefix));
        return prefix;
    }, Tooltip.prototype.tip = function() {
        if (!this.$tip && (this.$tip = $(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip;
    }, Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    }, Tooltip.prototype.enable = function() {
        this.enabled = !0;
    }, Tooltip.prototype.disable = function() {
        this.enabled = !1;
    }, Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    }, Tooltip.prototype.toggle = function(e) {
        var self = this;
        e && ((self = $(e.currentTarget).data("bs." + this.type)) || (self = new this.constructor(e.currentTarget, this.getDelegateOptions()), 
        $(e.currentTarget).data("bs." + this.type, self))), e ? (self.inState.click = !self.inState.click, 
        self.isInStateTrue() ? self.enter(self) : self.leave(self)) : self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
    }, Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout), this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type), that.$tip && that.$tip.detach(), 
            that.$tip = null, that.$arrow = null, that.$viewport = null, that.$element = null;
        });
    };
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin, $.fn.tooltip.Constructor = Tooltip, $.fn.tooltip.noConflict = function() {
        return $.fn.tooltip = old, this;
    };
}(jQuery), function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.popover"), options = "object" == typeof option && option;
            !data && /destroy|hide/.test(option) || (data || $this.data("bs.popover", data = new Popover(this, options)), 
            "string" == typeof option && data[option]());
        });
    }
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.7", Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype), Popover.prototype.constructor = Popover, 
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    }, Popover.prototype.setContent = function() {
        var $tip = this.tip(), title = this.getTitle(), content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title), $tip.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof content ? "html" : "append" : "text"](content), 
        $tip.removeClass("fade top bottom left right in"), $tip.find(".popover-title").html() || $tip.find(".popover-title").hide();
    }, Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    }, Popover.prototype.getContent = function() {
        var $e = this.$element, o = this.options;
        return $e.attr("data-content") || ("function" == typeof o.content ? o.content.call($e[0]) : o.content);
    }, Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    var old = $.fn.popover;
    $.fn.popover = Plugin, $.fn.popover.Constructor = Popover, $.fn.popover.noConflict = function() {
        return $.fn.popover = old, this;
    };
}(jQuery), function($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body), this.$scrollElement = $($(element).is(document.body) ? window : element), 
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options), this.selector = (this.options.target || "") + " .nav li > a", 
        this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, 
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this)), this.refresh(), 
        this.process();
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.scrollspy"), options = "object" == typeof option && option;
            data || $this.data("bs.scrollspy", data = new ScrollSpy(this, options)), "string" == typeof option && data[option]();
        });
    }
    ScrollSpy.VERSION = "3.3.7", ScrollSpy.DEFAULTS = {
        offset: 10
    }, ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
    }, ScrollSpy.prototype.refresh = function() {
        var that = this, offsetMethod = "offset", offsetBase = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), 
        $.isWindow(this.$scrollElement[0]) || (offsetMethod = "position", offsetBase = this.$scrollElement.scrollTop()), 
        this.$body.find(this.selector).map(function() {
            var $el = $(this), href = $el.data("target") || $el.attr("href"), $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [ [ $href[offsetMethod]().top + offsetBase, href ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            that.offsets.push(this[0]), that.targets.push(this[1]);
        });
    }, ScrollSpy.prototype.process = function() {
        var i, scrollTop = this.$scrollElement.scrollTop() + this.options.offset, scrollHeight = this.getScrollHeight(), maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height(), offsets = this.offsets, targets = this.targets, activeTarget = this.activeTarget;
        if (this.scrollHeight != scrollHeight && this.refresh(), scrollTop >= maxScroll) return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        if (activeTarget && scrollTop < offsets[0]) return this.activeTarget = null, this.clear();
        for (i = offsets.length; i--; ) activeTarget != targets[i] && scrollTop >= offsets[i] && (void 0 === offsets[i + 1] || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
    }, ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target, this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]', active = $(selector).parents("li").addClass("active");
        active.parent(".dropdown-menu").length && (active = active.closest("li.dropdown").addClass("active")), 
        active.trigger("activate.bs.scrollspy");
    }, ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
    };
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin, $.fn.scrollspy.Constructor = ScrollSpy, $.fn.scrollspy.noConflict = function() {
        return $.fn.scrollspy = old, this;
    }, $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data());
        });
    });
}(jQuery), function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.tab");
            data || $this.data("bs.tab", data = new Tab(this)), "string" == typeof option && data[option]();
        });
    }
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.7", Tab.TRANSITION_DURATION = 150, Tab.prototype.show = function() {
        var $this = this.element, $ul = $this.closest("ul:not(.dropdown-menu)"), selector = $this.data("target");
        if (selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")), 
        !$this.parent("li").hasClass("active")) {
            var $previous = $ul.find(".active:last a"), hideEvent = $.Event("hide.bs.tab", {
                relatedTarget: $this[0]
            }), showEvent = $.Event("show.bs.tab", {
                relatedTarget: $previous[0]
            });
            if ($previous.trigger(hideEvent), $this.trigger(showEvent), !showEvent.isDefaultPrevented() && !hideEvent.isDefaultPrevented()) {
                var $target = $(selector);
                this.activate($this.closest("li"), $ul), this.activate($target, $target.parent(), function() {
                    $previous.trigger({
                        type: "hidden.bs.tab",
                        relatedTarget: $this[0]
                    }), $this.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: $previous[0]
                    });
                });
            }
        }
    }, Tab.prototype.activate = function(element, container, callback) {
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), 
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), 
            transition ? (element[0].offsetWidth, element.addClass("in")) : element.removeClass("fade"), 
            element.parent(".dropdown-menu").length && element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), 
            callback && callback();
        }
        var $active = container.find("> .active"), transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next(), 
        $active.removeClass("in");
    };
    var old = $.fn.tab;
    $.fn.tab = Plugin, $.fn.tab.Constructor = Tab, $.fn.tab.noConflict = function() {
        return $.fn.tab = old, this;
    };
    var clickHandler = function(e) {
        e.preventDefault(), Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery), function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.affix"), options = "object" == typeof option && option;
            data || $this.data("bs.affix", data = new Affix(this, options)), "string" == typeof option && data[option]();
        });
    }
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options), this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this)), 
        this.$element = $(element), this.affixed = null, this.unpin = null, this.pinnedOffset = null, 
        this.checkPosition();
    };
    Affix.VERSION = "3.3.7", Affix.RESET = "affix affix-top affix-bottom", Affix.DEFAULTS = {
        offset: 0,
        target: window
    }, Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop(), position = this.$element.offset(), targetHeight = this.$target.height();
        if (null != offsetTop && "top" == this.affixed) return scrollTop < offsetTop && "top";
        if ("bottom" == this.affixed) return null != offsetTop ? !(scrollTop + this.unpin <= position.top) && "bottom" : !(scrollTop + targetHeight <= scrollHeight - offsetBottom) && "bottom";
        var initializing = null == this.affixed, colliderTop = initializing ? scrollTop : position.top, colliderHeight = initializing ? targetHeight : height;
        return null != offsetTop && scrollTop <= offsetTop ? "top" : null != offsetBottom && colliderTop + colliderHeight >= scrollHeight - offsetBottom && "bottom";
    }, Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop(), position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    }, Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    }, Affix.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var height = this.$element.height(), offset = this.options.offset, offsetTop = offset.top, offsetBottom = offset.bottom, scrollHeight = Math.max($(document).height(), $(document.body).height());
            "object" != typeof offset && (offsetBottom = offsetTop = offset), "function" == typeof offsetTop && (offsetTop = offset.top(this.$element)), 
            "function" == typeof offsetBottom && (offsetBottom = offset.bottom(this.$element));
            var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
            if (this.affixed != affix) {
                null != this.unpin && this.$element.css("top", "");
                var affixType = "affix" + (affix ? "-" + affix : ""), e = $.Event(affixType + ".bs.affix");
                if (this.$element.trigger(e), e.isDefaultPrevented()) return;
                this.affixed = affix, this.unpin = "bottom" == affix ? this.getPinnedOffset() : null, 
                this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
            }
            "bottom" == affix && this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    var old = $.fn.affix;
    $.fn.affix = Plugin, $.fn.affix.Constructor = Affix, $.fn.affix.noConflict = function() {
        return $.fn.affix = old, this;
    }, $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this), data = $spy.data();
            data.offset = data.offset || {}, null != data.offsetBottom && (data.offset.bottom = data.offsetBottom), 
            null != data.offsetTop && (data.offset.top = data.offsetTop), Plugin.call($spy, data);
        });
    });
}(jQuery), define("bootstrap", [ "jquery", "modal" ], function() {}), function(root, factory) {
    "function" == typeof define && define.amd ? define("angular-translate", [], function() {
        return factory();
    }) : "object" == typeof exports ? module.exports = factory() : factory();
}(0, function() {
    function runTranslate($translate) {
        "use strict";
        var key = $translate.storageKey(), storage = $translate.storage(), fallbackFromIncorrectStorageValue = function() {
            var preferred = $translate.preferredLanguage();
            angular.isString(preferred) ? $translate.use(preferred) : storage.put(key, $translate.use());
        };
        fallbackFromIncorrectStorageValue.displayName = "fallbackFromIncorrectStorageValue", 
        storage ? storage.get(key) ? $translate.use(storage.get(key)).catch(fallbackFromIncorrectStorageValue) : fallbackFromIncorrectStorageValue() : angular.isString($translate.preferredLanguage()) && $translate.use($translate.preferredLanguage());
    }
    function $translateSanitizationProvider() {
        "use strict";
        var $sanitize, $sce, strategies, currentStrategy = null, hasConfiguredStrategy = !1, hasShownNoStrategyConfiguredWarning = !1;
        strategies = {
            sanitize: function(value, mode) {
                return "text" === mode && (value = htmlSanitizeValue(value)), value;
            },
            escape: function(value, mode) {
                return "text" === mode && (value = htmlEscapeValue(value)), value;
            },
            sanitizeParameters: function(value, mode) {
                return "params" === mode && (value = mapInterpolationParameters(value, htmlSanitizeValue)), 
                value;
            },
            escapeParameters: function(value, mode) {
                return "params" === mode && (value = mapInterpolationParameters(value, htmlEscapeValue)), 
                value;
            },
            sce: function(value, mode, context) {
                return "text" === mode ? value = htmlTrustValue(value) : "params" === mode && "filter" !== context && (value = mapInterpolationParameters(value, htmlEscapeValue)), 
                value;
            },
            sceParameters: function(value, mode) {
                return "params" === mode && (value = mapInterpolationParameters(value, htmlTrustValue)), 
                value;
            }
        }, strategies.escaped = strategies.escapeParameters, this.addStrategy = function(strategyName, strategyFunction) {
            return strategies[strategyName] = strategyFunction, this;
        }, this.removeStrategy = function(strategyName) {
            return delete strategies[strategyName], this;
        }, this.useStrategy = function(strategy) {
            return hasConfiguredStrategy = !0, currentStrategy = strategy, this;
        }, this.$get = [ "$injector", "$log", function($injector, $log) {
            var cachedStrategyMap = {}, applyStrategies = function(value, mode, context, selectedStrategies) {
                return angular.forEach(selectedStrategies, function(selectedStrategy) {
                    if (angular.isFunction(selectedStrategy)) value = selectedStrategy(value, mode, context); else if (angular.isFunction(strategies[selectedStrategy])) value = strategies[selectedStrategy](value, mode, context); else {
                        if (!angular.isString(strategies[selectedStrategy])) throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                        if (!cachedStrategyMap[strategies[selectedStrategy]]) try {
                            cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);
                        } catch (e) {
                            throw cachedStrategyMap[strategies[selectedStrategy]] = function() {}, new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                        }
                        value = cachedStrategyMap[strategies[selectedStrategy]](value, mode, context);
                    }
                }), value;
            }, showNoStrategyConfiguredWarning = function() {
                hasConfiguredStrategy || hasShownNoStrategyConfiguredWarning || ($log.warn("pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details."), 
                hasShownNoStrategyConfiguredWarning = !0);
            };
            return $injector.has("$sanitize") && ($sanitize = $injector.get("$sanitize")), $injector.has("$sce") && ($sce = $injector.get("$sce")), 
            {
                useStrategy: function(self) {
                    return function(strategy) {
                        self.useStrategy(strategy);
                    };
                }(this),
                sanitize: function(value, mode, strategy, context) {
                    if (currentStrategy || showNoStrategyConfiguredWarning(), strategy || null === strategy || (strategy = currentStrategy), 
                    !strategy) return value;
                    context || (context = "service");
                    var selectedStrategies = angular.isArray(strategy) ? strategy : [ strategy ];
                    return applyStrategies(value, mode, context, selectedStrategies);
                }
            };
        } ];
        var htmlEscapeValue = function(value) {
            var element = angular.element("<div></div>");
            return element.text(value), element.html();
        }, htmlSanitizeValue = function(value) {
            if (!$sanitize) throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as 'escape'.");
            return $sanitize(value);
        }, htmlTrustValue = function(value) {
            if (!$sce) throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sce service.");
            return $sce.trustAsHtml(value);
        }, mapInterpolationParameters = function(value, iteratee, stack) {
            if (angular.isDate(value)) return value;
            if (angular.isObject(value)) {
                var result = angular.isArray(value) ? [] : {};
                if (stack) {
                    if (stack.indexOf(value) > -1) throw new Error("pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object");
                } else stack = [];
                return stack.push(value), angular.forEach(value, function(propertyValue, propertyKey) {
                    angular.isFunction(propertyValue) || (result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack));
                }), stack.splice(-1, 1), result;
            }
            return angular.isNumber(value) ? value : angular.isUndefined(value) || null === value ? value : iteratee(value);
        };
    }
    function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {
        "use strict";
        var $preferredLanguage, $languageKeyAliases, $fallbackLanguage, $fallbackWasString, $uses, $nextLang, $storageFactory, $storagePrefix, $missingTranslationHandlerFactory, $interpolationFactory, $loaderFactory, $loaderOptions, $notFoundIndicatorLeft, $notFoundIndicatorRight, loaderCache, postProcessFn, $translationTable = {}, $availableLanguageKeys = [], $storageKey = $STORAGE_KEY, $interpolatorFactories = [], $cloakClassName = "translate-cloak", $postCompilingEnabled = !1, $forceAsyncReloadEnabled = !1, $nestedObjectDelimeter = ".", $isReady = !1, $keepContent = !1, directivePriority = 0, statefulFilter = !0, uniformLanguageTagResolver = "default", languageTagResolver = {
            default: function(tag) {
                return (tag || "").split("-").join("_");
            },
            java: function(tag) {
                var temp = (tag || "").split("-").join("_"), parts = temp.split("_");
                return parts.length > 1 ? parts[0].toLowerCase() + "_" + parts[1].toUpperCase() : temp;
            },
            bcp47: function(tag) {
                var temp = (tag || "").split("_").join("-"), parts = temp.split("-");
                return parts.length > 1 ? parts[0].toLowerCase() + "-" + parts[1].toUpperCase() : temp;
            },
            "iso639-1": function(tag) {
                return (tag || "").split("_").join("-").split("-")[0].toLowerCase();
            }
        }, getFirstBrowserLanguage = function() {
            if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) return pascalprechtTranslateOverrider.getLocale();
            var i, language, nav = $windowProvider.$get().navigator, browserLanguagePropertyKeys = [ "language", "browserLanguage", "systemLanguage", "userLanguage" ];
            if (angular.isArray(nav.languages)) for (i = 0; i < nav.languages.length; i++) if ((language = nav.languages[i]) && language.length) return language;
            for (i = 0; i < browserLanguagePropertyKeys.length; i++) if ((language = nav[browserLanguagePropertyKeys[i]]) && language.length) return language;
            return null;
        };
        getFirstBrowserLanguage.displayName = "angular-translate/service: getFirstBrowserLanguage";
        var getLocale = function() {
            var locale = getFirstBrowserLanguage() || "";
            return languageTagResolver[uniformLanguageTagResolver] && (locale = languageTagResolver[uniformLanguageTagResolver](locale)), 
            locale;
        };
        getLocale.displayName = "angular-translate/service: getLocale";
        var indexOf = function(array, searchElement) {
            for (var i = 0, len = array.length; i < len; i++) if (array[i] === searchElement) return i;
            return -1;
        }, trim = function() {
            return this.toString().replace(/^\s+|\s+$/g, "");
        }, negotiateLocale = function(preferred) {
            if (preferred) {
                for (var avail = [], locale = angular.lowercase(preferred), i = 0, n = $availableLanguageKeys.length; i < n; i++) avail.push(angular.lowercase($availableLanguageKeys[i]));
                if (indexOf(avail, locale) > -1) return preferred;
                if ($languageKeyAliases) {
                    var alias;
                    for (var langKeyAlias in $languageKeyAliases) if ($languageKeyAliases.hasOwnProperty(langKeyAlias)) {
                        var hasWildcardKey = !1, hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) && angular.lowercase(langKeyAlias) === angular.lowercase(preferred);
                        if ("*" === langKeyAlias.slice(-1) && (hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length - 1)), 
                        (hasExactKey || hasWildcardKey) && (alias = $languageKeyAliases[langKeyAlias], indexOf(avail, angular.lowercase(alias)) > -1)) return alias;
                    }
                }
                var parts = preferred.split("_");
                return parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1 ? parts[0] : void 0;
            }
        }, translations = function(langKey, translationTable) {
            if (!langKey && !translationTable) return $translationTable;
            if (langKey && !translationTable) {
                if (angular.isString(langKey)) return $translationTable[langKey];
            } else angular.isObject($translationTable[langKey]) || ($translationTable[langKey] = {}), 
            angular.extend($translationTable[langKey], flatObject(translationTable));
            return this;
        };
        this.translations = translations, this.cloakClassName = function(name) {
            return name ? ($cloakClassName = name, this) : $cloakClassName;
        }, this.nestedObjectDelimeter = function(delimiter) {
            return delimiter ? ($nestedObjectDelimeter = delimiter, this) : $nestedObjectDelimeter;
        };
        var flatObject = function(data, path, result, prevKey) {
            var key, keyWithPath, keyWithShortPath, val;
            path || (path = []), result || (result = {});
            for (key in data) Object.prototype.hasOwnProperty.call(data, key) && (val = data[key], 
            angular.isObject(val) ? flatObject(val, path.concat(key), result, key) : (keyWithPath = path.length ? "" + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key : key, 
            path.length && key === prevKey && (keyWithShortPath = "" + path.join($nestedObjectDelimeter), 
            result[keyWithShortPath] = "@:" + keyWithPath), result[keyWithPath] = val));
            return result;
        };
        flatObject.displayName = "flatObject", this.addInterpolation = function(factory) {
            return $interpolatorFactories.push(factory), this;
        }, this.useMessageFormatInterpolation = function() {
            return this.useInterpolation("$translateMessageFormatInterpolation");
        }, this.useInterpolation = function(factory) {
            return $interpolationFactory = factory, this;
        }, this.useSanitizeValueStrategy = function(value) {
            return $translateSanitizationProvider.useStrategy(value), this;
        }, this.preferredLanguage = function(langKey) {
            return langKey ? (setupPreferredLanguage(langKey), this) : $preferredLanguage;
        };
        var setupPreferredLanguage = function(langKey) {
            return langKey && ($preferredLanguage = langKey), $preferredLanguage;
        };
        this.translationNotFoundIndicator = function(indicator) {
            return this.translationNotFoundIndicatorLeft(indicator), this.translationNotFoundIndicatorRight(indicator), 
            this;
        }, this.translationNotFoundIndicatorLeft = function(indicator) {
            return indicator ? ($notFoundIndicatorLeft = indicator, this) : $notFoundIndicatorLeft;
        }, this.translationNotFoundIndicatorRight = function(indicator) {
            return indicator ? ($notFoundIndicatorRight = indicator, this) : $notFoundIndicatorRight;
        }, this.fallbackLanguage = function(langKey) {
            return fallbackStack(langKey), this;
        };
        var fallbackStack = function(langKey) {
            return langKey ? (angular.isString(langKey) ? ($fallbackWasString = !0, $fallbackLanguage = [ langKey ]) : angular.isArray(langKey) && ($fallbackWasString = !1, 
            $fallbackLanguage = langKey), angular.isString($preferredLanguage) && indexOf($fallbackLanguage, $preferredLanguage) < 0 && $fallbackLanguage.push($preferredLanguage), 
            this) : $fallbackWasString ? $fallbackLanguage[0] : $fallbackLanguage;
        };
        this.use = function(langKey) {
            if (langKey) {
                if (!$translationTable[langKey] && !$loaderFactory) throw new Error("$translateProvider couldn't find translationTable for langKey: '" + langKey + "'");
                return $uses = langKey, this;
            }
            return $uses;
        }, this.resolveClientLocale = function() {
            return getLocale();
        };
        var storageKey = function(key) {
            return key ? ($storageKey = key, this) : $storagePrefix ? $storagePrefix + $storageKey : $storageKey;
        };
        this.storageKey = storageKey, this.useUrlLoader = function(url, options) {
            return this.useLoader("$translateUrlLoader", angular.extend({
                url: url
            }, options));
        }, this.useStaticFilesLoader = function(options) {
            return this.useLoader("$translateStaticFilesLoader", options);
        }, this.useLoader = function(loaderFactory, options) {
            return $loaderFactory = loaderFactory, $loaderOptions = options || {}, this;
        }, this.useLocalStorage = function() {
            return this.useStorage("$translateLocalStorage");
        }, this.useCookieStorage = function() {
            return this.useStorage("$translateCookieStorage");
        }, this.useStorage = function(storageFactory) {
            return $storageFactory = storageFactory, this;
        }, this.storagePrefix = function(prefix) {
            return prefix ? ($storagePrefix = prefix, this) : prefix;
        }, this.useMissingTranslationHandlerLog = function() {
            return this.useMissingTranslationHandler("$translateMissingTranslationHandlerLog");
        }, this.useMissingTranslationHandler = function(factory) {
            return $missingTranslationHandlerFactory = factory, this;
        }, this.usePostCompiling = function(value) {
            return $postCompilingEnabled = !!value, this;
        }, this.forceAsyncReload = function(value) {
            return $forceAsyncReloadEnabled = !!value, this;
        }, this.uniformLanguageTag = function(options) {
            return options ? angular.isString(options) && (options = {
                standard: options
            }) : options = {}, uniformLanguageTagResolver = options.standard, this;
        }, this.determinePreferredLanguage = function(fn) {
            var locale = fn && angular.isFunction(fn) ? fn() : getLocale();
            return $preferredLanguage = $availableLanguageKeys.length ? negotiateLocale(locale) || locale : locale, 
            this;
        }, this.registerAvailableLanguageKeys = function(languageKeys, aliases) {
            return languageKeys ? ($availableLanguageKeys = languageKeys, aliases && ($languageKeyAliases = aliases), 
            this) : $availableLanguageKeys;
        }, this.useLoaderCache = function(cache) {
            return !1 === cache ? loaderCache = void 0 : !0 === cache ? loaderCache = !0 : void 0 === cache ? loaderCache = "$translationCache" : cache && (loaderCache = cache), 
            this;
        }, this.directivePriority = function(priority) {
            return void 0 === priority ? directivePriority : (directivePriority = priority, 
            this);
        }, this.statefulFilter = function(state) {
            return void 0 === state ? statefulFilter : (statefulFilter = state, this);
        }, this.postProcess = function(fn) {
            return postProcessFn = fn || void 0, this;
        }, this.keepContent = function(value) {
            return $keepContent = !!value, this;
        }, this.$get = [ "$log", "$injector", "$rootScope", "$q", function($log, $injector, $rootScope, $q) {
            var Storage, fallbackIndex, startFallbackIteration, defaultInterpolator = $injector.get($interpolationFactory || "$translateDefaultInterpolation"), pendingLoader = !1, interpolatorHashMap = {}, langPromises = {}, $translate = function(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {
                !$uses && $preferredLanguage && ($uses = $preferredLanguage);
                var uses = forceLanguage && forceLanguage !== $uses ? negotiateLocale(forceLanguage) || forceLanguage : $uses;
                if (forceLanguage && loadTranslationsIfMissing(forceLanguage), angular.isArray(translationId)) {
                    return function(translationIds) {
                        for (var results = {}, promises = [], i = 0, c = translationIds.length; i < c; i++) promises.push(function(translationId) {
                            var deferred = $q.defer(), regardless = function(value) {
                                results[translationId] = value, deferred.resolve([ translationId, value ]);
                            };
                            return $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless), 
                            deferred.promise;
                        }(translationIds[i]));
                        return $q.all(promises).then(function() {
                            return results;
                        });
                    }(translationId);
                }
                var deferred = $q.defer();
                translationId && (translationId = trim.apply(translationId));
                var promiseToWaitFor = function() {
                    var promise = $preferredLanguage ? langPromises[$preferredLanguage] : langPromises[uses];
                    if (fallbackIndex = 0, $storageFactory && !promise) {
                        var langKey = Storage.get($storageKey);
                        if (promise = langPromises[langKey], $fallbackLanguage && $fallbackLanguage.length) {
                            var index = indexOf($fallbackLanguage, langKey);
                            fallbackIndex = 0 === index ? 1 : 0, indexOf($fallbackLanguage, $preferredLanguage) < 0 && $fallbackLanguage.push($preferredLanguage);
                        }
                    }
                    return promise;
                }();
                if (promiseToWaitFor) {
                    var promiseResolved = function() {
                        forceLanguage || (uses = $uses), determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);
                    };
                    promiseResolved.displayName = "promiseResolved", promiseToWaitFor.finally(promiseResolved).catch(angular.noop);
                } else determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);
                return deferred.promise;
            }, applyNotFoundIndicators = function(translationId) {
                return $notFoundIndicatorLeft && (translationId = [ $notFoundIndicatorLeft, translationId ].join(" ")), 
                $notFoundIndicatorRight && (translationId = [ translationId, $notFoundIndicatorRight ].join(" ")), 
                translationId;
            }, useLanguage = function(key) {
                $uses = key, $storageFactory && Storage.put($translate.storageKey(), $uses), $rootScope.$emit("$translateChangeSuccess", {
                    language: key
                }), defaultInterpolator.setLocale($uses);
                var eachInterpolator = function(interpolator, id) {
                    interpolatorHashMap[id].setLocale($uses);
                };
                eachInterpolator.displayName = "eachInterpolatorLocaleSetter", angular.forEach(interpolatorHashMap, eachInterpolator), 
                $rootScope.$emit("$translateChangeEnd", {
                    language: key
                });
            }, loadAsync = function(key) {
                if (!key) throw "No language key specified for loading.";
                var deferred = $q.defer();
                $rootScope.$emit("$translateLoadingStart", {
                    language: key
                }), pendingLoader = !0;
                var cache = loaderCache;
                "string" == typeof cache && (cache = $injector.get(cache));
                var loaderOptions = angular.extend({}, $loaderOptions, {
                    key: key,
                    $http: angular.extend({}, {
                        cache: cache
                    }, $loaderOptions.$http)
                }), onLoaderSuccess = function(data) {
                    var translationTable = {};
                    $rootScope.$emit("$translateLoadingSuccess", {
                        language: key
                    }), angular.isArray(data) ? angular.forEach(data, function(table) {
                        angular.extend(translationTable, flatObject(table));
                    }) : angular.extend(translationTable, flatObject(data)), pendingLoader = !1, deferred.resolve({
                        key: key,
                        table: translationTable
                    }), $rootScope.$emit("$translateLoadingEnd", {
                        language: key
                    });
                };
                onLoaderSuccess.displayName = "onLoaderSuccess";
                var onLoaderError = function(key) {
                    $rootScope.$emit("$translateLoadingError", {
                        language: key
                    }), deferred.reject(key), $rootScope.$emit("$translateLoadingEnd", {
                        language: key
                    });
                };
                return onLoaderError.displayName = "onLoaderError", $injector.get($loaderFactory)(loaderOptions).then(onLoaderSuccess, onLoaderError), 
                deferred.promise;
            };
            if ($storageFactory && (Storage = $injector.get($storageFactory), !Storage.get || !Storage.put)) throw new Error("Couldn't use storage '" + $storageFactory + "', missing get() or put() method!");
            if ($interpolatorFactories.length) {
                var eachInterpolationFactory = function(interpolatorFactory) {
                    var interpolator = $injector.get(interpolatorFactory);
                    interpolator.setLocale($preferredLanguage || $uses), interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
                };
                eachInterpolationFactory.displayName = "interpolationFactoryAdder", angular.forEach($interpolatorFactories, eachInterpolationFactory);
            }
            var getTranslationTable = function(langKey) {
                var deferred = $q.defer();
                if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) deferred.resolve($translationTable[langKey]); else if (langPromises[langKey]) {
                    var onResolve = function(data) {
                        translations(data.key, data.table), deferred.resolve(data.table);
                    };
                    onResolve.displayName = "translationTableResolver", langPromises[langKey].then(onResolve, deferred.reject);
                } else deferred.reject();
                return deferred.promise;
            }, getFallbackTranslation = function(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                var deferred = $q.defer(), onResolve = function(translationTable) {
                    if (Object.prototype.hasOwnProperty.call(translationTable, translationId) && null !== translationTable[translationId]) {
                        Interpolator.setLocale(langKey);
                        var translation = translationTable[translationId];
                        if ("@:" === translation.substr(0, 2)) getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator, sanitizeStrategy).then(deferred.resolve, deferred.reject); else {
                            var interpolatedValue = Interpolator.interpolate(translationTable[translationId], interpolateParams, "service", sanitizeStrategy, translationId);
                            interpolatedValue = applyPostProcessing(translationId, translationTable[translationId], interpolatedValue, interpolateParams, langKey), 
                            deferred.resolve(interpolatedValue);
                        }
                        Interpolator.setLocale($uses);
                    } else deferred.reject();
                };
                return onResolve.displayName = "fallbackTranslationResolver", getTranslationTable(langKey).then(onResolve, deferred.reject), 
                deferred.promise;
            }, getFallbackTranslationInstant = function(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                var result, translationTable = $translationTable[langKey];
                if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId) && null !== translationTable[translationId]) {
                    if (Interpolator.setLocale(langKey), result = Interpolator.interpolate(translationTable[translationId], interpolateParams, "filter", sanitizeStrategy, translationId), 
                    result = applyPostProcessing(translationId, translationTable[translationId], result, interpolateParams, langKey, sanitizeStrategy), 
                    !angular.isString(result) && angular.isFunction(result.$$unwrapTrustedValue)) {
                        var result2 = result.$$unwrapTrustedValue();
                        if ("@:" === result2.substr(0, 2)) return getFallbackTranslationInstant(langKey, result2.substr(2), interpolateParams, Interpolator, sanitizeStrategy);
                    } else if ("@:" === result.substr(0, 2)) return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator, sanitizeStrategy);
                    Interpolator.setLocale($uses);
                }
                return result;
            }, translateByHandler = function(translationId, interpolateParams, defaultTranslationText, sanitizeStrategy) {
                return $missingTranslationHandlerFactory ? $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams, defaultTranslationText, sanitizeStrategy) : translationId;
            }, resolveForFallbackLanguage = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
                var deferred = $q.defer();
                if (fallbackLanguageIndex < $fallbackLanguage.length) {
                    var langKey = $fallbackLanguage[fallbackLanguageIndex];
                    getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy).then(function(data) {
                        deferred.resolve(data);
                    }, function() {
                        return resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                    });
                } else if (defaultTranslationText) deferred.resolve(defaultTranslationText); else {
                    var missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);
                    $missingTranslationHandlerFactory && missingTranslationHandlerTranslation ? deferred.resolve(missingTranslationHandlerTranslation) : deferred.reject(applyNotFoundIndicators(translationId));
                }
                return deferred.promise;
            }, resolveForFallbackLanguageInstant = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                var result;
                if (fallbackLanguageIndex < $fallbackLanguage.length) {
                    var langKey = $fallbackLanguage[fallbackLanguageIndex];
                    (result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy)) || "" === result || (result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator));
                }
                return result;
            }, fallbackTranslation = function(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
                return resolveForFallbackLanguage(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy);
            }, fallbackTranslationInstant = function(translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                return resolveForFallbackLanguageInstant(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, sanitizeStrategy);
            }, determineTranslation = function(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy) {
                var deferred = $q.defer(), table = uses ? $translationTable[uses] : $translationTable, Interpolator = interpolationId ? interpolatorHashMap[interpolationId] : defaultInterpolator;
                if (table && Object.prototype.hasOwnProperty.call(table, translationId) && null !== table[translationId]) {
                    var translation = table[translationId];
                    if ("@:" === translation.substr(0, 2)) $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject); else {
                        var resolvedTranslation = Interpolator.interpolate(translation, interpolateParams, "service", sanitizeStrategy, translationId);
                        resolvedTranslation = applyPostProcessing(translationId, translation, resolvedTranslation, interpolateParams, uses), 
                        deferred.resolve(resolvedTranslation);
                    }
                } else {
                    var missingTranslationHandlerTranslation;
                    $missingTranslationHandlerFactory && !pendingLoader && (missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText)), 
                    uses && $fallbackLanguage && $fallbackLanguage.length ? fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(function(translation) {
                        deferred.resolve(translation);
                    }, function(_translationId) {
                        deferred.reject(applyNotFoundIndicators(_translationId));
                    }) : $missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation ? defaultTranslationText ? deferred.resolve(defaultTranslationText) : deferred.resolve(missingTranslationHandlerTranslation) : defaultTranslationText ? deferred.resolve(defaultTranslationText) : deferred.reject(applyNotFoundIndicators(translationId));
                }
                return deferred.promise;
            }, determineTranslationInstant = function(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy) {
                var result, table = uses ? $translationTable[uses] : $translationTable, Interpolator = defaultInterpolator;
                if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId) && (Interpolator = interpolatorHashMap[interpolationId]), 
                table && Object.prototype.hasOwnProperty.call(table, translationId) && null !== table[translationId]) {
                    var translation = table[translationId];
                    "@:" === translation.substr(0, 2) ? result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses, sanitizeStrategy) : (result = Interpolator.interpolate(translation, interpolateParams, "filter", sanitizeStrategy, translationId), 
                    result = applyPostProcessing(translationId, translation, result, interpolateParams, uses, sanitizeStrategy));
                } else {
                    var missingTranslationHandlerTranslation;
                    $missingTranslationHandlerFactory && !pendingLoader && (missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy)), 
                    uses && $fallbackLanguage && $fallbackLanguage.length ? (fallbackIndex = 0, result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator, sanitizeStrategy)) : result = $missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation ? missingTranslationHandlerTranslation : applyNotFoundIndicators(translationId);
                }
                return result;
            }, clearNextLangAndPromise = function(key) {
                $nextLang === key && ($nextLang = void 0), langPromises[key] = void 0;
            }, applyPostProcessing = function(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy) {
                var fn = postProcessFn;
                return fn && ("string" == typeof fn && (fn = $injector.get(fn)), fn) ? fn(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy) : resolvedTranslation;
            }, loadTranslationsIfMissing = function(key) {
                $translationTable[key] || !$loaderFactory || langPromises[key] || (langPromises[key] = loadAsync(key).then(function(translation) {
                    return translations(translation.key, translation.table), translation;
                }));
            };
            $translate.preferredLanguage = function(langKey) {
                return langKey && setupPreferredLanguage(langKey), $preferredLanguage;
            }, $translate.cloakClassName = function() {
                return $cloakClassName;
            }, $translate.nestedObjectDelimeter = function() {
                return $nestedObjectDelimeter;
            }, $translate.fallbackLanguage = function(langKey) {
                if (void 0 !== langKey && null !== langKey) {
                    if (fallbackStack(langKey), $loaderFactory && $fallbackLanguage && $fallbackLanguage.length) for (var i = 0, len = $fallbackLanguage.length; i < len; i++) langPromises[$fallbackLanguage[i]] || (langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]));
                    $translate.use($translate.use());
                }
                return $fallbackWasString ? $fallbackLanguage[0] : $fallbackLanguage;
            }, $translate.useFallbackLanguage = function(langKey) {
                if (void 0 !== langKey && null !== langKey) if (langKey) {
                    var langKeyPosition = indexOf($fallbackLanguage, langKey);
                    langKeyPosition > -1 && (startFallbackIteration = langKeyPosition);
                } else startFallbackIteration = 0;
            }, $translate.proposedLanguage = function() {
                return $nextLang;
            }, $translate.storage = function() {
                return Storage;
            }, $translate.negotiateLocale = negotiateLocale, $translate.use = function(key) {
                if (!key) return $uses;
                var deferred = $q.defer();
                deferred.promise.then(null, angular.noop), $rootScope.$emit("$translateChangeStart", {
                    language: key
                });
                var aliasedKey = negotiateLocale(key);
                return $availableLanguageKeys.length > 0 && !aliasedKey ? $q.reject(key) : (aliasedKey && (key = aliasedKey), 
                $nextLang = key, !$forceAsyncReloadEnabled && $translationTable[key] || !$loaderFactory || langPromises[key] ? langPromises[key] ? langPromises[key].then(function(translation) {
                    return $nextLang === translation.key && useLanguage(translation.key), deferred.resolve(translation.key), 
                    translation;
                }, function(key) {
                    return !$uses && $fallbackLanguage && $fallbackLanguage.length > 0 && $fallbackLanguage[0] !== key ? $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject) : deferred.reject(key);
                }) : (deferred.resolve(key), useLanguage(key)) : (langPromises[key] = loadAsync(key).then(function(translation) {
                    return translations(translation.key, translation.table), deferred.resolve(translation.key), 
                    $nextLang === key && useLanguage(translation.key), translation;
                }, function(key) {
                    return $rootScope.$emit("$translateChangeError", {
                        language: key
                    }), deferred.reject(key), $rootScope.$emit("$translateChangeEnd", {
                        language: key
                    }), $q.reject(key);
                }), langPromises[key].finally(function() {
                    clearNextLangAndPromise(key);
                }).catch(angular.noop)), deferred.promise);
            }, $translate.resolveClientLocale = function() {
                return getLocale();
            }, $translate.storageKey = function() {
                return storageKey();
            }, $translate.isPostCompilingEnabled = function() {
                return $postCompilingEnabled;
            }, $translate.isForceAsyncReloadEnabled = function() {
                return $forceAsyncReloadEnabled;
            }, $translate.isKeepContent = function() {
                return $keepContent;
            }, $translate.refresh = function(langKey) {
                function loadNewData(languageKey) {
                    var promise = loadAsync(languageKey);
                    return langPromises[languageKey] = promise, promise.then(function(data) {
                        $translationTable[languageKey] = {}, translations(languageKey, data.table), updatedLanguages[languageKey] = !0;
                    }, angular.noop), promise;
                }
                if (!$loaderFactory) throw new Error("Couldn't refresh translation table, no loader registered!");
                $rootScope.$emit("$translateRefreshStart", {
                    language: langKey
                });
                var deferred = $q.defer(), updatedLanguages = {};
                if (deferred.promise.then(function() {
                    for (var key in $translationTable) $translationTable.hasOwnProperty(key) && (key in updatedLanguages || delete $translationTable[key]);
                    $uses && useLanguage($uses);
                }, angular.noop).finally(function() {
                    $rootScope.$emit("$translateRefreshEnd", {
                        language: langKey
                    });
                }), langKey) $translationTable[langKey] ? loadNewData(langKey).then(deferred.resolve, deferred.reject) : deferred.reject(); else {
                    var languagesToReload = $fallbackLanguage && $fallbackLanguage.slice() || [];
                    $uses && -1 === languagesToReload.indexOf($uses) && languagesToReload.push($uses), 
                    $q.all(languagesToReload.map(loadNewData)).then(deferred.resolve, deferred.reject);
                }
                return deferred.promise;
            }, $translate.instant = function(translationId, interpolateParams, interpolationId, forceLanguage, sanitizeStrategy) {
                var uses = forceLanguage && forceLanguage !== $uses ? negotiateLocale(forceLanguage) || forceLanguage : $uses;
                if (null === translationId || angular.isUndefined(translationId)) return translationId;
                if (forceLanguage && loadTranslationsIfMissing(forceLanguage), angular.isArray(translationId)) {
                    for (var results = {}, i = 0, c = translationId.length; i < c; i++) results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage, sanitizeStrategy);
                    return results;
                }
                if (angular.isString(translationId) && translationId.length < 1) return translationId;
                translationId && (translationId = trim.apply(translationId));
                var result, possibleLangKeys = [];
                $preferredLanguage && possibleLangKeys.push($preferredLanguage), uses && possibleLangKeys.push(uses), 
                $fallbackLanguage && $fallbackLanguage.length && (possibleLangKeys = possibleLangKeys.concat($fallbackLanguage));
                for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
                    var possibleLangKey = possibleLangKeys[j];
                    if ($translationTable[possibleLangKey] && void 0 !== $translationTable[possibleLangKey][translationId] && (result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy)), 
                    void 0 !== result) break;
                }
                if (!result && "" !== result) if ($notFoundIndicatorLeft || $notFoundIndicatorRight) result = applyNotFoundIndicators(translationId); else {
                    result = defaultInterpolator.interpolate(translationId, interpolateParams, "filter", sanitizeStrategy);
                    var missingTranslationHandlerTranslation;
                    $missingTranslationHandlerFactory && !pendingLoader && (missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy)), 
                    $missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation && (result = missingTranslationHandlerTranslation);
                }
                return result;
            }, $translate.versionInfo = function() {
                return "2.14.0";
            }, $translate.loaderCache = function() {
                return loaderCache;
            }, $translate.directivePriority = function() {
                return directivePriority;
            }, $translate.statefulFilter = function() {
                return statefulFilter;
            }, $translate.isReady = function() {
                return $isReady;
            };
            var $onReadyDeferred = $q.defer();
            $onReadyDeferred.promise.then(function() {
                $isReady = !0;
            }), $translate.onReady = function(fn) {
                var deferred = $q.defer();
                return angular.isFunction(fn) && deferred.promise.then(fn), $isReady ? deferred.resolve() : $onReadyDeferred.promise.then(deferred.resolve), 
                deferred.promise;
            }, $translate.getAvailableLanguageKeys = function() {
                return $availableLanguageKeys.length > 0 ? $availableLanguageKeys : null;
            }, $translate.getTranslationTable = function(langKey) {
                return langKey = langKey || $translate.use(), langKey && $translationTable[langKey] ? angular.copy($translationTable[langKey]) : null;
            };
            var globalOnReadyListener = $rootScope.$on("$translateReady", function() {
                $onReadyDeferred.resolve(), globalOnReadyListener(), globalOnReadyListener = null;
            }), globalOnChangeListener = $rootScope.$on("$translateChangeEnd", function() {
                $onReadyDeferred.resolve(), globalOnChangeListener(), globalOnChangeListener = null;
            });
            if ($loaderFactory) {
                if (angular.equals($translationTable, {}) && $translate.use() && $translate.use($translate.use()), 
                $fallbackLanguage && $fallbackLanguage.length) for (var processAsyncResult = function(translation) {
                    return translations(translation.key, translation.table), $rootScope.$emit("$translateChangeEnd", {
                        language: translation.key
                    }), translation;
                }, i = 0, len = $fallbackLanguage.length; i < len; i++) {
                    var fallbackLanguageId = $fallbackLanguage[i];
                    !$forceAsyncReloadEnabled && $translationTable[fallbackLanguageId] || (langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult));
                }
            } else $rootScope.$emit("$translateReady", {
                language: $translate.use()
            });
            return $translate;
        } ];
    }
    function $translateDefaultInterpolation($interpolate, $translateSanitization) {
        "use strict";
        var $locale, $translateInterpolator = {};
        return $translateInterpolator.setLocale = function(locale) {
            $locale = locale;
        }, $translateInterpolator.getInterpolationIdentifier = function() {
            return "default";
        }, $translateInterpolator.useSanitizeValueStrategy = function(value) {
            return $translateSanitization.useStrategy(value), this;
        }, $translateInterpolator.interpolate = function(value, interpolationParams, context, sanitizeStrategy) {
            interpolationParams = interpolationParams || {}, interpolationParams = $translateSanitization.sanitize(interpolationParams, "params", sanitizeStrategy, context);
            var interpolatedText;
            return angular.isNumber(value) ? interpolatedText = "" + value : angular.isString(value) ? (interpolatedText = $interpolate(value)(interpolationParams), 
            interpolatedText = $translateSanitization.sanitize(interpolatedText, "text", sanitizeStrategy, context)) : interpolatedText = "", 
            interpolatedText;
        }, $translateInterpolator;
    }
    function translateDirective($translate, $interpolate, $compile, $parse, $rootScope) {
        "use strict";
        var trim = function() {
            return this.toString().replace(/^\s+|\s+$/g, "");
        };
        return {
            restrict: "AE",
            scope: !0,
            priority: $translate.directivePriority(),
            compile: function(tElement, tAttr) {
                var translateValuesExist = tAttr.translateValues ? tAttr.translateValues : void 0, translateInterpolation = tAttr.translateInterpolation ? tAttr.translateInterpolation : void 0, translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i), interpolateRegExp = "^(.*)(" + $interpolate.startSymbol() + ".*" + $interpolate.endSymbol() + ")(.*)", watcherRegExp = "^(.*)" + $interpolate.startSymbol() + "(.*)" + $interpolate.endSymbol() + "(.*)";
                return function(scope, iElement, iAttr) {
                    scope.interpolateParams = {}, scope.preText = "", scope.postText = "", scope.translateNamespace = getTranslateNamespace(scope);
                    var translationIds = {}, observeElementTranslation = function(translationId) {
                        if (angular.isFunction(observeElementTranslation._unwatchOld) && (observeElementTranslation._unwatchOld(), 
                        observeElementTranslation._unwatchOld = void 0), angular.equals(translationId, "") || !angular.isDefined(translationId)) {
                            var iElementText = trim.apply(iElement.text()), interpolateMatches = iElementText.match(interpolateRegExp);
                            if (angular.isArray(interpolateMatches)) {
                                scope.preText = interpolateMatches[1], scope.postText = interpolateMatches[3], translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
                                var watcherMatches = iElementText.match(watcherRegExp);
                                angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length && (observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function(newValue) {
                                    translationIds.translate = newValue, updateTranslations();
                                }));
                            } else translationIds.translate = iElementText || void 0;
                        } else translationIds.translate = translationId;
                        updateTranslations();
                    };
                    !function(interpolateParams, iAttr, tAttr) {
                        if (iAttr.translateValues && angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent)), 
                        translateValueExist) for (var attr in tAttr) if (Object.prototype.hasOwnProperty.call(iAttr, attr) && "translateValue" === attr.substr(0, 14) && "translateValues" !== attr) {
                            var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);
                            interpolateParams[attributeName] = tAttr[attr];
                        }
                    }(scope.interpolateParams, iAttr, tAttr);
                    var firstAttributeChangedEvent = !0;
                    iAttr.$observe("translate", function(translationId) {
                        void 0 === translationId ? observeElementTranslation("") : "" === translationId && firstAttributeChangedEvent || (translationIds.translate = translationId, 
                        updateTranslations()), firstAttributeChangedEvent = !1;
                    });
                    for (var translateAttr in iAttr) iAttr.hasOwnProperty(translateAttr) && "translateAttr" === translateAttr.substr(0, 13) && translateAttr.length > 13 && function(translateAttr) {
                        iAttr.$observe(translateAttr, function(translationId) {
                            translationIds[translateAttr] = translationId, updateTranslations();
                        });
                    }(translateAttr);
                    if (iAttr.$observe("translateDefault", function(value) {
                        scope.defaultText = value, updateTranslations();
                    }), translateValuesExist && iAttr.$observe("translateValues", function(interpolateParams) {
                        interpolateParams && scope.$parent.$watch(function() {
                            angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
                        });
                    }), translateValueExist) {
                        for (var attr in iAttr) Object.prototype.hasOwnProperty.call(iAttr, attr) && "translateValue" === attr.substr(0, 14) && "translateValues" !== attr && function(attrName) {
                            iAttr.$observe(attrName, function(value) {
                                var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);
                                scope.interpolateParams[attributeName] = value;
                            });
                        }(attr);
                    }
                    var updateTranslations = function() {
                        for (var key in translationIds) translationIds.hasOwnProperty(key) && void 0 !== translationIds[key] && updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);
                    }, updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {
                        translationId ? (translateNamespace && "." === translationId.charAt(0) && (translationId = translateNamespace + translationId), 
                        $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage).then(function(translation) {
                            applyTranslation(translation, scope, !0, translateAttr);
                        }, function(translationId) {
                            applyTranslation(translationId, scope, !1, translateAttr);
                        })) : applyTranslation(translationId, scope, !1, translateAttr);
                    }, applyTranslation = function(value, scope, successful, translateAttr) {
                        if (successful || void 0 !== scope.defaultText && (value = scope.defaultText), "translate" === translateAttr) {
                            (successful || !successful && !$translate.isKeepContent() && void 0 === iAttr.translateKeepContent) && iElement.empty().append(scope.preText + value + scope.postText);
                            var globallyEnabled = $translate.isPostCompilingEnabled(), locallyDefined = void 0 !== tAttr.translateCompile, locallyEnabled = locallyDefined && "false" !== tAttr.translateCompile;
                            (globallyEnabled && !locallyDefined || locallyEnabled) && $compile(iElement.contents())(scope);
                        } else {
                            var attributeName = iAttr.$attr[translateAttr];
                            "data-" === attributeName.substr(0, 5) && (attributeName = attributeName.substr(5)), 
                            attributeName = attributeName.substr(15), iElement.attr(attributeName, value);
                        }
                    };
                    (translateValuesExist || translateValueExist || iAttr.translateDefault) && scope.$watch("interpolateParams", updateTranslations, !0), 
                    scope.$on("translateLanguageChanged", updateTranslations);
                    var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                    iElement.text().length ? observeElementTranslation(iAttr.translate ? iAttr.translate : "") : iAttr.translate && observeElementTranslation(iAttr.translate), 
                    updateTranslations(), scope.$on("$destroy", unbind);
                };
            }
        };
    }
    function getTranslateNamespace(scope) {
        "use strict";
        return scope.translateNamespace ? scope.translateNamespace : scope.$parent ? getTranslateNamespace(scope.$parent) : void 0;
    }
    function translateAttrDirective($translate, $rootScope) {
        "use strict";
        return {
            restrict: "A",
            priority: $translate.directivePriority(),
            link: function(scope, element, attr) {
                var translateAttr, translateValues, previousAttributes = {}, updateTranslations = function() {
                    angular.forEach(translateAttr, function(translationId, attributeName) {
                        translationId && (previousAttributes[attributeName] = !0, scope.translateNamespace && "." === translationId.charAt(0) && (translationId = scope.translateNamespace + translationId), 
                        $translate(translationId, translateValues, attr.translateInterpolation, void 0, scope.translateLanguage).then(function(translation) {
                            element.attr(attributeName, translation);
                        }, function(translationId) {
                            element.attr(attributeName, translationId);
                        }));
                    }), angular.forEach(previousAttributes, function(flag, attributeName) {
                        translateAttr[attributeName] || (element.removeAttr(attributeName), delete previousAttributes[attributeName]);
                    });
                };
                watchAttribute(scope, attr.translateAttr, function(newValue) {
                    translateAttr = newValue;
                }, updateTranslations), watchAttribute(scope, attr.translateValues, function(newValue) {
                    translateValues = newValue;
                }, updateTranslations), attr.translateValues && scope.$watch(attr.translateValues, updateTranslations, !0), 
                scope.$on("translateLanguageChanged", updateTranslations);
                var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                updateTranslations(), scope.$on("$destroy", unbind);
            }
        };
    }
    function watchAttribute(scope, attribute, valueCallback, changeCallback) {
        "use strict";
        attribute && ("::" === attribute.substr(0, 2) ? attribute = attribute.substr(2) : scope.$watch(attribute, function(newValue) {
            valueCallback(newValue), changeCallback();
        }, !0), valueCallback(scope.$eval(attribute)));
    }
    function translateCloakDirective($translate) {
        "use strict";
        return {
            compile: function(tElement) {
                var applyCloak = function(element) {
                    element.addClass($translate.cloakClassName());
                }, removeCloak = function(element) {
                    element.removeClass($translate.cloakClassName());
                };
                return applyCloak(tElement), function(scope, iElement, iAttr) {
                    var iRemoveCloak = removeCloak.bind(this, iElement), iApplyCloak = applyCloak.bind(this, iElement);
                    iAttr.translateCloak && iAttr.translateCloak.length ? iAttr.$observe("translateCloak", function(translationId) {
                        $translate(translationId).then(iRemoveCloak, iApplyCloak);
                    }) : $translate.onReady(iRemoveCloak);
                };
            }
        };
    }
    function translateNamespaceDirective() {
        "use strict";
        return {
            restrict: "A",
            scope: !0,
            compile: function() {
                return {
                    pre: function(scope, iElement, iAttrs) {
                        scope.translateNamespace = getTranslateNamespace(scope), scope.translateNamespace && "." === iAttrs.translateNamespace.charAt(0) ? scope.translateNamespace += iAttrs.translateNamespace : scope.translateNamespace = iAttrs.translateNamespace;
                    }
                };
            }
        };
    }
    function getTranslateNamespace(scope) {
        "use strict";
        return scope.translateNamespace ? scope.translateNamespace : scope.$parent ? getTranslateNamespace(scope.$parent) : void 0;
    }
    function translateLanguageDirective() {
        "use strict";
        return {
            restrict: "A",
            scope: !0,
            compile: function() {
                return function(scope, iElement, iAttrs) {
                    iAttrs.$observe("translateLanguage", function(newTranslateLanguage) {
                        scope.translateLanguage = newTranslateLanguage;
                    }), scope.$watch("translateLanguage", function() {
                        scope.$broadcast("translateLanguageChanged");
                    });
                };
            }
        };
    }
    function translateFilterFactory($parse, $translate) {
        "use strict";
        var translateFilter = function(translationId, interpolateParams, interpolation, forceLanguage) {
            return angular.isObject(interpolateParams) || (interpolateParams = $parse(interpolateParams)(this)), 
            $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);
        };
        return $translate.statefulFilter() && (translateFilter.$stateful = !0), translateFilter;
    }
    function $translationCache($cacheFactory) {
        "use strict";
        return $cacheFactory("translations");
    }
    return runTranslate.$inject = [ "$translate" ], $translate.$inject = [ "$STORAGE_KEY", "$windowProvider", "$translateSanitizationProvider", "pascalprechtTranslateOverrider" ], 
    $translateDefaultInterpolation.$inject = [ "$interpolate", "$translateSanitization" ], 
    translateDirective.$inject = [ "$translate", "$interpolate", "$compile", "$parse", "$rootScope" ], 
    translateAttrDirective.$inject = [ "$translate", "$rootScope" ], translateCloakDirective.$inject = [ "$translate" ], 
    translateFilterFactory.$inject = [ "$parse", "$translate" ], $translationCache.$inject = [ "$cacheFactory" ], 
    angular.module("pascalprecht.translate", [ "ng" ]).run(runTranslate), runTranslate.displayName = "runTranslate", 
    angular.module("pascalprecht.translate").provider("$translateSanitization", $translateSanitizationProvider), 
    angular.module("pascalprecht.translate").constant("pascalprechtTranslateOverrider", {}).provider("$translate", $translate), 
    $translate.displayName = "displayName", angular.module("pascalprecht.translate").factory("$translateDefaultInterpolation", $translateDefaultInterpolation), 
    $translateDefaultInterpolation.displayName = "$translateDefaultInterpolation", angular.module("pascalprecht.translate").constant("$STORAGE_KEY", "NG_TRANSLATE_LANG_KEY"), 
    angular.module("pascalprecht.translate").directive("translate", translateDirective), 
    translateDirective.displayName = "translateDirective", angular.module("pascalprecht.translate").directive("translateAttr", translateAttrDirective), 
    translateAttrDirective.displayName = "translateAttrDirective", angular.module("pascalprecht.translate").directive("translateCloak", translateCloakDirective), 
    translateCloakDirective.displayName = "translateCloakDirective", angular.module("pascalprecht.translate").directive("translateNamespace", translateNamespaceDirective), 
    translateNamespaceDirective.displayName = "translateNamespaceDirective", angular.module("pascalprecht.translate").directive("translateLanguage", translateLanguageDirective), 
    translateLanguageDirective.displayName = "translateLanguageDirective", angular.module("pascalprecht.translate").filter("translate", translateFilterFactory), 
    translateFilterFactory.displayName = "translateFilterFactory", angular.module("pascalprecht.translate").factory("$translationCache", $translationCache), 
    $translationCache.displayName = "$translationCache", "pascalprecht.translate";
}), function(window, angular) {
    var isDefined = angular.isDefined, isUndefined = angular.isUndefined, isNumber = angular.isNumber, isObject = angular.isObject, isArray = angular.isArray, isString = angular.isString, extend = angular.extend, toJson = angular.toJson;
    angular.module("LocalStorageModule", []).provider("localStorageService", function() {
        this.prefix = "ls", this.storageType = "localStorage", this.cookie = {
            expiry: 30,
            path: "/",
            secure: !1
        }, this.defaultToCookie = !0, this.notify = {
            setItem: !0,
            removeItem: !1
        }, this.setPrefix = function(prefix) {
            return this.prefix = prefix, this;
        }, this.setStorageType = function(storageType) {
            return this.storageType = storageType, this;
        }, this.setDefaultToCookie = function(shouldDefault) {
            return this.defaultToCookie = !!shouldDefault, this;
        }, this.setStorageCookie = function(exp, path, secure) {
            return this.cookie.expiry = exp, this.cookie.path = path, this.cookie.secure = secure, 
            this;
        }, this.setStorageCookieDomain = function(domain) {
            return this.cookie.domain = domain, this;
        }, this.setNotify = function(itemSet, itemRemove) {
            return this.notify = {
                setItem: itemSet,
                removeItem: itemRemove
            }, this;
        }, this.$get = [ "$rootScope", "$window", "$document", "$parse", "$timeout", function($rootScope, $window, $document, $parse, $timeout) {
            function handleStorageChangeCallback(e) {
                if (e || (e = $window.event), notify.setItem && isString(e.key) && isKeyPrefixOurs(e.key)) {
                    var key = underiveQualifiedKey(e.key);
                    $timeout(function() {
                        $rootScope.$broadcast("LocalStorageModule.notification.changed", {
                            key: key,
                            newvalue: e.newValue,
                            storageType: self.storageType
                        });
                    });
                }
            }
            var webStorage, self = this, prefix = self.prefix, cookie = self.cookie, notify = self.notify, storageType = self.storageType;
            $document ? $document[0] && ($document = $document[0]) : $document = document, "." !== prefix.substr(-1) && (prefix = prefix ? prefix + "." : "");
            var deriveQualifiedKey = function(key) {
                return prefix + key;
            }, underiveQualifiedKey = function(key) {
                return key.replace(new RegExp("^" + prefix, "g"), "");
            }, isKeyPrefixOurs = function(key) {
                return 0 === key.indexOf(prefix);
            }, checkSupport = function() {
                try {
                    var supported = storageType in $window && null !== $window[storageType], key = deriveQualifiedKey("__" + Math.round(1e7 * Math.random()));
                    return supported && (webStorage = $window[storageType], webStorage.setItem(key, ""), 
                    webStorage.removeItem(key)), supported;
                } catch (e) {
                    return self.defaultToCookie && (storageType = "cookie"), $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), 
                    !1;
                }
            }, browserSupportsLocalStorage = checkSupport(), addToLocalStorage = function(key, value, type) {
                if (setStorageType(type), value = isUndefined(value) ? null : toJson(value), !browserSupportsLocalStorage && self.defaultToCookie || "cookie" === self.storageType) return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), 
                notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                    key: key,
                    newvalue: value,
                    storageType: "cookie"
                }), addToCookies(key, value);
                try {
                    webStorage && webStorage.setItem(deriveQualifiedKey(key), value), notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                        key: key,
                        newvalue: value,
                        storageType: self.storageType
                    });
                } catch (e) {
                    return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), 
                    addToCookies(key, value);
                }
                return !0;
            }, getFromLocalStorage = function(key, type) {
                if (setStorageType(type), !browserSupportsLocalStorage && self.defaultToCookie || "cookie" === self.storageType) return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), 
                getFromCookies(key);
                var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
                if (!item || "null" === item) return null;
                try {
                    return JSON.parse(item);
                } catch (e) {
                    return item;
                }
            }, removeFromLocalStorage = function() {
                var consumed = 0;
                arguments.length >= 1 && ("localStorage" === arguments[arguments.length - 1] || "sessionStorage" === arguments[arguments.length - 1]) && (consumed = 1, 
                setStorageType(arguments[arguments.length - 1]));
                var i, key;
                for (i = 0; i < arguments.length - consumed; i++) if (key = arguments[i], !browserSupportsLocalStorage && self.defaultToCookie || "cookie" === self.storageType) browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), 
                notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                    key: key,
                    storageType: "cookie"
                }), removeFromCookies(key); else try {
                    webStorage.removeItem(deriveQualifiedKey(key)), notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                        key: key,
                        storageType: self.storageType
                    });
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), removeFromCookies(key);
                }
            }, getKeysForLocalStorage = function(type) {
                if (setStorageType(type), !browserSupportsLocalStorage) return $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), 
                [];
                var prefixLength = prefix.length, keys = [];
                for (var key in webStorage) if (key.substr(0, prefixLength) === prefix) try {
                    keys.push(key.substr(prefixLength));
                } catch (e) {
                    return $rootScope.$broadcast("LocalStorageModule.notification.error", e.Description), 
                    [];
                }
                return keys;
            }, clearAllFromLocalStorage = function(regularExpression, type) {
                setStorageType(type);
                var prefixRegex = prefix ? new RegExp("^" + prefix) : new RegExp(), testRegex = regularExpression ? new RegExp(regularExpression) : new RegExp();
                if (!browserSupportsLocalStorage && self.defaultToCookie || "cookie" === self.storageType) return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), 
                clearAllFromCookies();
                if (!browserSupportsLocalStorage && !self.defaultToCookie) return !1;
                var prefixLength = prefix.length;
                for (var key in webStorage) if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) try {
                    removeFromLocalStorage(key.substr(prefixLength));
                } catch (e) {
                    return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), 
                    clearAllFromCookies();
                }
                return !0;
            }, browserSupportsCookies = function() {
                try {
                    return $window.navigator.cookieEnabled || "cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1);
                } catch (e) {
                    return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), 
                    !1;
                }
            }(), addToCookies = function(key, value, daysToExpiry, secure) {
                if (isUndefined(value)) return !1;
                if ((isArray(value) || isObject(value)) && (value = toJson(value)), !browserSupportsCookies) return $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED"), 
                !1;
                try {
                    var expiry = "", expiryDate = new Date(), cookieDomain = "";
                    if (null === value ? (expiryDate.setTime(expiryDate.getTime() + -864e5), expiry = "; expires=" + expiryDate.toGMTString(), 
                    value = "") : isNumber(daysToExpiry) && 0 !== daysToExpiry ? (expiryDate.setTime(expiryDate.getTime() + 24 * daysToExpiry * 60 * 60 * 1e3), 
                    expiry = "; expires=" + expiryDate.toGMTString()) : 0 !== cookie.expiry && (expiryDate.setTime(expiryDate.getTime() + 24 * cookie.expiry * 60 * 60 * 1e3), 
                    expiry = "; expires=" + expiryDate.toGMTString()), key) {
                        var cookiePath = "; path=" + cookie.path;
                        cookie.domain && (cookieDomain = "; domain=" + cookie.domain), "boolean" == typeof secure ? !0 === secure && (cookieDomain += "; secure") : !0 === cookie.secure && (cookieDomain += "; secure"), 
                        $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
                    }
                } catch (e) {
                    return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), 
                    !1;
                }
                return !0;
            }, getFromCookies = function(key) {
                if (!browserSupportsCookies) return $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED"), 
                !1;
                for (var cookies = $document.cookie && $document.cookie.split(";") || [], i = 0; i < cookies.length; i++) {
                    for (var thisCookie = cookies[i]; " " === thisCookie.charAt(0); ) thisCookie = thisCookie.substring(1, thisCookie.length);
                    if (0 === thisCookie.indexOf(deriveQualifiedKey(key) + "=")) {
                        var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
                        try {
                            var parsedValue = JSON.parse(storedValues);
                            return "number" == typeof parsedValue ? storedValues : parsedValue;
                        } catch (e) {
                            return storedValues;
                        }
                    }
                }
                return null;
            }, removeFromCookies = function(key) {
                addToCookies(key, null);
            }, clearAllFromCookies = function() {
                for (var thisCookie = null, prefixLength = prefix.length, cookies = $document.cookie.split(";"), i = 0; i < cookies.length; i++) {
                    for (thisCookie = cookies[i]; " " === thisCookie.charAt(0); ) thisCookie = thisCookie.substring(1, thisCookie.length);
                    var key = thisCookie.substring(prefixLength, thisCookie.indexOf("="));
                    removeFromCookies(key);
                }
            }, getStorageType = function() {
                return storageType;
            }, setStorageType = function(type) {
                return type && storageType !== type && (storageType = type, browserSupportsLocalStorage = checkSupport()), 
                browserSupportsLocalStorage;
            }, bindToScope = function(scope, key, def, lsKey, type) {
                lsKey = lsKey || key;
                var value = getFromLocalStorage(lsKey, type);
                return null === value && isDefined(def) ? value = def : isObject(value) && isObject(def) && (value = extend(value, def)), 
                $parse(key).assign(scope, value), scope.$watch(key, function(newVal) {
                    addToLocalStorage(lsKey, newVal, type);
                }, isObject(scope[key]));
            };
            return browserSupportsLocalStorage && ($window.addEventListener ? ($window.addEventListener("storage", handleStorageChangeCallback, !1), 
            $rootScope.$on("$destroy", function() {
                $window.removeEventListener("storage", handleStorageChangeCallback);
            })) : $window.attachEvent && ($window.attachEvent("onstorage", handleStorageChangeCallback), 
            $rootScope.$on("$destroy", function() {
                $window.detachEvent("onstorage", handleStorageChangeCallback);
            }))), {
                isSupported: browserSupportsLocalStorage,
                getStorageType: getStorageType,
                setStorageType: setStorageType,
                set: addToLocalStorage,
                add: addToLocalStorage,
                get: getFromLocalStorage,
                keys: getKeysForLocalStorage,
                remove: removeFromLocalStorage,
                clearAll: clearAllFromLocalStorage,
                bind: bindToScope,
                deriveKey: deriveQualifiedKey,
                underiveKey: underiveQualifiedKey,
                length: function(type) {
                    setStorageType(type);
                    for (var count = 0, storage = $window[storageType], i = 0; i < storage.length; i++) 0 === storage.key(i).indexOf(prefix) && count++;
                    return count;
                },
                defaultToCookie: this.defaultToCookie,
                cookie: {
                    isSupported: browserSupportsCookies,
                    set: addToCookies,
                    add: addToCookies,
                    get: getFromCookies,
                    remove: removeFromCookies,
                    clearAll: clearAllFromCookies
                }
            };
        } ];
    });
}(window, window.angular), define("angular-local-storage", [ "angular" ], function() {}), 
function(window, angular) {
    "use strict";
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function packageStyles(options) {
        var styles = {};
        return options && (options.to || options.from) && (styles.to = options.to, styles.from = options.from), 
        styles;
    }
    function pendClasses(classes, fix, isPrefix) {
        var className = "";
        return classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [], 
        forEach(classes, function(klass, i) {
            klass && klass.length > 0 && (className += i > 0 ? " " : "", className += isPrefix ? fix + klass : klass + fix);
        }), className;
    }
    function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        val >= 0 && arr.splice(index, 1);
    }
    function stripCommentsFromElement(element) {
        if (element instanceof jqLite) switch (element.length) {
          case 0:
            return element;

          case 1:
            if (element[0].nodeType === ELEMENT_NODE) return element;
            break;

          default:
            return jqLite(extractElementNode(element));
        }
        if (element.nodeType === ELEMENT_NODE) return jqLite(element);
    }
    function extractElementNode(element) {
        if (!element[0]) return element;
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.addClass(elm, className);
        });
    }
    function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.removeClass(elm, className);
        });
    }
    function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
            options.addClass && ($$addClass($$jqLite, element, options.addClass), options.addClass = null), 
            options.removeClass && ($$removeClass($$jqLite, element, options.removeClass), options.removeClass = null);
        };
    }
    function prepareAnimationOptions(options) {
        if (options = options || {}, !options.$$prepared) {
            var domOperation = options.domOperation || noop;
            options.domOperation = function() {
                options.$$domOperationFired = !0, domOperation(), domOperation = noop;
            }, options.$$prepared = !0;
        }
        return options;
    }
    function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options);
    }
    function applyAnimationFromStyles(element, options) {
        options.from && (element.css(options.from), options.from = null);
    }
    function applyAnimationToStyles(element, options) {
        options.to && (element.css(options.to), options.to = null);
    }
    function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {}, newOptions = newAnimation.options || {}, toAdd = (target.addClass || "") + " " + (newOptions.addClass || ""), toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || ""), classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
        newOptions.preparationClasses && (target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses), 
        delete newOptions.preparationClasses);
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        return extend(target, newOptions), realDomOperation && (target.domOperation = realDomOperation), 
        classes.addClass ? target.addClass = classes.addClass : target.addClass = null, 
        classes.removeClass ? target.removeClass = classes.removeClass : target.removeClass = null, 
        oldAnimation.addClass = target.addClass, oldAnimation.removeClass = target.removeClass, 
        target;
    }
    function resolveElementClasses(existing, toAdd, toRemove) {
        function splitClassesToLookup(classes) {
            isString(classes) && (classes = classes.split(" "));
            var obj = {};
            return forEach(classes, function(klass) {
                klass.length && (obj[klass] = !0);
            }), obj;
        }
        var flags = {};
        existing = splitClassesToLookup(existing), toAdd = splitClassesToLookup(toAdd), 
        forEach(toAdd, function(value, key) {
            flags[key] = 1;
        }), toRemove = splitClassesToLookup(toRemove), forEach(toRemove, function(value, key) {
            flags[key] = 1 === flags[key] ? null : -1;
        });
        var classes = {
            addClass: "",
            removeClass: ""
        };
        return forEach(flags, function(val, klass) {
            var prop, allow;
            1 === val ? (prop = "addClass", allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX]) : -1 === val && (prop = "removeClass", 
            allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX]), allow && (classes[prop].length && (classes[prop] += " "), 
            classes[prop] += klass);
        }), classes;
    }
    function getDomNode(element) {
        return element instanceof jqLite ? element[0] : element;
    }
    function applyGeneratedPreparationClasses(element, event, options) {
        var classes = "";
        event && (classes = pendClasses(event, EVENT_CLASS_PREFIX, !0)), options.addClass && (classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX))), 
        options.removeClass && (classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX))), 
        classes.length && (options.preparationClasses = classes, element.addClass(classes));
    }
    function clearGeneratedClasses(element, options) {
        options.preparationClasses && (element.removeClass(options.preparationClasses), 
        options.preparationClasses = null), options.activeClasses && (element.removeClass(options.activeClasses), 
        options.activeClasses = null);
    }
    function blockTransitions(node, duration) {
        var value = duration ? "-" + duration + "s" : "";
        return applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]), [ TRANSITION_DELAY_PROP, value ];
    }
    function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? "paused" : "", key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        return applyInlineStyle(node, [ key, value ]), [ key, value ];
    }
    function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0], value = styleTuple[1];
        node.style[prop] = value;
    }
    function concatWithSpace(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    function getCssKeyframeDurationStyle(duration) {
        return [ ANIMATION_DURATION_PROP, duration + "s" ];
    }
    function getCssDelayStyle(delay, isKeyframeAnimation) {
        return [ isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP, delay + "s" ];
    }
    function computeCssStyles($window, element, properties) {
        var styles = Object.create(null), detectedStyles = $window.getComputedStyle(element) || {};
        return forEach(properties, function(formalStyleName, actualStyleName) {
            var val = detectedStyles[formalStyleName];
            if (val) {
                var c = val.charAt(0);
                ("-" === c || "+" === c || c >= 0) && (val = parseMaxTime(val)), 0 === val && (val = null), 
                styles[actualStyleName] = val;
            }
        }), styles;
    }
    function parseMaxTime(str) {
        var maxValue = 0, values = str.split(/\s*,\s*/);
        return forEach(values, function(value) {
            "s" === value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), 
            value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value;
        }), maxValue;
    }
    function truthyTimingValue(val) {
        return 0 === val || null != val;
    }
    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP, value = duration + "s";
        return applyOnlyDuration ? style += DURATION_KEY : value += " linear all", [ style, value ];
    }
    function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
            flush: function() {
                cache = Object.create(null);
            },
            count: function(key) {
                var entry = cache[key];
                return entry ? entry.total : 0;
            },
            get: function(key) {
                var entry = cache[key];
                return entry && entry.value;
            },
            put: function(key, value) {
                cache[key] ? cache[key].total++ : cache[key] = {
                    total: 1,
                    value: value
                };
            }
        };
    }
    function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
            backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
    }
    var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, ELEMENT_NODE = 1, ADD_CLASS_SUFFIX = "-add", REMOVE_CLASS_SUFFIX = "-remove", EVENT_CLASS_PREFIX = "ng-", NG_ANIMATE_CLASSNAME = "ng-animate", NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";
    void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend ? ("-webkit-", 
    TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", 
    TRANSITIONEND_EVENT = "transitionend"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend ? ("-webkit-", 
    ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", 
    ANIMATIONEND_EVENT = "animationend");
    var copy, extend, forEach, isArray, isDefined, isElement, isFunction, isObject, isString, isUndefined, jqLite, noop, DURATION_KEY = "Duration", TIMING_KEY = "TimingFunction", ANIMATION_PLAYSTATE_KEY = "PlayState", ANIMATION_DELAY_PROP = ANIMATION_PROP + "Delay", ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY, TRANSITION_DELAY_PROP = TRANSITION_PROP + "Delay", TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY, ngMinErr = angular.$$minErr("ng"), $$rAFSchedulerFactory = [ "$$rAF", function($$rAF) {
        function scheduler(tasks) {
            queue = queue.concat(tasks), nextTick();
        }
        function nextTick() {
            if (queue.length) {
                for (var items = queue.shift(), i = 0; i < items.length; i++) items[i]();
                cancelFn || $$rAF(function() {
                    cancelFn || nextTick();
                });
            }
        }
        var queue, cancelFn;
        return queue = scheduler.queue = [], scheduler.waitUntilQuiet = function(fn) {
            cancelFn && cancelFn(), cancelFn = $$rAF(function() {
                cancelFn = null, fn(), nextTick();
            });
        }, scheduler;
    } ], $$AnimateChildrenDirective = [ "$interpolate", function($interpolate) {
        return {
            link: function(scope, element, attrs) {
                function setData(value) {
                    value = "on" === value || "true" === value, element.data(NG_ANIMATE_CHILDREN_DATA, value);
                }
                var val = attrs.ngAnimateChildren;
                isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN_DATA, !0) : (setData($interpolate(val)(scope)), 
                attrs.$observe("ngAnimateChildren", setData));
            }
        };
    } ], ANIMATE_TIMER_KEY = "$$animateCss", ONE_SECOND = 1e3, ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + "Property",
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + "IterationCount"
    }, DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
    }, $AnimateCssProvider = [ "$animateProvider", function($animateProvider) {
        var gcsLookup = createLocalCacheLookup(), gcsStaggerLookup = createLocalCacheLookup();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
            function gcsHashFn(node, extraClasses) {
                var KEY = "$$ngAnimateParentKey", parentNode = node.parentNode;
                return (parentNode[KEY] || (parentNode[KEY] = ++parentCounter)) + "-" + node.getAttribute("class") + "-" + extraClasses;
            }
            function computeCachedCssStyles(node, className, cacheKey, properties) {
                var timings = gcsLookup.get(cacheKey);
                return timings || (timings = computeCssStyles($window, node, properties), "infinite" === timings.animationIterationCount && (timings.animationIterationCount = 1)), 
                gcsLookup.put(cacheKey, timings), timings;
            }
            function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                var stagger;
                if (gcsLookup.count(cacheKey) > 0 && !(stagger = gcsStaggerLookup.get(cacheKey))) {
                    var staggerClassName = pendClasses(className, "-stagger");
                    $$jqLite.addClass(node, staggerClassName), stagger = computeCssStyles($window, node, properties), 
                    stagger.animationDuration = Math.max(stagger.animationDuration, 0), stagger.transitionDuration = Math.max(stagger.transitionDuration, 0), 
                    $$jqLite.removeClass(node, staggerClassName), gcsStaggerLookup.put(cacheKey, stagger);
                }
                return stagger || {};
            }
            function waitUntilQuiet(callback) {
                rafWaitQueue.push(callback), $$rAFScheduler.waitUntilQuiet(function() {
                    gcsLookup.flush(), gcsStaggerLookup.flush();
                    for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                    rafWaitQueue.length = 0;
                });
            }
            function computeTimings(node, className, cacheKey) {
                var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES), aD = timings.animationDelay, tD = timings.transitionDelay;
                return timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD, timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration), 
                timings;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite), parentCounter = 0, rafWaitQueue = [];
            return function(element, initialOptions) {
                function endFn() {
                    close();
                }
                function cancelFn() {
                    close(!0);
                }
                function close(rejected) {
                    if (!(animationClosed || animationCompleted && animationPaused)) {
                        animationClosed = !0, animationPaused = !1, options.$$skipPreparationClasses || $$jqLite.removeClass(element, preparationClasses), 
                        $$jqLite.removeClass(element, activeClasses), blockKeyframeAnimations(node, !1), 
                        blockTransitions(node, !1), forEach(temporaryStyles, function(entry) {
                            node.style[entry[0]] = "";
                        }), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                        Object.keys(restoreStyles).length && forEach(restoreStyles, function(value, prop) {
                            value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                        }), options.onDone && options.onDone(), events && events.length && element.off(events.join(" "), onAnimationProgress);
                        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
                        animationTimerData && ($timeout.cancel(animationTimerData[0].timer), element.removeData(ANIMATE_TIMER_KEY)), 
                        runner && runner.complete(!rejected);
                    }
                }
                function applyBlocking(duration) {
                    flags.blockTransition && blockTransitions(node, duration), flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration);
                }
                function closeAndReturnNoopAnimator() {
                    return runner = new $$AnimateRunner({
                        end: endFn,
                        cancel: cancelFn
                    }), waitUntilQuiet(noop), close(), {
                        $$willAnimate: !1,
                        start: function() {
                            return runner;
                        },
                        end: endFn
                    };
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event, timeStamp = ev.$manualTimeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && (animationCompleted = !0, 
                    close());
                }
                function start() {
                    function triggerAnimationStart() {
                        if (!animationClosed) {
                            if (applyBlocking(!1), forEach(temporaryStyles, function(entry) {
                                var key = entry[0], value = entry[1];
                                node.style[key] = value;
                            }), applyAnimationClasses(element, options), $$jqLite.addClass(element, activeClasses), 
                            flags.recalculateTimingStyles) {
                                if (fullClassName = node.getAttribute("class") + " " + preparationClasses, cacheKey = gcsHashFn(node, fullClassName), 
                                timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay, 
                                maxDelay = Math.max(relativeDelay, 0), 0 === (maxDuration = timings.maxDuration)) return void close();
                                flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0;
                            }
                            if (flags.applyAnimationDelay && (relativeDelay = "boolean" != typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay, 
                            maxDelay = Math.max(relativeDelay, 0), timings.animationDelay = relativeDelay, delayStyle = getCssDelayStyle(relativeDelay, !0), 
                            temporaryStyles.push(delayStyle), node.style[delayStyle[0]] = delayStyle[1]), maxDelayTime = maxDelay * ONE_SECOND, 
                            maxDurationTime = maxDuration * ONE_SECOND, options.easing) {
                                var easeProp, easeVal = options.easing;
                                flags.hasTransitions && (easeProp = TRANSITION_PROP + TIMING_KEY, temporaryStyles.push([ easeProp, easeVal ]), 
                                node.style[easeProp] = easeVal), flags.hasAnimations && (easeProp = ANIMATION_PROP + TIMING_KEY, 
                                temporaryStyles.push([ easeProp, easeVal ]), node.style[easeProp] = easeVal);
                            }
                            timings.transitionDuration && events.push(TRANSITIONEND_EVENT), timings.animationDuration && events.push(ANIMATIONEND_EVENT), 
                            startTime = Date.now();
                            var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime, endTime = startTime + timerTime, animationsData = element.data(ANIMATE_TIMER_KEY) || [], setupFallbackTimer = !0;
                            if (animationsData.length) {
                                var currentTimerData = animationsData[0];
                                setupFallbackTimer = endTime > currentTimerData.expectedEndTime, setupFallbackTimer ? $timeout.cancel(currentTimerData.timer) : animationsData.push(close);
                            }
                            if (setupFallbackTimer) {
                                var timer = $timeout(onAnimationExpired, timerTime, !1);
                                animationsData[0] = {
                                    timer: timer,
                                    expectedEndTime: endTime
                                }, animationsData.push(close), element.data(ANIMATE_TIMER_KEY, animationsData);
                            }
                            events.length && element.on(events.join(" "), onAnimationProgress), options.to && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.to)), 
                            applyAnimationToStyles(element, options));
                        }
                    }
                    function onAnimationExpired() {
                        var animationsData = element.data(ANIMATE_TIMER_KEY);
                        if (animationsData) {
                            for (var i = 1; i < animationsData.length; i++) animationsData[i]();
                            element.removeData(ANIMATE_TIMER_KEY);
                        }
                    }
                    if (!animationClosed) {
                        if (!node.parentNode) return void close();
                        var playPause = function(playAnimation) {
                            if (animationCompleted) animationPaused && playAnimation && (animationPaused = !1, 
                            close()); else if (animationPaused = !playAnimation, timings.animationDuration) {
                                var value = blockKeyframeAnimations(node, animationPaused);
                                animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                            }
                        }, maxStagger = itemIndex > 0 && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                        maxStagger ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), !1) : triggerAnimationStart(), 
                        runnerHost.resume = function() {
                            playPause(!0);
                        }, runnerHost.pause = function() {
                            playPause(!1);
                        };
                    }
                }
                var options = initialOptions || {};
                options.$$prepared || (options = prepareAnimationOptions(copy(options)));
                var restoreStyles = {}, node = getDomNode(element);
                if (!node || !node.parentNode || !$$animateQueue.enabled()) return closeAndReturnNoopAnimator();
                var animationClosed, animationPaused, animationCompleted, runner, runnerHost, maxDelay, maxDelayTime, maxDuration, maxDurationTime, startTime, temporaryStyles = [], classes = element.attr("class"), styles = packageStyles(options), events = [];
                if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions) return closeAndReturnNoopAnimator();
                var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event, isStructural = method && options.structural, structuralClassName = "", addRemoveClassName = "";
                isStructural ? structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, !0) : method && (structuralClassName = method), 
                options.addClass && (addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX)), 
                options.removeClass && (addRemoveClassName.length && (addRemoveClassName += " "), 
                addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)), options.applyClassesEarly && addRemoveClassName.length && applyAnimationClasses(element, options);
                var preparationClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim(), fullClassName = classes + " " + preparationClasses, activeClasses = pendClasses(preparationClasses, "-active"), hasToStyles = styles.to && Object.keys(styles.to).length > 0;
                if (!((options.keyframeStyle || "").length > 0 || hasToStyles || preparationClasses)) return closeAndReturnNoopAnimator();
                var cacheKey, stagger;
                if (options.stagger > 0) {
                    var staggerVal = parseFloat(options.stagger);
                    stagger = {
                        transitionDelay: staggerVal,
                        animationDelay: staggerVal,
                        transitionDuration: 0,
                        animationDuration: 0
                    };
                } else cacheKey = gcsHashFn(node, fullClassName), stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                options.$$skipPreparationClasses || $$jqLite.addClass(element, preparationClasses);
                var applyOnlyDuration;
                if (options.transitionStyle) {
                    var transitionStyle = [ TRANSITION_PROP, options.transitionStyle ];
                    applyInlineStyle(node, transitionStyle), temporaryStyles.push(transitionStyle);
                }
                if (options.duration >= 0) {
                    applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                    var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                    applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle);
                }
                if (options.keyframeStyle) {
                    var keyframeStyle = [ ANIMATION_PROP, options.keyframeStyle ];
                    applyInlineStyle(node, keyframeStyle), temporaryStyles.push(keyframeStyle);
                }
                var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0, isFirst = 0 === itemIndex;
                isFirst && !options.skipBlocking && blockTransitions(node, 9999);
                var timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration;
                var flags = {};
                if (flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0, 
                flags.hasTransitionAll = flags.hasTransitions && "all" === timings.transitionProperty, 
                flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions), 
                flags.applyAnimationDuration = options.duration && flags.hasAnimations, flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions), 
                flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations, 
                flags.recalculateTimingStyles = addRemoveClassName.length > 0, (flags.applyTransitionDuration || flags.applyAnimationDuration) && (maxDuration = options.duration ? parseFloat(options.duration) : maxDuration, 
                flags.applyTransitionDuration && (flags.hasTransitions = !0, timings.transitionDuration = maxDuration, 
                applyOnlyDuration = node.style[TRANSITION_PROP + "Property"].length > 0, temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))), 
                flags.applyAnimationDuration && (flags.hasAnimations = !0, timings.animationDuration = maxDuration, 
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration)))), 0 === maxDuration && !flags.recalculateTimingStyles) return closeAndReturnNoopAnimator();
                if (null != options.delay) {
                    var delayStyle;
                    "boolean" != typeof options.delay && (delayStyle = parseFloat(options.delay), maxDelay = Math.max(delayStyle, 0)), 
                    flags.applyTransitionDelay && temporaryStyles.push(getCssDelayStyle(delayStyle)), 
                    flags.applyAnimationDelay && temporaryStyles.push(getCssDelayStyle(delayStyle, !0));
                }
                return null == options.duration && timings.transitionDuration > 0 && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst), 
                maxDelayTime = maxDelay * ONE_SECOND, maxDurationTime = maxDuration * ONE_SECOND, 
                options.skipBlocking || (flags.blockTransition = timings.transitionDuration > 0, 
                flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration), 
                options.from && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.from)), 
                applyAnimationFromStyles(element, options)), flags.blockTransition || flags.blockKeyframeAnimation ? applyBlocking(maxDuration) : options.skipBlocking || blockTransitions(node, !1), 
                {
                    $$willAnimate: !0,
                    end: endFn,
                    start: function() {
                        if (!animationClosed) return runnerHost = {
                            end: endFn,
                            cancel: cancelFn,
                            resume: null,
                            pause: null
                        }, runner = new $$AnimateRunner(runnerHost), waitUntilQuiet(start), runner;
                    }
                };
            };
        } ];
    } ], $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        function isDocumentFragment(node) {
            return node.parentNode && 11 === node.parentNode.nodeType;
        }
        $$animationProvider.drivers.push("$$animateCssDriver");
        var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim", NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
            function filterCssClasses(classes) {
                return classes.replace(/\bng-\S+\b/g, "");
            }
            function getUniqueValues(a, b) {
                return isString(a) && (a = a.split(" ")), isString(b) && (b = b.split(" ")), a.filter(function(val) {
                    return -1 === b.indexOf(val);
                }).join(" ");
            }
            function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                function calculateAnchorStyles(anchor) {
                    var styles = {}, coords = getDomNode(anchor).getBoundingClientRect();
                    return forEach([ "width", "height", "top", "left" ], function(key) {
                        var value = coords[key];
                        switch (key) {
                          case "top":
                            value += bodyNode.scrollTop;
                            break;

                          case "left":
                            value += bodyNode.scrollLeft;
                        }
                        styles[key] = Math.floor(value) + "px";
                    }), styles;
                }
                function getClassVal(element) {
                    return element.attr("class") || "";
                }
                function prepareInAnimation() {
                    var endingClasses = filterCssClasses(getClassVal(inAnchor)), toAdd = getUniqueValues(endingClasses, startingClasses), toRemove = getUniqueValues(startingClasses, endingClasses), animator = $animateCss(clone, {
                        to: calculateAnchorStyles(inAnchor),
                        addClass: "ng-anchor-in " + toAdd,
                        removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                        delay: !0
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function end() {
                    clone.remove(), outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                }
                var clone = jqLite(getDomNode(outAnchor).cloneNode(!0)), startingClasses = filterCssClasses(getClassVal(clone));
                outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), 
                clone.addClass("ng-anchor"), rootBodyElement.append(clone);
                var animatorIn, animatorOut = function() {
                    var animator = $animateCss(clone, {
                        addClass: NG_OUT_ANCHOR_CLASS_NAME,
                        delay: !0,
                        from: calculateAnchorStyles(outAnchor)
                    });
                    return animator.$$willAnimate ? animator : null;
                }();
                if (!animatorOut && !(animatorIn = prepareInAnimation())) return end();
                var startingAnimator = animatorOut || animatorIn;
                return {
                    start: function() {
                        function endFn() {
                            currentAnimation && currentAnimation.end();
                        }
                        var runner, currentAnimation = startingAnimator.start();
                        return currentAnimation.done(function() {
                            return currentAnimation = null, !animatorIn && (animatorIn = prepareInAnimation()) ? (currentAnimation = animatorIn.start(), 
                            currentAnimation.done(function() {
                                currentAnimation = null, end(), runner.complete();
                            }), currentAnimation) : (end(), void runner.complete());
                        }), runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                    }
                };
            }
            function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                var fromAnimation = prepareRegularAnimation(from), toAnimation = prepareRegularAnimation(to), anchorAnimations = [];
                if (forEach(anchors, function(anchor) {
                    var outElement = anchor.out, inElement = anchor.in, animator = prepareAnchoredAnimation(classes, outElement, inElement);
                    animator && anchorAnimations.push(animator);
                }), fromAnimation || toAnimation || 0 !== anchorAnimations.length) return {
                    start: function() {
                        function endFn() {
                            forEach(animationRunners, function(runner) {
                                runner.end();
                            });
                        }
                        var animationRunners = [];
                        fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                        forEach(anchorAnimations, function(animation) {
                            animationRunners.push(animation.start());
                        });
                        var runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                        return $$AnimateRunner.all(animationRunners, function(status) {
                            runner.complete(status);
                        }), runner;
                    }
                };
            }
            function prepareRegularAnimation(animationDetails) {
                var element = animationDetails.element, options = animationDetails.options || {};
                animationDetails.structural && (options.event = animationDetails.event, options.structural = !0, 
                options.applyClassesEarly = !0, "leave" === animationDetails.event && (options.onDone = options.domOperation)), 
                options.preparationClasses && (options.event = concatWithSpace(options.event, options.preparationClasses));
                var animator = $animateCss(element, options);
                return animator.$$willAnimate ? animator : null;
            }
            if (!$sniffer.animations && !$sniffer.transitions) return noop;
            var bodyNode = $document[0].body, rootNode = getDomNode($rootElement), rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
            return function(animationDetails) {
                return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
            };
        } ];
    } ], $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function($injector, $$AnimateRunner, $$jqLite) {
            function lookupAnimations(classes) {
                classes = isArray(classes) ? classes : classes.split(" ");
                for (var matches = [], flagMap = {}, i = 0; i < classes.length; i++) {
                    var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                    animationFactory && !flagMap[klass] && (matches.push($injector.get(animationFactory)), 
                    flagMap[klass] = !0);
                }
                return matches;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, classes, options) {
                function applyOptions() {
                    options.domOperation(), applyAnimationClasses(element, options);
                }
                function close() {
                    animationClosed = !0, applyOptions(), applyAnimationStyles(element, options);
                }
                function executeAnimationFn(fn, element, event, options, onDone) {
                    var args;
                    switch (event) {
                      case "animate":
                        args = [ element, options.from, options.to, onDone ];
                        break;

                      case "setClass":
                        args = [ element, classesToAdd, classesToRemove, onDone ];
                        break;

                      case "addClass":
                        args = [ element, classesToAdd, onDone ];
                        break;

                      case "removeClass":
                        args = [ element, classesToRemove, onDone ];
                        break;

                      default:
                        args = [ element, onDone ];
                    }
                    args.push(options);
                    var value = fn.apply(fn, args);
                    if (value) if (isFunction(value.start) && (value = value.start()), value instanceof $$AnimateRunner) value.done(onDone); else if (isFunction(value)) return value;
                    return noop;
                }
                function groupEventedAnimations(element, event, options, animations, fnName) {
                    var operations = [];
                    return forEach(animations, function(ani) {
                        var animation = ani[fnName];
                        animation && operations.push(function() {
                            var runner, endProgressCb, resolved = !1, onAnimationComplete = function(rejected) {
                                resolved || (resolved = !0, (endProgressCb || noop)(rejected), runner.complete(!rejected));
                            };
                            return runner = new $$AnimateRunner({
                                end: function() {
                                    onAnimationComplete();
                                },
                                cancel: function() {
                                    onAnimationComplete(!0);
                                }
                            }), endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                                onAnimationComplete(!1 === result);
                            }), runner;
                        });
                    }), operations;
                }
                function packageAnimations(element, event, options, animations, fnName) {
                    var operations = groupEventedAnimations(element, event, options, animations, fnName);
                    if (0 === operations.length) {
                        var a, b;
                        "beforeSetClass" === fnName ? (a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")) : "setClass" === fnName && (a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "addClass")), 
                        a && (operations = operations.concat(a)), b && (operations = operations.concat(b));
                    }
                    if (0 !== operations.length) return function(callback) {
                        var runners = [];
                        return operations.length && forEach(operations, function(animateFn) {
                            runners.push(animateFn());
                        }), runners.length ? $$AnimateRunner.all(runners, callback) : callback(), function(reject) {
                            forEach(runners, function(runner) {
                                reject ? runner.cancel() : runner.end();
                            });
                        };
                    };
                }
                var animationClosed = !1;
                3 === arguments.length && isObject(classes) && (options = classes, classes = null), 
                options = prepareAnimationOptions(options), classes || (classes = element.attr("class") || "", 
                options.addClass && (classes += " " + options.addClass), options.removeClass && (classes += " " + options.removeClass));
                var before, after, classesToAdd = options.addClass, classesToRemove = options.removeClass, animations = lookupAnimations(classes);
                if (animations.length) {
                    var afterFn, beforeFn;
                    "leave" === event ? (beforeFn = "leave", afterFn = "afterLeave") : (beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1), 
                    afterFn = event), "enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn)), 
                    after = packageAnimations(element, event, options, animations, afterFn);
                }
                if (before || after) {
                    var runner;
                    return {
                        $$willAnimate: !0,
                        end: function() {
                            return runner ? runner.end() : (close(), runner = new $$AnimateRunner(), runner.complete(!0)), 
                            runner;
                        },
                        start: function() {
                            function onComplete(success) {
                                close(success), runner.complete(success);
                            }
                            function endAnimations(cancelled) {
                                animationClosed || ((closeActiveAnimations || noop)(cancelled), onComplete(cancelled));
                            }
                            if (runner) return runner;
                            runner = new $$AnimateRunner();
                            var closeActiveAnimations, chain = [];
                            return before && chain.push(function(fn) {
                                closeActiveAnimations = before(fn);
                            }), chain.length ? chain.push(function(fn) {
                                applyOptions(), fn(!0);
                            }) : applyOptions(), after && chain.push(function(fn) {
                                closeActiveAnimations = after(fn);
                            }), runner.setHost({
                                end: function() {
                                    endAnimations();
                                },
                                cancel: function() {
                                    endAnimations(!0);
                                }
                            }), $$AnimateRunner.chain(chain, onComplete), runner;
                        }
                    };
                }
            };
        } ];
    } ], $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver"), this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
            function prepareAnimation(animationDetails) {
                var element = animationDetails.element, event = animationDetails.event, options = animationDetails.options, classes = animationDetails.classes;
                return $$animateJs(element, event, classes, options);
            }
            return function(animationDetails) {
                if (animationDetails.from && animationDetails.to) {
                    var fromAnimation = prepareAnimation(animationDetails.from), toAnimation = prepareAnimation(animationDetails.to);
                    if (!fromAnimation && !toAnimation) return;
                    return {
                        start: function() {
                            function endFnFactory() {
                                return function() {
                                    forEach(animationRunners, function(runner) {
                                        runner.end();
                                    });
                                };
                            }
                            function done(status) {
                                runner.complete(status);
                            }
                            var animationRunners = [];
                            fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                            $$AnimateRunner.all(animationRunners, done);
                            var runner = new $$AnimateRunner({
                                end: endFnFactory(),
                                cancel: endFnFactory()
                            });
                            return runner;
                        }
                    };
                }
                return prepareAnimation(animationDetails);
            };
        } ];
    } ], NG_ANIMATE_ATTR_NAME = "data-ng-animate", NG_ANIMATE_PIN_DATA = "$ngAnimatePin", $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
        function makeTruthyCssClassMap(classString) {
            if (!classString) return null;
            var keys = classString.split(ONE_SPACE), map = Object.create(null);
            return forEach(keys, function(key) {
                map[key] = !0;
            }), map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
            if (newClassString && currentClassString) {
                var currentClassMap = makeTruthyCssClassMap(currentClassString);
                return newClassString.split(ONE_SPACE).some(function(className) {
                    return currentClassMap[className];
                });
            }
        }
        function isAllowed(ruleType, currentAnimation, previousAnimation) {
            return rules[ruleType].some(function(fn) {
                return fn(currentAnimation, previousAnimation);
            });
        }
        function hasAnimationClasses(animation, and) {
            var a = (animation.addClass || "").length > 0, b = (animation.removeClass || "").length > 0;
            return and ? a && b : a || b;
        }
        var PRE_DIGEST_STATE = 1, RUNNING_STATE = 2, ONE_SPACE = " ", rules = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        rules.join.push(function(newAnimation, currentAnimation) {
            return !newAnimation.structural && hasAnimationClasses(newAnimation);
        }), rules.skip.push(function(newAnimation, currentAnimation) {
            return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        }), rules.skip.push(function(newAnimation, currentAnimation) {
            return "leave" === currentAnimation.event && newAnimation.structural;
        }), rules.skip.push(function(newAnimation, currentAnimation) {
            return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        }), rules.cancel.push(function(newAnimation, currentAnimation) {
            return currentAnimation.structural && newAnimation.structural;
        }), rules.cancel.push(function(newAnimation, currentAnimation) {
            return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        }), rules.cancel.push(function(newAnimation, currentAnimation) {
            if (currentAnimation.structural) return !1;
            var nA = newAnimation.addClass, nR = newAnimation.removeClass, cA = currentAnimation.addClass, cR = currentAnimation.removeClass;
            return !(isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR)) && (hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA));
        }), this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$Map", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function($$rAF, $rootScope, $rootElement, $document, $$Map, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden) {
            function postDigestTaskFactory() {
                var postDigestCalled = !1;
                return function(fn) {
                    postDigestCalled ? fn() : $rootScope.$$postDigest(function() {
                        postDigestCalled = !0, fn();
                    });
                };
            }
            function normalizeAnimationDetails(element, animation) {
                return mergeAnimationDetails(element, animation, {});
            }
            function findCallbacks(targetParentNode, targetNode, event) {
                var matches = [], entries = callbackRegistry[event];
                return entries && forEach(entries, function(entry) {
                    contains.call(entry.node, targetNode) ? matches.push(entry.callback) : "leave" === event && contains.call(entry.node, targetParentNode) && matches.push(entry.callback);
                }), matches;
            }
            function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                    return !(entry.node === containerNode && (!matchCallback || entry.callback === matchCallback));
                });
            }
            function cleanupEventListeners(phase, node) {
                "close" !== phase || node.parentNode || $animate.off(node);
            }
            function queueAnimation(originalElement, event, initialOptions) {
                function notifyProgress(runner, event, phase, data) {
                    runInNextPostDigestOrNow(function() {
                        var callbacks = findCallbacks(parentNode, node, event);
                        callbacks.length ? $$rAF(function() {
                            forEach(callbacks, function(callback) {
                                callback(element, phase, data);
                            }), cleanupEventListeners(phase, node);
                        }) : cleanupEventListeners(phase, node);
                    }), runner.progress(event, phase, data);
                }
                function close(reject) {
                    clearGeneratedClasses(element, options), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), runner.complete(!reject);
                }
                var options = copy(initialOptions), element = stripCommentsFromElement(originalElement), node = getDomNode(element), parentNode = node && node.parentNode;
                options = prepareAnimationOptions(options);
                var runner = new $$AnimateRunner(), runInNextPostDigestOrNow = postDigestTaskFactory();
                if (isArray(options.addClass) && (options.addClass = options.addClass.join(" ")), 
                options.addClass && !isString(options.addClass) && (options.addClass = null), isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" ")), 
                options.removeClass && !isString(options.removeClass) && (options.removeClass = null), 
                options.from && !isObject(options.from) && (options.from = null), options.to && !isObject(options.to) && (options.to = null), 
                !node) return close(), runner;
                var className = [ node.getAttribute("class"), options.addClass, options.removeClass ].join(" ");
                if (!isAnimatableClassName(className)) return close(), runner;
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, documentHidden = $$isDocumentHidden(), skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node), existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {}, hasExistingAnimation = !!existingAnimation.state;
                if (skipAnimations || hasExistingAnimation && existingAnimation.state === PRE_DIGEST_STATE || (skipAnimations = !areAnimationsAllowed(node, parentNode, event)), 
                skipAnimations) return documentHidden && notifyProgress(runner, event, "start"), 
                close(), documentHidden && notifyProgress(runner, event, "close"), runner;
                isStructural && closeChildAnimations(node);
                var newAnimation = {
                    structural: isStructural,
                    element: element,
                    event: event,
                    addClass: options.addClass,
                    removeClass: options.removeClass,
                    close: close,
                    options: options,
                    runner: runner
                };
                if (hasExistingAnimation) {
                    if (isAllowed("skip", newAnimation, existingAnimation)) return existingAnimation.state === RUNNING_STATE ? (close(), 
                    runner) : (mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner);
                    if (isAllowed("cancel", newAnimation, existingAnimation)) if (existingAnimation.state === RUNNING_STATE) existingAnimation.runner.end(); else {
                        if (!existingAnimation.structural) return mergeAnimationDetails(element, existingAnimation, newAnimation), 
                        existingAnimation.runner;
                        existingAnimation.close();
                    } else {
                        if (isAllowed("join", newAnimation, existingAnimation)) {
                            if (existingAnimation.state !== RUNNING_STATE) return applyGeneratedPreparationClasses(element, isStructural ? event : null, options), 
                            event = newAnimation.event = existingAnimation.event, options = mergeAnimationDetails(element, existingAnimation, newAnimation), 
                            existingAnimation.runner;
                            normalizeAnimationDetails(element, newAnimation);
                        }
                    }
                } else normalizeAnimationDetails(element, newAnimation);
                var isValidAnimation = newAnimation.structural;
                if (isValidAnimation || (isValidAnimation = "animate" === newAnimation.event && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation)), 
                !isValidAnimation) return close(), clearElementAnimationState(node), runner;
                var counter = (existingAnimation.counter || 0) + 1;
                return newAnimation.counter = counter, markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation), 
                $rootScope.$$postDigest(function() {
                    element = stripCommentsFromElement(originalElement);
                    var animationDetails = activeAnimationsLookup.get(node), animationCancelled = !animationDetails;
                    animationDetails = animationDetails || {};
                    var parentElement = element.parent() || [], isValidAnimation = parentElement.length > 0 && ("animate" === animationDetails.event || animationDetails.structural || hasAnimationClasses(animationDetails));
                    if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) return animationCancelled && (applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options)), (animationCancelled || isStructural && animationDetails.event !== event) && (options.domOperation(), 
                    runner.end()), void (isValidAnimation || clearElementAnimationState(node));
                    event = !animationDetails.structural && hasAnimationClasses(animationDetails, !0) ? "setClass" : animationDetails.event, 
                    markElementAnimationState(node, RUNNING_STATE);
                    var realRunner = $$animation(element, event, animationDetails.options);
                    runner.setHost(realRunner), notifyProgress(runner, event, "start", {}), realRunner.done(function(status) {
                        close(!status);
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails && animationDetails.counter === counter && clearElementAnimationState(node), 
                        notifyProgress(runner, event, "close", {});
                    });
                }), runner;
            }
            function closeChildAnimations(node) {
                var children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                forEach(children, function(child) {
                    var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10), animationDetails = activeAnimationsLookup.get(child);
                    if (animationDetails) switch (state) {
                      case RUNNING_STATE:
                        animationDetails.runner.end();

                      case PRE_DIGEST_STATE:
                        activeAnimationsLookup.delete(child);
                    }
                });
            }
            function clearElementAnimationState(node) {
                node.removeAttribute(NG_ANIMATE_ATTR_NAME), activeAnimationsLookup.delete(node);
            }
            function areAnimationsAllowed(node, parentNode, event) {
                var animateChildren, bodyNode = $document[0].body, rootNode = getDomNode($rootElement), bodyNodeDetected = node === bodyNode || "HTML" === node.nodeName, rootNodeDetected = node === rootNode, parentAnimationDetected = !1, elementDisabled = disabledElementsLookup.get(node), parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);
                for (parentHost && (parentNode = getDomNode(parentHost)); parentNode && (rootNodeDetected || (rootNodeDetected = parentNode === rootNode), 
                parentNode.nodeType === ELEMENT_NODE); ) {
                    var details = activeAnimationsLookup.get(parentNode) || {};
                    if (!parentAnimationDetected) {
                        var parentNodeDisabled = disabledElementsLookup.get(parentNode);
                        if (!0 === parentNodeDisabled && !1 !== elementDisabled) {
                            elementDisabled = !0;
                            break;
                        }
                        !1 === parentNodeDisabled && (elementDisabled = !1), parentAnimationDetected = details.structural;
                    }
                    if (isUndefined(animateChildren) || !0 === animateChildren) {
                        var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);
                        isDefined(value) && (animateChildren = value);
                    }
                    if (parentAnimationDetected && !1 === animateChildren) break;
                    if (bodyNodeDetected || (bodyNodeDetected = parentNode === bodyNode), bodyNodeDetected && rootNodeDetected) break;
                    parentNode = rootNodeDetected || !(parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA)) ? parentNode.parentNode : getDomNode(parentHost);
                }
                return (!parentAnimationDetected || animateChildren) && !0 !== elementDisabled && rootNodeDetected && bodyNodeDetected;
            }
            function markElementAnimationState(node, state, details) {
                details = details || {}, details.state = state, node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                var oldValue = activeAnimationsLookup.get(node), newValue = oldValue ? extend(oldValue, details) : details;
                activeAnimationsLookup.set(node, newValue);
            }
            var activeAnimationsLookup = new $$Map(), disabledElementsLookup = new $$Map(), animationsEnabled = null, deregisterWatch = $rootScope.$watch(function() {
                return 0 === $templateRequest.totalPendingRequests;
            }, function(isEmpty) {
                isEmpty && (deregisterWatch(), $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        null === animationsEnabled && (animationsEnabled = !0);
                    });
                }));
            }), callbackRegistry = Object.create(null), classNameFilter = $animateProvider.classNameFilter(), isAnimatableClassName = classNameFilter ? function(className) {
                return classNameFilter.test(className);
            } : function() {
                return !0;
            }, applyAnimationClasses = applyAnimationClassesFactory($$jqLite), contains = window.Node.prototype.contains || function(arg) {
                return this === arg || !!(16 & this.compareDocumentPosition(arg));
            }, $animate = {
                on: function(event, container, callback) {
                    var node = extractElementNode(container);
                    callbackRegistry[event] = callbackRegistry[event] || [], callbackRegistry[event].push({
                        node: node,
                        callback: callback
                    }), jqLite(container).on("$destroy", function() {
                        activeAnimationsLookup.get(node) || $animate.off(event, container, callback);
                    });
                },
                off: function(event, container, callback) {
                    if (1 !== arguments.length || isString(arguments[0])) {
                        var entries = callbackRegistry[event];
                        entries && (callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback));
                    } else {
                        container = arguments[0];
                        for (var eventType in callbackRegistry) callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                    }
                },
                pin: function(element, parentElement) {
                    assertArg(isElement(element), "element", "not an element"), assertArg(isElement(parentElement), "parentElement", "not an element"), 
                    element.data(NG_ANIMATE_PIN_DATA, parentElement);
                },
                push: function(element, event, options, domOperation) {
                    return options = options || {}, options.domOperation = domOperation, queueAnimation(element, event, options);
                },
                enabled: function(element, bool) {
                    var argCount = arguments.length;
                    if (0 === argCount) bool = !!animationsEnabled; else {
                        if (isElement(element)) {
                            var node = getDomNode(element);
                            1 === argCount ? bool = !disabledElementsLookup.get(node) : disabledElementsLookup.set(node, !bool);
                        } else bool = animationsEnabled = !!element;
                    }
                    return bool;
                }
            };
            return $animate;
        } ];
    } ], $$AnimationProvider = [ "$animateProvider", function($animateProvider) {
        function setRunner(element, runner) {
            element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
            element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
            return element.data(RUNNER_STORAGE_KEY);
        }
        var NG_ANIMATE_REF_ATTR = "ng-animate-ref", drivers = this.drivers = [], RUNNER_STORAGE_KEY = "$$animationRunner";
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$Map", "$$rAFScheduler", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler) {
            function sortAnimations(animations) {
                function processNode(entry) {
                    if (entry.processed) return entry;
                    entry.processed = !0;
                    var elementNode = entry.domNode, parentNode = elementNode.parentNode;
                    lookup.set(elementNode, entry);
                    for (var parentEntry; parentNode; ) {
                        if (parentEntry = lookup.get(parentNode)) {
                            parentEntry.processed || (parentEntry = processNode(parentEntry));
                            break;
                        }
                        parentNode = parentNode.parentNode;
                    }
                    return (parentEntry || tree).children.push(entry), entry;
                }
                var i, tree = {
                    children: []
                }, lookup = new $$Map();
                for (i = 0; i < animations.length; i++) {
                    var animation = animations[i];
                    lookup.set(animation.domNode, animations[i] = {
                        domNode: animation.domNode,
                        fn: animation.fn,
                        children: []
                    });
                }
                for (i = 0; i < animations.length; i++) processNode(animations[i]);
                return function(tree) {
                    var i, result = [], queue = [];
                    for (i = 0; i < tree.children.length; i++) queue.push(tree.children[i]);
                    var remainingLevelEntries = queue.length, nextLevelEntries = 0, row = [];
                    for (i = 0; i < queue.length; i++) {
                        var entry = queue[i];
                        remainingLevelEntries <= 0 && (remainingLevelEntries = nextLevelEntries, nextLevelEntries = 0, 
                        result.push(row), row = []), row.push(entry.fn), entry.children.forEach(function(childEntry) {
                            nextLevelEntries++, queue.push(childEntry);
                        }), remainingLevelEntries--;
                    }
                    return row.length && result.push(row), result;
                }(tree);
            }
            var animationQueue = [], applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, options) {
                function getAnchorNodes(node) {
                    var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]", items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [ node ] : node.querySelectorAll(SELECTOR), anchors = [];
                    return forEach(items, function(node) {
                        var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                        attr && attr.length && anchors.push(node);
                    }), anchors;
                }
                function groupAnimations(animations) {
                    var preparedAnimations = [], refLookup = {};
                    forEach(animations, function(animation, index) {
                        var element = animation.element, node = getDomNode(element), event = animation.event, enterOrMove = [ "enter", "move" ].indexOf(event) >= 0, anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                        if (anchorNodes.length) {
                            var direction = enterOrMove ? "to" : "from";
                            forEach(anchorNodes, function(anchor) {
                                var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                refLookup[key] = refLookup[key] || {}, refLookup[key][direction] = {
                                    animationID: index,
                                    element: jqLite(anchor)
                                };
                            });
                        } else preparedAnimations.push(animation);
                    });
                    var usedIndicesLookup = {}, anchorGroups = {};
                    return forEach(refLookup, function(operations, key) {
                        var from = operations.from, to = operations.to;
                        if (!from || !to) {
                            var index = from ? from.animationID : to.animationID, indexKey = index.toString();
                            return void (usedIndicesLookup[indexKey] || (usedIndicesLookup[indexKey] = !0, preparedAnimations.push(animations[index])));
                        }
                        var fromAnimation = animations[from.animationID], toAnimation = animations[to.animationID], lookupKey = from.animationID.toString();
                        if (!anchorGroups[lookupKey]) {
                            var group = anchorGroups[lookupKey] = {
                                structural: !0,
                                beforeStart: function() {
                                    fromAnimation.beforeStart(), toAnimation.beforeStart();
                                },
                                close: function() {
                                    fromAnimation.close(), toAnimation.close();
                                },
                                classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                from: fromAnimation,
                                to: toAnimation,
                                anchors: []
                            };
                            group.classes.length ? preparedAnimations.push(group) : (preparedAnimations.push(fromAnimation), 
                            preparedAnimations.push(toAnimation));
                        }
                        anchorGroups[lookupKey].anchors.push({
                            out: from.element,
                            in: to.element
                        });
                    }), preparedAnimations;
                }
                function cssClassesIntersection(a, b) {
                    a = a.split(" "), b = b.split(" ");
                    for (var matches = [], i = 0; i < a.length; i++) {
                        var aa = a[i];
                        if ("ng-" !== aa.substring(0, 3)) for (var j = 0; j < b.length; j++) if (aa === b[j]) {
                            matches.push(aa);
                            break;
                        }
                    }
                    return matches.join(" ");
                }
                function invokeFirstDriver(animationDetails) {
                    for (var i = drivers.length - 1; i >= 0; i--) {
                        var driverName = drivers[i], factory = $injector.get(driverName), driver = factory(animationDetails);
                        if (driver) return driver;
                    }
                }
                function beforeStart() {
                    element.addClass(NG_ANIMATE_CLASSNAME), tempClasses && $$jqLite.addClass(element, tempClasses), 
                    prepareClassName && ($$jqLite.removeClass(element, prepareClassName), prepareClassName = null);
                }
                function updateAnimationRunners(animation, newRunner) {
                    function update(element) {
                        var runner = getRunner(element);
                        runner && runner.setHost(newRunner);
                    }
                    animation.from && animation.to ? (update(animation.from.element), update(animation.to.element)) : update(animation.element);
                }
                function handleDestroyedElement() {
                    var runner = getRunner(element);
                    !runner || "leave" === event && options.$$domOperationFired || runner.end();
                }
                function close(rejected) {
                    element.off("$destroy", handleDestroyedElement), removeRunner(element), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), tempClasses && $$jqLite.removeClass(element, tempClasses), 
                    element.removeClass(NG_ANIMATE_CLASSNAME), runner.complete(!rejected);
                }
                options = prepareAnimationOptions(options);
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, runner = new $$AnimateRunner({
                    end: function() {
                        close();
                    },
                    cancel: function() {
                        close(!0);
                    }
                });
                if (!drivers.length) return close(), runner;
                setRunner(element, runner);
                var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass)), tempClasses = options.tempClasses;
                tempClasses && (classes += " " + tempClasses, options.tempClasses = null);
                var prepareClassName;
                return isStructural && (prepareClassName = "ng-" + event + "-prepare", $$jqLite.addClass(element, prepareClassName)), 
                animationQueue.push({
                    element: element,
                    classes: classes,
                    event: event,
                    structural: isStructural,
                    options: options,
                    beforeStart: beforeStart,
                    close: close
                }), element.on("$destroy", handleDestroyedElement), animationQueue.length > 1 ? runner : ($rootScope.$$postDigest(function() {
                    var animations = [];
                    forEach(animationQueue, function(entry) {
                        getRunner(entry.element) ? animations.push(entry) : entry.close();
                    }), animationQueue.length = 0;
                    var groupedAnimations = groupAnimations(animations), toBeSortedAnimations = [];
                    forEach(groupedAnimations, function(animationEntry) {
                        toBeSortedAnimations.push({
                            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                            fn: function() {
                                animationEntry.beforeStart();
                                var startAnimationFn, closeFn = animationEntry.close;
                                if (getRunner(animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element)) {
                                    var operation = invokeFirstDriver(animationEntry);
                                    operation && (startAnimationFn = operation.start);
                                }
                                if (startAnimationFn) {
                                    var animationRunner = startAnimationFn();
                                    animationRunner.done(function(status) {
                                        closeFn(!status);
                                    }), updateAnimationRunners(animationEntry, animationRunner);
                                } else closeFn();
                            }
                        });
                    }), $$rAFScheduler(sortAnimations(toBeSortedAnimations));
                }), runner);
            };
        } ];
    } ], ngAnimateSwapDirective = [ "$animate", "$rootScope", function($animate, $rootScope) {
        return {
            restrict: "A",
            transclude: "element",
            terminal: !0,
            priority: 600,
            link: function(scope, $element, attrs, ctrl, $transclude) {
                var previousElement, previousScope;
                scope.$watchCollection(attrs.ngAnimateSwap || attrs.for, function(value) {
                    previousElement && $animate.leave(previousElement), previousScope && (previousScope.$destroy(), 
                    previousScope = null), (value || 0 === value) && (previousScope = scope.$new(), 
                    $transclude(previousScope, function(element) {
                        previousElement = element, $animate.enter(element, null, $element);
                    }));
                });
            }
        };
    } ];
    angular.module("ngAnimate", [], function() {
        noop = angular.noop, copy = angular.copy, extend = angular.extend, jqLite = angular.element, 
        forEach = angular.forEach, isArray = angular.isArray, isString = angular.isString, 
        isObject = angular.isObject, isUndefined = angular.isUndefined, isDefined = angular.isDefined, 
        isFunction = angular.isFunction, isElement = angular.isElement;
    }).info({
        angularVersion: "1.6.4"
    }).directive("ngAnimateSwap", ngAnimateSwapDirective).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", $$rAFSchedulerFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
}(window, window.angular), define("angular-animate", [ "angular" ], function() {}), 
function() {
    "use strict";
    function toastr($animate, $injector, $document, $rootScope, $sce, toastrConfig, $q) {
        function active() {
            return toasts.length;
        }
        function clear(toast) {
            if (1 !== arguments.length || toast) if (toast) remove(toast.toastId); else for (var i = 0; i < toasts.length; i++) remove(toasts[i].toastId);
        }
        function error(message, title, optionsOverride) {
            return _buildNotification(_getOptions().iconClasses.error, message, title, optionsOverride);
        }
        function info(message, title, optionsOverride) {
            return _buildNotification(_getOptions().iconClasses.info, message, title, optionsOverride);
        }
        function success(message, title, optionsOverride) {
            return _buildNotification(_getOptions().iconClasses.success, message, title, optionsOverride);
        }
        function warning(message, title, optionsOverride) {
            return _buildNotification(_getOptions().iconClasses.warning, message, title, optionsOverride);
        }
        function refreshTimer(toast, newTime) {
            toast && toast.isOpened && toasts.indexOf(toast) >= 0 && toast.scope.refreshTimer(newTime);
        }
        function remove(toastId, wasClicked) {
            function lastToast() {
                return !toasts.length;
            }
            var toast = function(toastId) {
                for (var i = 0; i < toasts.length; i++) if (toasts[i].toastId === toastId) return toasts[i];
            }(toastId);
            toast && !toast.deleting && (toast.deleting = !0, toast.isOpened = !1, $animate.leave(toast.el).then(function() {
                toast.scope.options.onHidden && toast.scope.options.onHidden(!!wasClicked, toast), 
                toast.scope.$destroy();
                var index = toasts.indexOf(toast);
                delete openToasts[toast.scope.message], toasts.splice(index, 1);
                var maxOpened = toastrConfig.maxOpened;
                maxOpened && toasts.length >= maxOpened && toasts[maxOpened - 1].open.resolve(), 
                lastToast() && (container.remove(), container = null, containerDefer = $q.defer());
            }));
        }
        function _buildNotification(type, message, title, optionsOverride) {
            return angular.isObject(title) && (optionsOverride = title, title = null), _notify({
                iconClass: type,
                message: message,
                optionsOverride: optionsOverride,
                title: title
            });
        }
        function _getOptions() {
            return angular.extend({}, toastrConfig);
        }
        function _createOrGetContainer(options) {
            if (container) return containerDefer.promise;
            container = angular.element("<div></div>"), container.attr("id", options.containerId), 
            container.addClass(options.positionClass), container.css({
                "pointer-events": "auto"
            });
            var target = angular.element(document.querySelector(options.target));
            if (!target || !target.length) throw "Target for toasts doesn't exist";
            return $animate.enter(container, target).then(function() {
                containerDefer.resolve();
            }), containerDefer.promise;
        }
        function _notify(map) {
            function createScope(toast, map, options) {
                function generateEvent(event) {
                    if (options[event]) return function() {
                        options[event](toast);
                    };
                }
                options.allowHtml ? (toast.scope.allowHtml = !0, toast.scope.title = $sce.trustAsHtml(map.title), 
                toast.scope.message = $sce.trustAsHtml(map.message)) : (toast.scope.title = map.title, 
                toast.scope.message = map.message), toast.scope.toastType = toast.iconClass, toast.scope.toastId = toast.toastId, 
                toast.scope.extraData = options.extraData, toast.scope.options = {
                    extendedTimeOut: options.extendedTimeOut,
                    messageClass: options.messageClass,
                    onHidden: options.onHidden,
                    onShown: generateEvent("onShown"),
                    onTap: generateEvent("onTap"),
                    progressBar: options.progressBar,
                    tapToDismiss: options.tapToDismiss,
                    timeOut: options.timeOut,
                    titleClass: options.titleClass,
                    toastClass: options.toastClass
                }, options.closeButton && (toast.scope.options.closeHtml = options.closeHtml);
            }
            function createToastEl(scope) {
                var angularDomEl = angular.element("<div toast></div>");
                return $injector.get("$compile")(angularDomEl)(scope);
            }
            var options = _getOptions();
            if (!function() {
                var isDuplicateOfLast = options.preventDuplicates && map.message === previousToastMessage, isDuplicateOpen = options.preventOpenDuplicates && openToasts[map.message];
                return !(!isDuplicateOfLast && !isDuplicateOpen && (previousToastMessage = map.message, 
                openToasts[map.message] = !0, 1));
            }()) {
                var newToast = function() {
                    var newToast = {
                        toastId: index++,
                        isOpened: !1,
                        scope: $rootScope.$new(),
                        open: $q.defer()
                    };
                    return newToast.iconClass = map.iconClass, map.optionsOverride && (angular.extend(options, function(options) {
                        for (var badOptions = [ "containerId", "iconClasses", "maxOpened", "newestOnTop", "positionClass", "preventDuplicates", "preventOpenDuplicates", "templates" ], i = 0, l = badOptions.length; i < l; i++) delete options[badOptions[i]];
                        return options;
                    }(map.optionsOverride)), newToast.iconClass = map.optionsOverride.iconClass || newToast.iconClass), 
                    createScope(newToast, map, options), newToast.el = createToastEl(newToast.scope), 
                    newToast;
                }();
                if (toasts.push(newToast), function() {
                    return options.autoDismiss && options.maxOpened && toasts.length > options.maxOpened;
                }()) for (var oldToasts = toasts.slice(0, toasts.length - options.maxOpened), i = 0, len = oldToasts.length; i < len; i++) remove(oldToasts[i].toastId);
                return function() {
                    return options.maxOpened && toasts.length <= options.maxOpened || !options.maxOpened;
                }() && newToast.open.resolve(), newToast.open.promise.then(function() {
                    _createOrGetContainer(options).then(function() {
                        if (newToast.isOpened = !0, options.newestOnTop) $animate.enter(newToast.el, container).then(function() {
                            newToast.scope.init();
                        }); else {
                            var sibling = container[0].lastChild ? angular.element(container[0].lastChild) : null;
                            $animate.enter(newToast.el, container, sibling).then(function() {
                                newToast.scope.init();
                            });
                        }
                    });
                }), newToast;
            }
        }
        var container, index = 0, toasts = [], previousToastMessage = "", openToasts = {}, containerDefer = $q.defer();
        return {
            active: active,
            clear: clear,
            error: error,
            info: info,
            remove: remove,
            success: success,
            warning: warning,
            refreshTimer: refreshTimer
        };
    }
    angular.module("toastr", []).factory("toastr", toastr), toastr.$inject = [ "$animate", "$injector", "$document", "$rootScope", "$sce", "toastrConfig", "$q" ];
}(), function() {
    "use strict";
    angular.module("toastr").constant("toastrConfig", {
        allowHtml: !1,
        autoDismiss: !1,
        closeButton: !1,
        closeHtml: "<button>&times;</button>",
        containerId: "toast-container",
        extendedTimeOut: 1e3,
        iconClasses: {
            error: "toast-error",
            info: "toast-info",
            success: "toast-success",
            warning: "toast-warning"
        },
        maxOpened: 0,
        messageClass: "toast-message",
        newestOnTop: !0,
        onHidden: null,
        onShown: null,
        onTap: null,
        positionClass: "toast-top-right",
        preventDuplicates: !1,
        preventOpenDuplicates: !1,
        progressBar: !1,
        tapToDismiss: !0,
        target: "body",
        templates: {
            toast: "directives/toast/toast.html",
            progressbar: "directives/progressbar/progressbar.html"
        },
        timeOut: 5e3,
        titleClass: "toast-title",
        toastClass: "toast"
    });
}(), function() {
    "use strict";
    function progressBar(toastrConfig) {
        function linkFunction(scope, element, attrs, toastCtrl) {
            function updateProgress() {
                var percentage = (hideTime - new Date().getTime()) / currentTimeOut * 100;
                element.css("width", percentage + "%");
            }
            var intervalId, currentTimeOut, hideTime;
            toastCtrl.progressBar = scope, scope.start = function(duration) {
                intervalId && clearInterval(intervalId), currentTimeOut = parseFloat(duration), 
                hideTime = new Date().getTime() + currentTimeOut, intervalId = setInterval(updateProgress, 10);
            }, scope.stop = function() {
                intervalId && clearInterval(intervalId);
            }, scope.$on("$destroy", function() {
                clearInterval(intervalId);
            });
        }
        return {
            require: "^toast",
            templateUrl: function() {
                return toastrConfig.templates.progressbar;
            },
            link: linkFunction
        };
    }
    angular.module("toastr").directive("progressBar", progressBar), progressBar.$inject = [ "toastrConfig" ];
}(), function() {
    "use strict";
    function ToastController() {
        this.progressBar = null, this.startProgressBar = function(duration) {
            this.progressBar && this.progressBar.start(duration);
        }, this.stopProgressBar = function() {
            this.progressBar && this.progressBar.stop();
        };
    }
    angular.module("toastr").controller("ToastController", ToastController);
}(), function() {
    "use strict";
    function toast($injector, $interval, toastrConfig, toastr) {
        function toastLinkFunction(scope, element, attrs, toastCtrl) {
            function createTimeout(time) {
                return toastCtrl.startProgressBar(time), $interval(function() {
                    toastCtrl.stopProgressBar(), toastr.remove(scope.toastId);
                }, time, 1);
            }
            function hideAndStopProgressBar() {
                scope.progressBar = !1, toastCtrl.stopProgressBar();
            }
            var timeout;
            if (scope.toastClass = scope.options.toastClass, scope.titleClass = scope.options.titleClass, 
            scope.messageClass = scope.options.messageClass, scope.progressBar = scope.options.progressBar, 
            function() {
                return scope.options.closeHtml;
            }()) {
                var button = angular.element(scope.options.closeHtml), $compile = $injector.get("$compile");
                button.addClass("toast-close-button"), button.attr("ng-click", "close(true, $event)"), 
                $compile(button)(scope), element.children().prepend(button);
            }
            scope.init = function() {
                scope.options.timeOut && (timeout = createTimeout(scope.options.timeOut)), scope.options.onShown && scope.options.onShown();
            }, element.on("mouseenter", function() {
                hideAndStopProgressBar(), timeout && $interval.cancel(timeout);
            }), scope.tapToast = function() {
                angular.isFunction(scope.options.onTap) && scope.options.onTap(), scope.options.tapToDismiss && scope.close(!0);
            }, scope.close = function(wasClicked, $event) {
                $event && angular.isFunction($event.stopPropagation) && $event.stopPropagation(), 
                toastr.remove(scope.toastId, wasClicked);
            }, scope.refreshTimer = function(newTime) {
                timeout && ($interval.cancel(timeout), timeout = createTimeout(newTime || scope.options.timeOut));
            }, element.on("mouseleave", function() {
                0 === scope.options.timeOut && 0 === scope.options.extendedTimeOut || (scope.$apply(function() {
                    scope.progressBar = scope.options.progressBar;
                }), timeout = createTimeout(scope.options.extendedTimeOut));
            });
        }
        return {
            templateUrl: function() {
                return toastrConfig.templates.toast;
            },
            controller: "ToastController",
            link: toastLinkFunction
        };
    }
    angular.module("toastr").directive("toast", toast), toast.$inject = [ "$injector", "$interval", "toastrConfig", "toastr" ];
}(), angular.module("toastr").run([ "$templateCache", function($templateCache) {
    $templateCache.put("directives/progressbar/progressbar.html", '<div class="toast-progress"></div>\n'), 
    $templateCache.put("directives/toast/toast.html", '<div class="{{toastClass}} {{toastType}}" ng-click="tapToast()">\n  <div ng-switch on="allowHtml">\n    <div ng-switch-default ng-if="title" class="{{titleClass}}" aria-label="{{title}}">{{title}}</div>\n    <div ng-switch-default class="{{messageClass}}" aria-label="{{message}}">{{message}}</div>\n    <div ng-switch-when="true" ng-if="title" class="{{titleClass}}" ng-bind-html="title"></div>\n    <div ng-switch-when="true" class="{{messageClass}}" ng-bind-html="message"></div>\n  </div>\n  <progress-bar ng-if="progressBar"></progress-bar>\n</div>\n');
} ]), define("angular-toastr", [ "angular" ], function() {}), function() {
    angular.module("angular-jwt", [ "angular-jwt.options", "angular-jwt.interceptor", "angular-jwt.jwt", "angular-jwt.authManager" ]), 
    angular.module("angular-jwt.authManager", []).provider("authManager", function() {
        this.$get = [ "$rootScope", "$injector", "$location", "jwtHelper", "jwtInterceptor", "jwtOptions", function($rootScope, $injector, $location, jwtHelper, jwtInterceptor, jwtOptions) {
            function invokeToken(tokenGetter) {
                return Array.isArray(tokenGetter) ? $injector.invoke(tokenGetter, this, {
                    options: null
                }) : tokenGetter();
            }
            function invokeRedirector(redirector) {
                if (Array.isArray(redirector) || angular.isFunction(redirector)) return $injector.invoke(redirector, config, {});
                throw new Error("unauthenticatedRedirector must be a function");
            }
            function isAuthenticated() {
                var token = invokeToken(config.tokenGetter);
                if (token) return !jwtHelper.isTokenExpired(token);
            }
            function authenticate() {
                $rootScope.isAuthenticated = !0;
            }
            function unauthenticate() {
                $rootScope.isAuthenticated = !1;
            }
            function checkAuthOnRefresh() {
                $rootScope.$on("$locationChangeStart", function() {
                    var token = invokeToken(config.tokenGetter);
                    token && (jwtHelper.isTokenExpired(token) ? $rootScope.$broadcast("tokenHasExpired", token) : authenticate());
                });
            }
            function redirectWhenUnauthenticated() {
                $rootScope.$on("unauthenticated", function() {
                    invokeRedirector(config.unauthenticatedRedirector), unauthenticate();
                });
            }
            function verifyRoute(event, next) {
                if (!next) return !1;
                var routeData = next.$$route ? next.$$route : next.data;
                if (routeData && !0 === routeData.requiresLogin) {
                    var token = invokeToken(config.tokenGetter);
                    token && !jwtHelper.isTokenExpired(token) || (event.preventDefault(), invokeRedirector(config.unauthenticatedRedirector));
                }
            }
            var config = jwtOptions.getConfig();
            $rootScope.isAuthenticated = !1;
            var eventName = $injector.has("$state") ? "$stateChangeStart" : "$routeChangeStart";
            return $rootScope.$on(eventName, verifyRoute), {
                authenticate: authenticate,
                unauthenticate: unauthenticate,
                getToken: function() {
                    return invokeToken(config.tokenGetter);
                },
                redirect: function() {
                    return invokeRedirector(config.unauthenticatedRedirector);
                },
                checkAuthOnRefresh: checkAuthOnRefresh,
                redirectWhenUnauthenticated: redirectWhenUnauthenticated,
                isAuthenticated: isAuthenticated
            };
        } ];
    }), angular.module("angular-jwt.interceptor", []).provider("jwtInterceptor", function() {
        this.urlParam, this.authHeader, this.authPrefix, this.whiteListedDomains, this.tokenGetter;
        var config = this;
        this.$get = [ "$q", "$injector", "$rootScope", "urlUtils", "jwtOptions", function($q, $injector, $rootScope, urlUtils, jwtOptions) {
            function isSafe(url) {
                if (!urlUtils.isSameOrigin(url) && !options.whiteListedDomains.length) throw new Error("As of v0.1.0, requests to domains other than the application's origin must be white listed. Use jwtOptionsProvider.config({ whiteListedDomains: [<domain>] }); to whitelist.");
                for (var hostname = urlUtils.urlResolve(url).hostname.toLowerCase(), i = 0; i < options.whiteListedDomains.length; i++) {
                    var domain = options.whiteListedDomains[i], regexp = domain instanceof RegExp ? domain : new RegExp(domain, "i");
                    if (hostname.match(regexp)) return !0;
                }
                return !!urlUtils.isSameOrigin(url);
            }
            var options = angular.extend({}, jwtOptions.getConfig(), config);
            return {
                request: function(request) {
                    if (request.skipAuthorization || !isSafe(request.url)) return request;
                    if (options.urlParam) {
                        if (request.params = request.params || {}, request.params[options.urlParam]) return request;
                    } else if (request.headers = request.headers || {}, request.headers[options.authHeader]) return request;
                    return $q.when($injector.invoke(options.tokenGetter, this, {
                        options: request
                    })).then(function(token) {
                        return token && (options.urlParam ? request.params[options.urlParam] = token : request.headers[options.authHeader] = options.authPrefix + token), 
                        request;
                    });
                },
                responseError: function(response) {
                    return 401 === response.status && $rootScope.$broadcast("unauthenticated", response), 
                    $q.reject(response);
                }
            };
        } ];
    }), angular.module("angular-jwt.jwt", []).service("jwtHelper", [ "$window", function($window) {
        this.urlBase64Decode = function(str) {
            var output = str.replace(/-/g, "+").replace(/_/g, "/");
            switch (output.length % 4) {
              case 0:
                break;

              case 2:
                output += "==";
                break;

              case 3:
                output += "=";
                break;

              default:
                throw "Illegal base64url string!";
            }
            return $window.decodeURIComponent(escape($window.atob(output)));
        }, this.decodeToken = function(token) {
            var parts = token.split(".");
            if (3 !== parts.length) throw new Error("JWT must have 3 parts");
            var decoded = this.urlBase64Decode(parts[1]);
            if (!decoded) throw new Error("Cannot decode the token");
            return angular.fromJson(decoded);
        }, this.getTokenExpirationDate = function(token) {
            var decoded = this.decodeToken(token);
            if (void 0 === decoded.exp) return null;
            var d = new Date(0);
            return d.setUTCSeconds(decoded.exp), d;
        }, this.isTokenExpired = function(token, offsetSeconds) {
            var d = this.getTokenExpirationDate(token);
            return offsetSeconds = offsetSeconds || 0, null !== d && !(d.valueOf() > new Date().valueOf() + 1e3 * offsetSeconds);
        };
    } ]), angular.module("angular-jwt.options", []).provider("jwtOptions", function() {
        var globalConfig = {};
        this.config = function(value) {
            globalConfig = value;
        }, this.$get = function() {
            function JwtOptions() {
                this.config = angular.extend({}, options, globalConfig);
            }
            var options = {
                urlParam: null,
                authHeader: "Authorization",
                authPrefix: "Bearer ",
                whiteListedDomains: [],
                tokenGetter: function() {
                    return null;
                },
                loginPath: "/",
                unauthenticatedRedirectPath: "/",
                unauthenticatedRedirector: [ "$location", function($location) {
                    $location.path(this.unauthenticatedRedirectPath);
                } ]
            };
            return JwtOptions.prototype.getConfig = function() {
                return this.config;
            }, new JwtOptions();
        };
    }), angular.module("angular-jwt.interceptor").service("urlUtils", function() {
        function urlResolve(url) {
            var href = url;
            return urlParsingNode.setAttribute("href", href), href = urlParsingNode.href, urlParsingNode.setAttribute("href", href), 
            {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
        }
        function urlIsSameOrigin(requestUrl) {
            var parsed = angular.isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
            return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
        }
        var urlParsingNode = document.createElement("a"), originUrl = urlResolve(window.location.href);
        return {
            urlResolve: urlResolve,
            isSameOrigin: urlIsSameOrigin
        };
    });
}(), define("angular-jwt", [ "angular" ], function() {}), angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.multiMap", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead" ]), 
angular.module("ui.bootstrap.tpls", [ "uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html" ]), 
angular.module("ui.bootstrap.collapse", []).directive("uibCollapse", [ "$animate", "$q", "$parse", "$injector", function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has("$animateCss") ? $injector.get("$animateCss") : null;
    return {
        link: function(scope, element, attrs) {
            function getScrollFromElement(element) {
                return horizontal ? {
                    width: element.scrollWidth + "px"
                } : {
                    height: element.scrollHeight + "px"
                };
            }
            function expand() {
                element.hasClass("collapse") && element.hasClass("in") || $q.resolve(expandingExpr(scope)).then(function() {
                    element.removeClass("collapse").addClass("collapsing").attr("aria-expanded", !0).attr("aria-hidden", !1), 
                    $animateCss ? $animateCss(element, {
                        addClass: "in",
                        easing: "ease",
                        css: {
                            overflow: "hidden"
                        },
                        to: getScrollFromElement(element[0])
                    }).start().finally(expandDone) : $animate.addClass(element, "in", {
                        css: {
                            overflow: "hidden"
                        },
                        to: getScrollFromElement(element[0])
                    }).then(expandDone);
                }, angular.noop);
            }
            function expandDone() {
                element.removeClass("collapsing").addClass("collapse").css(css), expandedExpr(scope);
            }
            function collapse() {
                return element.hasClass("collapse") || element.hasClass("in") ? void $q.resolve(collapsingExpr(scope)).then(function() {
                    element.css(getScrollFromElement(element[0])).removeClass("collapse").addClass("collapsing").attr("aria-expanded", !1).attr("aria-hidden", !0), 
                    $animateCss ? $animateCss(element, {
                        removeClass: "in",
                        to: cssTo
                    }).start().finally(collapseDone) : $animate.removeClass(element, "in", {
                        to: cssTo
                    }).then(collapseDone);
                }, angular.noop) : collapseDone();
            }
            function collapseDone() {
                element.css(cssTo), element.removeClass("collapsing").addClass("collapse"), collapsedExpr(scope);
            }
            var expandingExpr = $parse(attrs.expanding), expandedExpr = $parse(attrs.expanded), collapsingExpr = $parse(attrs.collapsing), collapsedExpr = $parse(attrs.collapsed), horizontal = !1, css = {}, cssTo = {};
            (function() {
                horizontal = !!("horizontal" in attrs), horizontal ? (css = {
                    width: ""
                }, cssTo = {
                    width: "0"
                }) : (css = {
                    height: ""
                }, cssTo = {
                    height: "0"
                }), scope.$eval(attrs.uibCollapse) || element.addClass("in").addClass("collapse").attr("aria-expanded", !0).attr("aria-hidden", !1).css(css);
            })(), scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
                shouldCollapse ? collapse() : expand();
            });
        }
    };
} ]), angular.module("ui.bootstrap.tabindex", []).directive("uibTabindexToggle", function() {
    return {
        restrict: "A",
        link: function(scope, elem, attrs) {
            attrs.$observe("disabled", function(disabled) {
                attrs.$set("tabindex", disabled ? -1 : null);
            });
        }
    };
}), angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse", "ui.bootstrap.tabindex" ]).constant("uibAccordionConfig", {
    closeOthers: !0
}).controller("UibAccordionController", [ "$scope", "$attrs", "uibAccordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [], this.closeOthers = function(openGroup) {
        (angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers) && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1);
        });
    }, this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope), groupScope.$on("$destroy", function(event) {
            that.removeGroup(groupScope);
        });
    }, this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        -1 !== index && this.groups.splice(index, 1);
    };
} ]).directive("uibAccordion", function() {
    return {
        controller: "UibAccordionController",
        controllerAs: "accordion",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/accordion/accordion.html";
        }
    };
}).directive("uibAccordionGroup", function() {
    return {
        require: "^uibAccordion",
        transclude: !0,
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/accordion/accordion-group.html";
        },
        scope: {
            heading: "@",
            panelClass: "@?",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            element.addClass("panel"), accordionCtrl.addGroup(scope), scope.openClass = attrs.openClass || "panel-open", 
            scope.panelClass = attrs.panelClass || "panel-default", scope.$watch("isOpen", function(value) {
                element.toggleClass(scope.openClass, !!value), value && accordionCtrl.closeOthers(scope);
            }), scope.toggleOpen = function($event) {
                scope.isDisabled || $event && 32 !== $event.which || (scope.isOpen = !scope.isOpen);
            };
            var id = "accordiongroup-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
            scope.headingId = id + "-tab", scope.panelId = id + "-panel";
        }
    };
}).directive("uibAccordionHeading", function() {
    return {
        transclude: !0,
        template: "",
        replace: !0,
        require: "^uibAccordionGroup",
        link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
}).directive("uibAccordionTransclude", function() {
    return {
        require: "^uibAccordionGroup",
        link: function(scope, element, attrs, controller) {
            scope.$watch(function() {
                return controller[attrs.uibAccordionTransclude];
            }, function(heading) {
                if (heading) {
                    var elem = angular.element(element[0].querySelector("uib-accordion-header,data-uib-accordion-header,x-uib-accordion-header,uib\\:accordion-header,[uib-accordion-header],[data-uib-accordion-header],[x-uib-accordion-header]"));
                    elem.html(""), elem.append(heading);
                }
            });
        }
    };
}), angular.module("ui.bootstrap.alert", []).controller("UibAlertController", [ "$scope", "$element", "$attrs", "$interpolate", "$timeout", function($scope, $element, $attrs, $interpolate, $timeout) {
    $scope.closeable = !!$attrs.close, $element.addClass("alert"), $attrs.$set("role", "alert"), 
    $scope.closeable && $element.addClass("alert-dismissible");
    var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
    dismissOnTimeout && $timeout(function() {
        $scope.close();
    }, parseInt(dismissOnTimeout, 10));
} ]).directive("uibAlert", function() {
    return {
        controller: "UibAlertController",
        controllerAs: "alert",
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/alert/alert.html";
        },
        transclude: !0,
        scope: {
            close: "&"
        }
    };
}), angular.module("ui.bootstrap.buttons", []).constant("uibButtonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("UibButtonsController", [ "uibButtonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active", this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("uibBtnRadio", [ "$parse", function($parse) {
    return {
        require: [ "uibBtnRadio", "ngModel" ],
        controller: "UibButtonsController",
        controllerAs: "buttons",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1], uncheckableExpr = $parse(attrs.uibUncheckable);
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
            }, element.on(buttonsCtrl.toggleEvent, function() {
                if (!attrs.disabled) {
                    var isActive = element.hasClass(buttonsCtrl.activeClass);
                    isActive && !angular.isDefined(attrs.uncheckable) || scope.$apply(function() {
                        ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio)), ngModelCtrl.$render();
                    });
                }
            }), attrs.uibUncheckable && scope.$watch(uncheckableExpr, function(uncheckable) {
                attrs.$set("uncheckable", uncheckable ? "" : void 0);
            });
        }
    };
} ]).directive("uibBtnCheckbox", function() {
    return {
        require: [ "uibBtnCheckbox", "ngModel" ],
        controller: "UibButtonsController",
        controllerAs: "button",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1);
            }
            function getCheckboxValue(attribute, defaultValue) {
                return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
            }
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.on(buttonsCtrl.toggleEvent, function() {
                attrs.disabled || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
}), angular.module("ui.bootstrap.carousel", []).controller("UibCarouselController", [ "$scope", "$element", "$interval", "$timeout", "$animate", function($scope, $element, $interval, $timeout, $animate) {
    function setActive(index) {
        for (var i = 0; i < slides.length; i++) slides[i].slide.active = i === index;
    }
    function goNext(slide, index, direction) {
        if (!destroyed) {
            if (angular.extend(slide, {
                direction: direction
            }), angular.extend(slides[currentIndex].slide || {}, {
                direction: direction
            }), $animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
                slides[index].element.data(SLIDE_DIRECTION, slide.direction);
                var currentIdx = self.getCurrentIndex();
                angular.isNumber(currentIdx) && slides[currentIdx].element && slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction), 
                $scope.$currentTransition = !0, $animate.on("addClass", slides[index].element, function(element, phase) {
                    "close" === phase && ($scope.$currentTransition = null, $animate.off("addClass", element));
                });
            }
            $scope.active = slide.index, currentIndex = slide.index, setActive(index), restartTimer();
        }
    }
    function findSlideIndex(slide) {
        for (var i = 0; i < slides.length; i++) if (slides[i].slide === slide) return i;
    }
    function resetTimer() {
        currentInterval && ($interval.cancel(currentInterval), currentInterval = null);
    }
    function resetTransition(slides) {
        slides.length || ($scope.$currentTransition = null);
    }
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        !isNaN(interval) && interval > 0 && (currentInterval = $interval(timerFn, interval));
    }
    function timerFn() {
        var interval = +$scope.interval;
        isPlaying && !isNaN(interval) && interval > 0 && slides.length ? $scope.next() : $scope.pause();
    }
    var currentInterval, isPlaying, self = this, slides = self.slides = $scope.slides = [], SLIDE_DIRECTION = "uib-slideDirection", currentIndex = $scope.active, destroyed = !1;
    $element.addClass("carousel"), self.addSlide = function(slide, element) {
        slides.push({
            slide: slide,
            element: element
        }), slides.sort(function(a, b) {
            return +a.slide.index - +b.slide.index;
        }), (slide.index === $scope.active || 1 === slides.length && !angular.isNumber($scope.active)) && ($scope.$currentTransition && ($scope.$currentTransition = null), 
        currentIndex = slide.index, $scope.active = slide.index, setActive(currentIndex), 
        self.select(slides[findSlideIndex(slide)]), 1 === slides.length && $scope.play());
    }, self.getCurrentIndex = function() {
        for (var i = 0; i < slides.length; i++) if (slides[i].slide.index === currentIndex) return i;
    }, self.next = $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        return 0 === newIndex && $scope.noWrap() ? void $scope.pause() : self.select(slides[newIndex], "next");
    }, self.prev = $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        return $scope.noWrap() && newIndex === slides.length - 1 ? void $scope.pause() : self.select(slides[newIndex], "prev");
    }, self.removeSlide = function(slide) {
        var index = findSlideIndex(slide);
        slides.splice(index, 1), slides.length > 0 && currentIndex === index ? index >= slides.length ? (currentIndex = slides.length - 1, 
        $scope.active = currentIndex, setActive(currentIndex), self.select(slides[slides.length - 1])) : (currentIndex = index, 
        $scope.active = currentIndex, setActive(currentIndex), self.select(slides[index])) : currentIndex > index && (currentIndex--, 
        $scope.active = currentIndex), 0 === slides.length && (currentIndex = null, $scope.active = null);
    }, self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = findSlideIndex(nextSlide.slide);
        void 0 === direction && (direction = nextIndex > self.getCurrentIndex() ? "next" : "prev"), 
        nextSlide.slide.index === currentIndex || $scope.$currentTransition || goNext(nextSlide.slide, nextIndex, direction);
    }, $scope.indexOfSlide = function(slide) {
        return +slide.slide.index;
    }, $scope.isActive = function(slide) {
        return $scope.active === slide.slide.index;
    }, $scope.isPrevDisabled = function() {
        return 0 === $scope.active && $scope.noWrap();
    }, $scope.isNextDisabled = function() {
        return $scope.active === slides.length - 1 && $scope.noWrap();
    }, $scope.pause = function() {
        $scope.noPause || (isPlaying = !1, resetTimer());
    }, $scope.play = function() {
        isPlaying || (isPlaying = !0, restartTimer());
    }, $element.on("mouseenter", $scope.pause), $element.on("mouseleave", $scope.play), 
    $scope.$on("$destroy", function() {
        destroyed = !0, resetTimer();
    }), $scope.$watch("noTransition", function(noTransition) {
        $animate.enabled($element, !noTransition);
    }), $scope.$watch("interval", restartTimer), $scope.$watchCollection("slides", resetTransition), 
    $scope.$watch("active", function(index) {
        if (angular.isNumber(index) && currentIndex !== index) {
            for (var i = 0; i < slides.length; i++) if (slides[i].slide.index === index) {
                index = i;
                break;
            }
            slides[index] && (setActive(index), self.select(slides[index]), currentIndex = index);
        }
    });
} ]).directive("uibCarousel", function() {
    return {
        transclude: !0,
        controller: "UibCarouselController",
        controllerAs: "carousel",
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/carousel/carousel.html";
        },
        scope: {
            active: "=",
            interval: "=",
            noTransition: "=",
            noPause: "=",
            noWrap: "&"
        }
    };
}).directive("uibSlide", [ "$animate", function($animate) {
    return {
        require: "^uibCarousel",
        restrict: "A",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/carousel/slide.html";
        },
        scope: {
            actual: "=?",
            index: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            element.addClass("item"), carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            }), scope.$watch("active", function(active) {
                $animate[active ? "addClass" : "removeClass"](element, "active");
            });
        }
    };
} ]).animation(".item", [ "$animateCss", function($animateCss) {
    function removeClass(element, className, callback) {
        element.removeClass(className), callback && callback();
    }
    return {
        beforeAddClass: function(element, className, done) {
            if ("active" === className) {
                var stopped = !1, direction = element.data("uib-slideDirection"), directionClass = "next" === direction ? "left" : "right", removeClassFn = removeClass.bind(this, element, directionClass + " " + direction, done);
                return element.addClass(direction), $animateCss(element, {
                    addClass: directionClass
                }).start().done(removeClassFn), function() {
                    stopped = !0;
                };
            }
            done();
        },
        beforeRemoveClass: function(element, className, done) {
            if ("active" === className) {
                var stopped = !1, direction = element.data("uib-slideDirection"), directionClass = "next" === direction ? "left" : "right", removeClassFn = removeClass.bind(this, element, directionClass, done);
                return $animateCss(element, {
                    addClass: directionClass
                }).start().done(removeClassFn), function() {
                    stopped = !0;
                };
            }
            done();
        }
    };
} ]), angular.module("ui.bootstrap.dateparser", []).service("uibDateParser", [ "$log", "$locale", "dateFilter", "orderByFilter", "filterFilter", function($log, $locale, dateFilter, orderByFilter, filterFilter) {
    function getFormatCodeToRegex(key) {
        return filterFilter(formatCodeToRegex, {
            key: key
        }, !0)[0];
    }
    function createParser(format) {
        var map = [], regex = format.split(""), quoteIndex = format.indexOf("'");
        if (quoteIndex > -1) {
            var inLiteral = !1;
            format = format.split("");
            for (var i = quoteIndex; i < format.length; i++) inLiteral ? ("'" === format[i] && (i + 1 < format.length && "'" === format[i + 1] ? (format[i + 1] = "$", 
            regex[i + 1] = "") : (regex[i] = "", inLiteral = !1)), format[i] = "$") : "'" === format[i] && (format[i] = "$", 
            regex[i] = "", inLiteral = !0);
            format = format.join("");
        }
        return angular.forEach(formatCodeToRegex, function(data) {
            var index = format.indexOf(data.key);
            if (index > -1) {
                format = format.split(""), regex[index] = "(" + data.regex + ")", format[index] = "$";
                for (var i = index + 1, n = index + data.key.length; i < n; i++) regex[i] = "", 
                format[i] = "$";
                format = format.join(""), map.push({
                    index: index,
                    key: data.key,
                    apply: data.apply,
                    matcher: data.regex
                });
            }
        }), {
            regex: new RegExp("^" + regex.join("") + "$"),
            map: orderByFilter(map, "index")
        };
    }
    function createFormatter(format) {
        for (var formatter, literalIdx, formatters = [], i = 0; i < format.length; ) if (angular.isNumber(literalIdx)) {
            if ("'" === format.charAt(i)) (i + 1 >= format.length || "'" !== format.charAt(i + 1)) && (formatters.push(constructLiteralFormatter(format, literalIdx, i)), 
            literalIdx = null); else if (i === format.length) for (;literalIdx < format.length; ) formatter = constructFormatterFromIdx(format, literalIdx), 
            formatters.push(formatter), literalIdx = formatter.endIdx;
            i++;
        } else "'" !== format.charAt(i) ? (formatter = constructFormatterFromIdx(format, i), 
        formatters.push(formatter.parser), i = formatter.endIdx) : (literalIdx = i, i++);
        return formatters;
    }
    function constructLiteralFormatter(format, literalIdx, endIdx) {
        return function() {
            return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
        };
    }
    function constructFormatterFromIdx(format, i) {
        for (var currentPosStr = format.substr(i), j = 0; j < formatCodeToRegex.length; j++) if (new RegExp("^" + formatCodeToRegex[j].key).test(currentPosStr)) {
            var data = formatCodeToRegex[j];
            return {
                endIdx: i + data.key.length,
                parser: data.formatter
            };
        }
        return {
            endIdx: i + 1,
            parser: function() {
                return currentPosStr.charAt(0);
            }
        };
    }
    function isValid(year, month, date) {
        return !(date < 1) && (1 === month && date > 28 ? 29 === date && (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) : 3 !== month && 5 !== month && 8 !== month && 10 !== month || date < 31);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function toTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
    }
    function fromTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone, !0) : date;
    }
    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(/:/g, "");
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        return addDateMinutes(date, reverse * (timezoneToOffset(timezone, dateTimezoneOffset) - dateTimezoneOffset));
    }
    var localeId, formatCodeToRegex, SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    this.init = function() {
        localeId = $locale.id, this.parsers = {}, this.formatters = {}, formatCodeToRegex = [ {
            key: "yyyy",
            regex: "\\d{4}",
            apply: function(value) {
                this.year = +value;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "yyyy");
            }
        }, {
            key: "yy",
            regex: "\\d{2}",
            apply: function(value) {
                value = +value, this.year = value < 69 ? value + 2e3 : value + 1900;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "yy");
            }
        }, {
            key: "y",
            regex: "\\d{1,4}",
            apply: function(value) {
                this.year = +value;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "y");
            }
        }, {
            key: "M!",
            regex: "0?[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                return /^[0-9]$/.test(date.getMonth()) ? dateFilter(date, "MM") : dateFilter(date, "M");
            }
        }, {
            key: "MMMM",
            regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
            },
            formatter: function(date) {
                return dateFilter(date, "MMMM");
            }
        }, {
            key: "MMM",
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
            },
            formatter: function(date) {
                return dateFilter(date, "MMM");
            }
        }, {
            key: "MM",
            regex: "0[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                return dateFilter(date, "MM");
            }
        }, {
            key: "M",
            regex: "[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                return dateFilter(date, "M");
            }
        }, {
            key: "d!",
            regex: "[0-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                return /^[1-9]$/.test(date.getDate()) ? dateFilter(date, "dd") : dateFilter(date, "d");
            }
        }, {
            key: "dd",
            regex: "[0-2][0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "dd");
            }
        }, {
            key: "d",
            regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "d");
            }
        }, {
            key: "EEEE",
            regex: $locale.DATETIME_FORMATS.DAY.join("|"),
            formatter: function(date) {
                return dateFilter(date, "EEEE");
            }
        }, {
            key: "EEE",
            regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|"),
            formatter: function(date) {
                return dateFilter(date, "EEE");
            }
        }, {
            key: "HH",
            regex: "(?:0|1)[0-9]|2[0-3]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "HH");
            }
        }, {
            key: "hh",
            regex: "0[0-9]|1[0-2]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "hh");
            }
        }, {
            key: "H",
            regex: "1?[0-9]|2[0-3]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "H");
            }
        }, {
            key: "h",
            regex: "[0-9]|1[0-2]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "h");
            }
        }, {
            key: "mm",
            regex: "[0-5][0-9]",
            apply: function(value) {
                this.minutes = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "mm");
            }
        }, {
            key: "m",
            regex: "[0-9]|[1-5][0-9]",
            apply: function(value) {
                this.minutes = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "m");
            }
        }, {
            key: "sss",
            regex: "[0-9][0-9][0-9]",
            apply: function(value) {
                this.milliseconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "sss");
            }
        }, {
            key: "ss",
            regex: "[0-5][0-9]",
            apply: function(value) {
                this.seconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "ss");
            }
        }, {
            key: "s",
            regex: "[0-9]|[1-5][0-9]",
            apply: function(value) {
                this.seconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "s");
            }
        }, {
            key: "a",
            regex: $locale.DATETIME_FORMATS.AMPMS.join("|"),
            apply: function(value) {
                12 === this.hours && (this.hours = 0), "PM" === value && (this.hours += 12);
            },
            formatter: function(date) {
                return dateFilter(date, "a");
            }
        }, {
            key: "Z",
            regex: "[+-]\\d{4}",
            apply: function(value) {
                var matches = value.match(/([+-])(\d{2})(\d{2})/), sign = matches[1], hours = matches[2], minutes = matches[3];
                this.hours += toInt(sign + hours), this.minutes += toInt(sign + minutes);
            },
            formatter: function(date) {
                return dateFilter(date, "Z");
            }
        }, {
            key: "ww",
            regex: "[0-4][0-9]|5[0-3]",
            formatter: function(date) {
                return dateFilter(date, "ww");
            }
        }, {
            key: "w",
            regex: "[0-9]|[1-4][0-9]|5[0-3]",
            formatter: function(date) {
                return dateFilter(date, "w");
            }
        }, {
            key: "GGGG",
            regex: $locale.DATETIME_FORMATS.ERANAMES.join("|").replace(/\s/g, "\\s"),
            formatter: function(date) {
                return dateFilter(date, "GGGG");
            }
        }, {
            key: "GGG",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "GGG");
            }
        }, {
            key: "GG",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "GG");
            }
        }, {
            key: "G",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "G");
            }
        } ], angular.version.major >= 1 && angular.version.minor > 4 && formatCodeToRegex.push({
            key: "LLLL",
            regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value);
            },
            formatter: function(date) {
                return dateFilter(date, "LLLL");
            }
        });
    }, this.init(), this.getParser = function(key) {
        var f = getFormatCodeToRegex(key);
        return f && f.apply || null;
    }, this.overrideParser = function(key, parser) {
        var f = getFormatCodeToRegex(key);
        f && angular.isFunction(parser) && (this.parsers = {}, f.apply = parser);
    }.bind(this), this.filter = function(date, format) {
        return angular.isDate(date) && !isNaN(date) && format ? (format = $locale.DATETIME_FORMATS[format] || format, 
        $locale.id !== localeId && this.init(), this.formatters[format] || (this.formatters[format] = createFormatter(format)), 
        this.formatters[format].reduce(function(str, formatter) {
            return str + formatter(date);
        }, "")) : "";
    }, this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) return input;
        format = $locale.DATETIME_FORMATS[format] || format, format = format.replace(SPECIAL_CHARACTERS_REGEXP, "\\$&"), 
        $locale.id !== localeId && this.init(), this.parsers[format] || (this.parsers[format] = createParser(format));
        var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex), tzOffset = !1;
        if (results && results.length) {
            var fields, dt;
            angular.isDate(baseDate) && !isNaN(baseDate.getTime()) ? fields = {
                year: baseDate.getFullYear(),
                month: baseDate.getMonth(),
                date: baseDate.getDate(),
                hours: baseDate.getHours(),
                minutes: baseDate.getMinutes(),
                seconds: baseDate.getSeconds(),
                milliseconds: baseDate.getMilliseconds()
            } : (baseDate && $log.warn("dateparser:", "baseDate is not a valid date"), fields = {
                year: 1900,
                month: 0,
                date: 1,
                hours: 0,
                minutes: 0,
                seconds: 0,
                milliseconds: 0
            });
            for (var i = 1, n = results.length; i < n; i++) {
                var mapper = map[i - 1];
                "Z" === mapper.matcher && (tzOffset = !0), mapper.apply && mapper.apply.call(fields, results[i]);
            }
            var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear, timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;
            return isValid(fields.year, fields.month, fields.date) && (!angular.isDate(baseDate) || isNaN(baseDate.getTime()) || tzOffset ? (dt = new Date(0), 
            datesetter.call(dt, fields.year, fields.month, fields.date), timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0)) : (dt = new Date(baseDate), 
            datesetter.call(dt, fields.year, fields.month, fields.date), timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds))), 
            dt;
        }
    }, this.toTimezone = toTimezone, this.fromTimezone = fromTimezone, this.timezoneToOffset = timezoneToOffset, 
    this.addDateMinutes = addDateMinutes, this.convertTimezoneToLocal = convertTimezoneToLocal;
} ]), angular.module("ui.bootstrap.isClass", []).directive("uibIsClass", [ "$animate", function($animate) {
    var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/, IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
    return {
        restrict: "A",
        compile: function(tElement, tAttrs) {
            function linkFn(scope, element, attrs) {
                linkedScopes.push(scope), instances.push({
                    scope: scope,
                    element: element
                }), exps.forEach(function(exp, k) {
                    addForExp(exp, scope);
                }), scope.$on("$destroy", removeScope);
            }
            function addForExp(exp, scope) {
                var matches = exp.match(IS_REGEXP), clazz = scope.$eval(matches[1]), compareWithExp = matches[2], data = expToData[exp];
                if (!data) {
                    var watchFn = function(compareWithVal) {
                        var newActivated = null;
                        instances.some(function(instance) {
                            if (instance.scope.$eval(onExp) === compareWithVal) return newActivated = instance, 
                            !0;
                        }), data.lastActivated !== newActivated && (data.lastActivated && $animate.removeClass(data.lastActivated.element, clazz), 
                        newActivated && $animate.addClass(newActivated.element, clazz), data.lastActivated = newActivated);
                    };
                    expToData[exp] = data = {
                        lastActivated: null,
                        scope: scope,
                        watchFn: watchFn,
                        compareWithExp: compareWithExp,
                        watcher: scope.$watch(compareWithExp, watchFn)
                    };
                }
                data.watchFn(scope.$eval(compareWithExp));
            }
            function removeScope(e) {
                var removedScope = e.targetScope, index = linkedScopes.indexOf(removedScope);
                if (linkedScopes.splice(index, 1), instances.splice(index, 1), linkedScopes.length) {
                    var newWatchScope = linkedScopes[0];
                    angular.forEach(expToData, function(data) {
                        data.scope === removedScope && (data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn), 
                        data.scope = newWatchScope);
                    });
                } else expToData = {};
            }
            var linkedScopes = [], instances = [], expToData = {}, onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP), onExp = onExpMatches[2], expsStr = onExpMatches[1], exps = expsStr.split(",");
            return linkFn;
        }
    };
} ]), angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.dateparser", "ui.bootstrap.isClass" ]).value("$datepickerSuppressError", !1).value("$datepickerLiteralWarning", !0).constant("uibDatepickerConfig", {
    datepickerMode: "day",
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    maxDate: null,
    maxMode: "year",
    minDate: null,
    minMode: "day",
    monthColumns: 3,
    ngModelOptions: {},
    shortcutPropagation: !1,
    showWeeks: !0,
    yearColumns: 5,
    yearRows: 4
}).controller("UibDatepickerController", [ "$scope", "$element", "$attrs", "$parse", "$interpolate", "$locale", "$log", "dateFilter", "uibDatepickerConfig", "$datepickerLiteralWarning", "$datepickerSuppressError", "uibDateParser", function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
    function setMode(mode) {
        $scope.datepickerMode = mode, $scope.datepickerOptions.datepickerMode = mode;
    }
    function extractOptions(ngModelCtrl) {
        var ngModelOptions;
        if (angular.version.minor < 6) ngModelOptions = ngModelCtrl.$options || $scope.datepickerOptions.ngModelOptions || datepickerConfig.ngModelOptions || {}, 
        ngModelOptions.getOption = function(key) {
            return ngModelOptions[key];
        }; else {
            var timezone = ngModelCtrl.$options.getOption("timezone") || ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) || (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);
            ngModelOptions = ngModelCtrl.$options.createChild(datepickerConfig.ngModelOptions).createChild($scope.datepickerOptions.ngModelOptions).createChild(ngModelCtrl.$options).createChild({
                timezone: timezone
            });
        }
        return ngModelOptions;
    }
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    }, ngModelOptions = {}, watchListeners = [];
    $element.addClass("uib-datepicker"), $attrs.$set("role", "application"), $scope.datepickerOptions || ($scope.datepickerOptions = {}), 
    this.modes = [ "day", "month", "year" ], [ "customClass", "dateDisabled", "datepickerMode", "formatDay", "formatDayHeader", "formatDayTitle", "formatMonth", "formatMonthTitle", "formatYear", "maxDate", "maxMode", "minDate", "minMode", "monthColumns", "showWeeks", "shortcutPropagation", "startingDay", "yearColumns", "yearRows" ].forEach(function(key) {
        switch (key) {
          case "customClass":
          case "dateDisabled":
            $scope[key] = $scope.datepickerOptions[key] || angular.noop;
            break;

          case "datepickerMode":
            $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
            break;

          case "formatDay":
          case "formatDayHeader":
          case "formatDayTitle":
          case "formatMonth":
          case "formatMonthTitle":
          case "formatYear":
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
            break;

          case "monthColumns":
          case "showWeeks":
          case "shortcutPropagation":
          case "yearColumns":
          case "yearRows":
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
            break;

          case "startingDay":
            angular.isDefined($scope.datepickerOptions.startingDay) ? self.startingDay = $scope.datepickerOptions.startingDay : angular.isNumber(datepickerConfig.startingDay) ? self.startingDay = datepickerConfig.startingDay : self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
            break;

          case "maxDate":
          case "minDate":
            $scope.$watch("datepickerOptions." + key, function(value) {
                value ? angular.isDate(value) ? self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption("timezone")) : ($datepickerLiteralWarning && $log.warn("Literal date support has been deprecated, please switch to date object usage"), 
                self[key] = new Date(dateFilter(value, "medium"))) : self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption("timezone")) : null, 
                self.refreshView();
            });
            break;

          case "maxMode":
          case "minMode":
            $scope.datepickerOptions[key] ? $scope.$watch(function() {
                return $scope.datepickerOptions[key];
            }, function(value) {
                self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key], 
                ("minMode" === key && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || "maxMode" === key && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) && ($scope.datepickerMode = self[key], 
                $scope.datepickerOptions.datepickerMode = self[key]);
            }) : self[key] = $scope[key] = datepickerConfig[key] || null;
        }
    }), $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(1e4 * Math.random()), 
    $scope.disabled = angular.isDefined($attrs.disabled) || !1, angular.isDefined($attrs.ngDisabled) && watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
        $scope.disabled = disabled, self.refreshView();
    })), $scope.isActive = function(dateObject) {
        return 0 === self.compare(dateObject.date, self.activeDate) && ($scope.activeDateId = dateObject.uid, 
        !0);
    }, this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelOptions = extractOptions(ngModelCtrl), $scope.datepickerOptions.initDate ? (self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption("timezone")) || new Date(), 
        $scope.$watch("datepickerOptions.initDate", function(initDate) {
            initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid) && (self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption("timezone")), 
            self.refreshView());
        })) : self.activeDate = new Date();
        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
        this.activeDate = isNaN(date) ? dateParser.fromTimezone(new Date(), ngModelOptions.getOption("timezone")) : dateParser.fromTimezone(date, ngModelOptions.getOption("timezone")), 
        ngModelCtrl.$render = function() {
            self.render();
        };
    }, this.render = function() {
        if (ngModelCtrl.$viewValue) {
            var date = new Date(ngModelCtrl.$viewValue);
            !isNaN(date) ? this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption("timezone")) : $datepickerSuppressError || $log.error('Datepicker directive: "ng-model" value must be a Date object');
        }
        this.refreshView();
    }, this.refreshView = function() {
        if (this.element) {
            $scope.selectedDt = null, this._refreshView(), $scope.activeDt && ($scope.activeDateId = $scope.activeDt.uid);
            var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
            date = dateParser.fromTimezone(date, ngModelOptions.getOption("timezone")), ngModelCtrl.$setValidity("dateDisabled", !date || this.element && !this.isDisabled(date));
        }
    }, this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        model = dateParser.fromTimezone(model, ngModelOptions.getOption("timezone"));
        var today = new Date();
        today = dateParser.fromTimezone(today, ngModelOptions.getOption("timezone"));
        var time = this.compare(date, today), dt = {
            date: date,
            label: dateParser.filter(date, format),
            selected: model && 0 === this.compare(date, model),
            disabled: this.isDisabled(date),
            past: time < 0,
            current: 0 === time,
            future: time > 0,
            customClass: this.customClass(date) || null
        };
        return model && 0 === this.compare(date, model) && ($scope.selectedDt = dt), self.activeDate && 0 === this.compare(dt.date, self.activeDate) && ($scope.activeDt = dt), 
        dt;
    }, this.isDisabled = function(date) {
        return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.customClass = function(date) {
        return $scope.customClass({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.split = function(arr, size) {
        for (var arrays = []; arr.length > 0; ) arrays.push(arr.splice(0, size));
        return arrays;
    }, $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption("timezone")) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), dt = dateParser.toTimezone(dt, ngModelOptions.getOption("timezone")), 
            ngModelCtrl.$setViewValue(dt), ngModelCtrl.$render();
        } else self.activeDate = date, setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]), 
        $scope.$emit("uib:datepicker.mode");
        $scope.$broadcast("uib:datepicker.focus");
    }, $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1), self.refreshView();
    }, $scope.toggleMode = function(direction) {
        direction = direction || 1, $scope.datepickerMode === self.maxMode && 1 === direction || $scope.datepickerMode === self.minMode && -1 === direction || (setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]), 
        $scope.$emit("uib:datepicker.mode"));
    }, $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        self.element[0].focus();
    };
    $scope.$on("uib:datepicker.focus", focusElement), $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (key && !evt.shiftKey && !evt.altKey && !$scope.disabled) if (evt.preventDefault(), 
        self.shortcutPropagation || evt.stopPropagation(), "enter" === key || "space" === key) {
            if (self.isDisabled(self.activeDate)) return;
            $scope.select(self.activeDate);
        } else !evt.ctrlKey || "up" !== key && "down" !== key ? (self.handleKeyDown(key, evt), 
        self.refreshView()) : $scope.toggleMode("up" === key ? 1 : -1);
    }, $element.on("keydown", function(evt) {
        $scope.$apply(function() {
            $scope.keydown(evt);
        });
    }), $scope.$on("$destroy", function() {
        for (;watchListeners.length; ) watchListeners.shift()();
    });
} ]).controller("UibDaypickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    function getDaysInMonth(year, month) {
        return 1 !== month || year % 4 != 0 || year % 100 == 0 && year % 400 != 0 ? DAYS_IN_MONTH[month] : 29;
    }
    function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        var time = checkDate.getTime();
        return checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
    }
    var DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
    this.step = {
        months: 1
    }, this.element = $element, this.init = function(ctrl) {
        angular.extend(ctrl, this), scope.showWeeks = ctrl.showWeeks, ctrl.refreshView();
    }, this.getDates = function(startDate, n) {
        for (var date, dates = new Array(n), current = new Date(startDate), i = 0; i < n; ) date = new Date(current), 
        dates[i++] = date, current.setDate(current.getDate() + 1);
        return dates;
    }, this._refreshView = function() {
        var year = this.activeDate.getFullYear(), month = this.activeDate.getMonth(), firstDayOfMonth = new Date(this.activeDate);
        firstDayOfMonth.setFullYear(year, month, 1);
        var difference = this.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
        numDisplayedFromPreviousMonth > 0 && firstDate.setDate(1 - numDisplayedFromPreviousMonth);
        for (var days = this.getDates(firstDate, 42), i = 0; i < 42; i++) days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + "-" + i
        });
        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, "EEEE")
        };
        if (scope.title = dateFilter(this.activeDate, this.formatDayTitle), scope.rows = this.split(days, 7), 
        scope.showWeeks) {
            scope.weekNumbers = [];
            for (var thursdayIndex = (11 - this.startingDay) % 7, numWeeks = scope.rows.length, curWeek = 0; curWeek < numWeeks; curWeek++) scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
        }
    }, this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()), _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        return _date1.setFullYear(date1.getFullYear()), _date2.setFullYear(date2.getFullYear()), 
        _date1 - _date2;
    }, this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getDate();
        if ("left" === key) date -= 1; else if ("up" === key) date -= 7; else if ("right" === key) date += 1; else if ("down" === key) date += 7; else if ("pageup" === key || "pagedown" === key) {
            var month = this.activeDate.getMonth() + ("pageup" === key ? -1 : 1);
            this.activeDate.setMonth(month, 1), date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else "home" === key ? date = 1 : "end" === key && (date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()));
        this.activeDate.setDate(date);
    };
} ]).controller("UibMonthpickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    this.step = {
        years: 1
    }, this.element = $element, this.init = function(ctrl) {
        angular.extend(ctrl, this), ctrl.refreshView();
    }, this._refreshView = function() {
        for (var date, months = new Array(12), year = this.activeDate.getFullYear(), i = 0; i < 12; i++) date = new Date(this.activeDate), 
        date.setFullYear(year, i, 1), months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
            uid: scope.uniqueId + "-" + i
        });
        scope.title = dateFilter(this.activeDate, this.formatMonthTitle), scope.rows = this.split(months, this.monthColumns), 
        scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
    }, this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth()), _date2 = new Date(date2.getFullYear(), date2.getMonth());
        return _date1.setFullYear(date1.getFullYear()), _date2.setFullYear(date2.getFullYear()), 
        _date1 - _date2;
    }, this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getMonth();
        if ("left" === key) date -= 1; else if ("up" === key) date -= this.monthColumns; else if ("right" === key) date += 1; else if ("down" === key) date += this.monthColumns; else if ("pageup" === key || "pagedown" === key) {
            var year = this.activeDate.getFullYear() + ("pageup" === key ? -1 : 1);
            this.activeDate.setFullYear(year);
        } else "home" === key ? date = 0 : "end" === key && (date = 11);
        this.activeDate.setMonth(date);
    };
} ]).controller("UibYearpickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
    }
    var columns, range;
    this.element = $element, this.yearpickerInit = function() {
        columns = this.yearColumns, range = this.yearRows * columns, this.step = {
            years: range
        };
    }, this._refreshView = function() {
        for (var date, years = new Array(range), i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) date = new Date(this.activeDate), 
        date.setFullYear(start + i, 0, 1), years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
            uid: scope.uniqueId + "-" + i
        });
        scope.title = [ years[0].label, years[range - 1].label ].join(" - "), scope.rows = this.split(years, columns), 
        scope.columns = columns;
    }, this.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
    }, this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getFullYear();
        "left" === key ? date -= 1 : "up" === key ? date -= columns : "right" === key ? date += 1 : "down" === key ? date += columns : "pageup" === key || "pagedown" === key ? date += ("pageup" === key ? -1 : 1) * range : "home" === key ? date = getStartingYear(this.activeDate.getFullYear()) : "end" === key && (date = getStartingYear(this.activeDate.getFullYear()) + range - 1), 
        this.activeDate.setFullYear(date);
    };
} ]).directive("uibDatepicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/datepicker.html";
        },
        scope: {
            datepickerOptions: "=?"
        },
        require: [ "uibDatepicker", "^ngModel" ],
        restrict: "A",
        controller: "UibDatepickerController",
        controllerAs: "datepicker",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            datepickerCtrl.init(ngModelCtrl);
        }
    };
}).directive("uibDaypicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/day.html";
        },
        require: [ "^uibDatepicker", "uibDaypicker" ],
        restrict: "A",
        controller: "UibDaypickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0];
            ctrls[1].init(datepickerCtrl);
        }
    };
}).directive("uibMonthpicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/month.html";
        },
        require: [ "^uibDatepicker", "uibMonthpicker" ],
        restrict: "A",
        controller: "UibMonthpickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0];
            ctrls[1].init(datepickerCtrl);
        }
    };
}).directive("uibYearpicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/year.html";
        },
        require: [ "^uibDatepicker", "uibYearpicker" ],
        restrict: "A",
        controller: "UibYearpickerController",
        link: function(scope, element, attrs, ctrls) {
            var ctrl = ctrls[0];
            angular.extend(ctrl, ctrls[1]), ctrl.yearpickerInit(), ctrl.refreshView();
        }
    };
}), angular.module("ui.bootstrap.position", []).factory("$uibPosition", [ "$document", "$window", function($document, $window) {
    var SCROLLBAR_WIDTH, BODY_SCROLLBAR_WIDTH, OVERFLOW_REGEX = {
        normal: /(auto|scroll)/,
        hidden: /(auto|scroll|hidden)/
    }, PLACEMENT_REGEX = {
        auto: /\s?auto?\s?/i,
        primary: /^(top|bottom|left|right)$/,
        secondary: /^(top|bottom|left|right|center)$/,
        vertical: /^(top|bottom)$/
    }, BODY_REGEX = /(HTML|BODY)/;
    return {
        getRawNode: function(elem) {
            return elem.nodeName ? elem : elem[0] || elem;
        },
        parseStyle: function(value) {
            return value = parseFloat(value), isFinite(value) ? value : 0;
        },
        offsetParent: function(elem) {
            elem = this.getRawNode(elem);
            for (var offsetParent = elem.offsetParent || $document[0].documentElement; offsetParent && offsetParent !== $document[0].documentElement && function(el) {
                return "static" === ($window.getComputedStyle(el).position || "static");
            }(offsetParent); ) offsetParent = offsetParent.offsetParent;
            return offsetParent || $document[0].documentElement;
        },
        scrollbarWidth: function(isBody) {
            if (isBody) {
                if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
                    var bodyElem = $document.find("body");
                    bodyElem.addClass("uib-position-body-scrollbar-measure"), BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth, 
                    BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0, 
                    bodyElem.removeClass("uib-position-body-scrollbar-measure");
                }
                return BODY_SCROLLBAR_WIDTH;
            }
            if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
                $document.find("body").append(scrollElem), SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth, 
                SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0, scrollElem.remove();
            }
            return SCROLLBAR_WIDTH;
        },
        scrollbarPadding: function(elem) {
            elem = this.getRawNode(elem);
            var elemStyle = $window.getComputedStyle(elem), paddingRight = this.parseStyle(elemStyle.paddingRight), paddingBottom = this.parseStyle(elemStyle.paddingBottom), scrollParent = this.scrollParent(elem, !1, !0), scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));
            return {
                scrollbarWidth: scrollbarWidth,
                widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
                right: paddingRight + scrollbarWidth,
                originalRight: paddingRight,
                heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
                bottom: paddingBottom + scrollbarWidth,
                originalBottom: paddingBottom
            };
        },
        isScrollable: function(elem, includeHidden) {
            elem = this.getRawNode(elem);
            var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal, elemStyle = $window.getComputedStyle(elem);
            return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
        },
        scrollParent: function(elem, includeHidden, includeSelf) {
            elem = this.getRawNode(elem);
            var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal, documentEl = $document[0].documentElement, elemStyle = $window.getComputedStyle(elem);
            if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) return elem;
            var excludeStatic = "absolute" === elemStyle.position, scrollParent = elem.parentElement || documentEl;
            if (scrollParent === documentEl || "fixed" === elemStyle.position) return documentEl;
            for (;scrollParent.parentElement && scrollParent !== documentEl; ) {
                var spStyle = $window.getComputedStyle(scrollParent);
                if (excludeStatic && "static" !== spStyle.position && (excludeStatic = !1), !excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) break;
                scrollParent = scrollParent.parentElement;
            }
            return scrollParent;
        },
        position: function(elem, includeMagins) {
            elem = this.getRawNode(elem);
            var elemOffset = this.offset(elem);
            if (includeMagins) {
                var elemStyle = $window.getComputedStyle(elem);
                elemOffset.top -= this.parseStyle(elemStyle.marginTop), elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
            }
            var parent = this.offsetParent(elem), parentOffset = {
                top: 0,
                left: 0
            };
            return parent !== $document[0].documentElement && (parentOffset = this.offset(parent), 
            parentOffset.top += parent.clientTop - parent.scrollTop, parentOffset.left += parent.clientLeft - parent.scrollLeft), 
            {
                width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                top: Math.round(elemOffset.top - parentOffset.top),
                left: Math.round(elemOffset.left - parentOffset.left)
            };
        },
        offset: function(elem) {
            elem = this.getRawNode(elem);
            var elemBCR = elem.getBoundingClientRect();
            return {
                width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
            };
        },
        viewportOffset: function(elem, useDocument, includePadding) {
            elem = this.getRawNode(elem), includePadding = !1 !== includePadding;
            var elemBCR = elem.getBoundingClientRect(), offsetBCR = {
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }, offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem), offsetParentBCR = offsetParent.getBoundingClientRect();
            if (offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop, offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft, 
            offsetParent === $document[0].documentElement && (offsetBCR.top += $window.pageYOffset, 
            offsetBCR.left += $window.pageXOffset), offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight, 
            offsetBCR.right = offsetBCR.left + offsetParent.clientWidth, includePadding) {
                var offsetParentStyle = $window.getComputedStyle(offsetParent);
                offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop), offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom), 
                offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft), offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
            }
            return {
                top: Math.round(elemBCR.top - offsetBCR.top),
                bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                left: Math.round(elemBCR.left - offsetBCR.left),
                right: Math.round(offsetBCR.right - elemBCR.right)
            };
        },
        parsePlacement: function(placement) {
            var autoPlace = PLACEMENT_REGEX.auto.test(placement);
            return autoPlace && (placement = placement.replace(PLACEMENT_REGEX.auto, "")), placement = placement.split("-"), 
            placement[0] = placement[0] || "top", PLACEMENT_REGEX.primary.test(placement[0]) || (placement[0] = "top"), 
            placement[1] = placement[1] || "center", PLACEMENT_REGEX.secondary.test(placement[1]) || (placement[1] = "center"), 
            placement[2] = !!autoPlace, placement;
        },
        positionElements: function(hostElem, targetElem, placement, appendToBody) {
            hostElem = this.getRawNode(hostElem), targetElem = this.getRawNode(targetElem);
            var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop("offsetWidth"), targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop("offsetHeight");
            placement = this.parsePlacement(placement);
            var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem), targetElemPos = {
                top: 0,
                left: 0,
                placement: ""
            };
            if (placement[2]) {
                var viewportOffset = this.viewportOffset(hostElem, appendToBody), targetElemStyle = $window.getComputedStyle(targetElem), adjustedSize = {
                    width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                    height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                };
                if (placement[0] = "top" === placement[0] && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? "bottom" : "bottom" === placement[0] && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? "top" : "left" === placement[0] && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? "right" : "right" === placement[0] && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? "left" : placement[0], 
                placement[1] = "top" === placement[1] && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? "bottom" : "bottom" === placement[1] && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? "top" : "left" === placement[1] && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? "right" : "right" === placement[1] && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? "left" : placement[1], 
                "center" === placement[1]) if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                    var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                    viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? placement[1] = "left" : viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left && (placement[1] = "right");
                } else {
                    var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                    viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? placement[1] = "top" : viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top && (placement[1] = "bottom");
                }
            }
            switch (placement[0]) {
              case "top":
                targetElemPos.top = hostElemPos.top - targetHeight;
                break;

              case "bottom":
                targetElemPos.top = hostElemPos.top + hostElemPos.height;
                break;

              case "left":
                targetElemPos.left = hostElemPos.left - targetWidth;
                break;

              case "right":
                targetElemPos.left = hostElemPos.left + hostElemPos.width;
            }
            switch (placement[1]) {
              case "top":
                targetElemPos.top = hostElemPos.top;
                break;

              case "bottom":
                targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                break;

              case "left":
                targetElemPos.left = hostElemPos.left;
                break;

              case "right":
                targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                break;

              case "center":
                PLACEMENT_REGEX.vertical.test(placement[0]) ? targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2 : targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            return targetElemPos.top = Math.round(targetElemPos.top), targetElemPos.left = Math.round(targetElemPos.left), 
            targetElemPos.placement = "center" === placement[1] ? placement[0] : placement[0] + "-" + placement[1], 
            targetElemPos;
        },
        adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
            if (-1 !== placementClasses.indexOf("top") && initialHeight !== currentHeight) return {
                top: containerPosition.top - currentHeight + "px"
            };
        },
        positionArrow: function(elem, placement) {
            elem = this.getRawNode(elem);
            var innerElem = elem.querySelector(".tooltip-inner, .popover-inner");
            if (innerElem) {
                var isTooltip = angular.element(innerElem).hasClass("tooltip-inner"), arrowElem = isTooltip ? elem.querySelector(".tooltip-arrow") : elem.querySelector(".arrow");
                if (arrowElem) {
                    var arrowCss = {
                        top: "",
                        bottom: "",
                        left: "",
                        right: ""
                    };
                    if (placement = this.parsePlacement(placement), "center" === placement[1]) return void angular.element(arrowElem).css(arrowCss);
                    var borderProp = "border-" + placement[0] + "-width", borderWidth = $window.getComputedStyle(arrowElem)[borderProp], borderRadiusProp = "border-";
                    borderRadiusProp += PLACEMENT_REGEX.vertical.test(placement[0]) ? placement[0] + "-" + placement[1] : placement[1] + "-" + placement[0], 
                    borderRadiusProp += "-radius";
                    var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
                    switch (placement[0]) {
                      case "top":
                        arrowCss.bottom = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "bottom":
                        arrowCss.top = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "left":
                        arrowCss.right = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "right":
                        arrowCss.left = isTooltip ? "0" : "-" + borderWidth;
                    }
                    arrowCss[placement[1]] = borderRadius, angular.element(arrowElem).css(arrowCss);
                }
            }
        }
    };
} ]), angular.module("ui.bootstrap.datepickerPopup", [ "ui.bootstrap.datepicker", "ui.bootstrap.position" ]).value("$datepickerPopupLiteralWarning", !0).constant("uibDatepickerPopupConfig", {
    altInputFormats: [],
    appendToBody: !1,
    clearText: "Clear",
    closeOnDateSelection: !0,
    closeText: "Done",
    currentText: "Today",
    datepickerPopup: "yyyy-MM-dd",
    datepickerPopupTemplateUrl: "uib/template/datepickerPopup/popup.html",
    datepickerTemplateUrl: "uib/template/datepicker/datepicker.html",
    html5Types: {
        date: "yyyy-MM-dd",
        "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss",
        month: "yyyy-MM"
    },
    onOpenFocus: !0,
    showButtonBar: !0,
    placement: "auto bottom-left"
}).controller("UibDatepickerPopupController", [ "$scope", "$element", "$attrs", "$compile", "$log", "$parse", "$window", "$document", "$rootScope", "$uibPosition", "dateFilter", "uibDateParser", "uibDatepickerPopupConfig", "$timeout", "uibDatepickerConfig", "$datepickerPopupLiteralWarning", function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
    function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, $scope.date);
        if (isNaN(date)) for (var i = 0; i < altInputFormats.length; i++) if (date = dateParser.parse(viewValue, altInputFormats[i], $scope.date), 
        !isNaN(date)) return date;
        return date;
    }
    function parseDate(viewValue) {
        if (angular.isNumber(viewValue) && (viewValue = new Date(viewValue)), !viewValue) return null;
        if (angular.isDate(viewValue) && !isNaN(viewValue)) return viewValue;
        if (angular.isString(viewValue)) {
            var date = parseDateString(viewValue);
            if (!isNaN(date)) return dateParser.toTimezone(date, ngModelOptions.getOption("timezone"));
        }
        return ngModelOptions.getOption("allowInvalid") ? viewValue : void 0;
    }
    function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        return !$attrs.ngRequired && !value || (angular.isNumber(value) && (value = new Date(value)), 
        !value || !(!angular.isDate(value) || isNaN(value)) || !!angular.isString(value) && !isNaN(parseDateString(value)));
    }
    function documentClickBind(event) {
        if ($scope.isOpen || !$scope.disabled) {
            var popup = $popup[0], dpContainsTarget = $element[0].contains(event.target), popupContainsTarget = void 0 !== popup.contains && popup.contains(event.target);
            !$scope.isOpen || dpContainsTarget || popupContainsTarget || $scope.$apply(function() {
                $scope.isOpen = !1;
            });
        }
    }
    function inputKeydownBind(evt) {
        27 === evt.which && $scope.isOpen ? (evt.preventDefault(), evt.stopPropagation(), 
        $scope.$apply(function() {
            $scope.isOpen = !1;
        }), $element[0].focus()) : 40 !== evt.which || $scope.isOpen || (evt.preventDefault(), 
        evt.stopPropagation(), $scope.$apply(function() {
            $scope.isOpen = !0;
        }));
    }
    function positionPopup() {
        if ($scope.isOpen) {
            var dpElement = angular.element($popup[0].querySelector(".uib-datepicker-popup")), placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement, position = $position.positionElements($element, dpElement, placement, appendToBody);
            dpElement.css({
                top: position.top + "px",
                left: position.left + "px"
            }), dpElement.hasClass("uib-position-measure") && dpElement.removeClass("uib-position-measure");
        }
    }
    function extractOptions(ngModelCtrl) {
        var ngModelOptions;
        return angular.version.minor < 6 ? (ngModelOptions = angular.isObject(ngModelCtrl.$options) ? ngModelCtrl.$options : {
            timezone: null
        }, ngModelOptions.getOption = function(key) {
            return ngModelOptions[key];
        }) : ngModelOptions = ngModelCtrl.$options, ngModelOptions;
    }
    var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus, datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl, ngModel, ngModelOptions, $popup, altInputFormats, isHtml5DateInput = !1, watchListeners = [];
    this.init = function(_ngModel_) {
        if (ngModel = _ngModel_, ngModelOptions = extractOptions(ngModel), closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, 
        appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody, 
        onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus, 
        datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl, 
        datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl, 
        altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats, 
        $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar, 
        datepickerPopupConfig.html5Types[$attrs.type] ? (dateFormat = datepickerPopupConfig.html5Types[$attrs.type], 
        isHtml5DateInput = !0) : (dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup, 
        $attrs.$observe("uibDatepickerPopup", function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat && (dateFormat = newDateFormat, ngModel.$modelValue = null, 
            !dateFormat)) throw new Error("uibDatepickerPopup must have a date format specified.");
        })), !dateFormat) throw new Error("uibDatepickerPopup must have a date format specified.");
        if (isHtml5DateInput && $attrs.uibDatepickerPopup) throw new Error("HTML5 date input types do not support custom formats.");
        popupEl = angular.element("<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>"), 
        popupEl.attr({
            "ng-model": "date",
            "ng-change": "dateSelection(date)",
            "template-url": datepickerPopupTemplateUrl
        }), datepickerEl = angular.element(popupEl.children()[0]), datepickerEl.attr("template-url", datepickerTemplateUrl), 
        $scope.datepickerOptions || ($scope.datepickerOptions = {}), isHtml5DateInput && "month" === $attrs.type && ($scope.datepickerOptions.datepickerMode = "month", 
        $scope.datepickerOptions.minMode = "month"), datepickerEl.attr("datepicker-options", "datepickerOptions"), 
        isHtml5DateInput ? ngModel.$formatters.push(function(value) {
            return $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption("timezone")), 
            value;
        }) : (ngModel.$$parserName = "date", ngModel.$validators.date = validator, ngModel.$parsers.unshift(parseDate), 
        ngModel.$formatters.push(function(value) {
            return ngModel.$isEmpty(value) ? ($scope.date = value, value) : (angular.isNumber(value) && (value = new Date(value)), 
            $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption("timezone")), 
            dateParser.filter($scope.date, dateFormat));
        })), ngModel.$viewChangeListeners.push(function() {
            $scope.date = parseDateString(ngModel.$viewValue);
        }), $element.on("keydown", inputKeydownBind), $popup = $compile(popupEl)($scope), 
        popupEl.remove(), appendToBody ? $document.find("body").append($popup) : $element.after($popup), 
        $scope.$on("$destroy", function() {
            for (!0 === $scope.isOpen && ($rootScope.$$phase || $scope.$apply(function() {
                $scope.isOpen = !1;
            })), $popup.remove(), $element.off("keydown", inputKeydownBind), $document.off("click", documentClickBind), 
            scrollParentEl && scrollParentEl.off("scroll", positionPopup), angular.element($window).off("resize", positionPopup); watchListeners.length; ) watchListeners.shift()();
        });
    }, $scope.getText = function(key) {
        return $scope[key + "Text"] || datepickerPopupConfig[key + "Text"];
    }, $scope.isDisabled = function(date) {
        "today" === date && (date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption("timezone")));
        var dates = {};
        return angular.forEach([ "minDate", "maxDate" ], function(key) {
            $scope.datepickerOptions[key] ? angular.isDate($scope.datepickerOptions[key]) ? dates[key] = new Date($scope.datepickerOptions[key]) : ($datepickerPopupLiteralWarning && $log.warn("Literal date support has been deprecated, please switch to date object usage"), 
            dates[key] = new Date(dateFilter($scope.datepickerOptions[key], "medium"))) : dates[key] = null;
        }), $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
    }, $scope.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    }, $scope.dateSelection = function(dt) {
        $scope.date = dt;
        var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
        $element.val(date), ngModel.$setViewValue(date), closeOnDateSelection && ($scope.isOpen = !1, 
        $element[0].focus());
    }, $scope.keydown = function(evt) {
        27 === evt.which && (evt.stopPropagation(), $scope.isOpen = !1, $element[0].focus());
    }, $scope.select = function(date, evt) {
        if (evt.stopPropagation(), "today" === date) {
            var today = new Date();
            angular.isDate($scope.date) ? (date = new Date($scope.date), date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate())) : (date = dateParser.fromTimezone(today, ngModelOptions.getOption("timezone")), 
            date.setHours(0, 0, 0, 0));
        }
        $scope.dateSelection(date);
    }, $scope.close = function(evt) {
        evt.stopPropagation(), $scope.isOpen = !1, $element[0].focus();
    }, $scope.disabled = angular.isDefined($attrs.disabled) || !1, $attrs.ngDisabled && watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
        $scope.disabled = disabled;
    })), $scope.$watch("isOpen", function(value) {
        value ? $scope.disabled ? $scope.isOpen = !1 : $timeout(function() {
            positionPopup(), onOpenFocus && $scope.$broadcast("uib:datepicker.focus"), $document.on("click", documentClickBind);
            var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
            appendToBody || $position.parsePlacement(placement)[2] ? (scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element))) && scrollParentEl.on("scroll", positionPopup) : scrollParentEl = null, 
            angular.element($window).on("resize", positionPopup);
        }, 0, !1) : ($document.off("click", documentClickBind), scrollParentEl && scrollParentEl.off("scroll", positionPopup), 
        angular.element($window).off("resize", positionPopup));
    }), $scope.$on("uib:datepicker.mode", function() {
        $timeout(positionPopup, 0, !1);
    });
} ]).directive("uibDatepickerPopup", function() {
    return {
        require: [ "ngModel", "uibDatepickerPopup" ],
        controller: "UibDatepickerPopupController",
        scope: {
            datepickerOptions: "=?",
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@"
        },
        link: function(scope, element, attrs, ctrls) {
            var ngModel = ctrls[0];
            ctrls[1].init(ngModel);
        }
    };
}).directive("uibDatepickerPopupWrap", function() {
    return {
        restrict: "A",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepickerPopup/popup.html";
        }
    };
}), angular.module("ui.bootstrap.debounce", []).factory("$$debounce", [ "$timeout", function($timeout) {
    return function(callback, debounceTime) {
        var timeoutPromise;
        return function() {
            var self = this, args = Array.prototype.slice.call(arguments);
            timeoutPromise && $timeout.cancel(timeoutPromise), timeoutPromise = $timeout(function() {
                callback.apply(self, args);
            }, debounceTime);
        };
    };
} ]), angular.module("ui.bootstrap.multiMap", []).factory("$$multiMap", function() {
    return {
        createNew: function() {
            var map = {};
            return {
                entries: function() {
                    return Object.keys(map).map(function(key) {
                        return {
                            key: key,
                            value: map[key]
                        };
                    });
                },
                get: function(key) {
                    return map[key];
                },
                hasKey: function(key) {
                    return !!map[key];
                },
                keys: function() {
                    return Object.keys(map);
                },
                put: function(key, value) {
                    map[key] || (map[key] = []), map[key].push(value);
                },
                remove: function(key, value) {
                    var values = map[key];
                    if (values) {
                        var idx = values.indexOf(value);
                        -1 !== idx && values.splice(idx, 1), values.length || delete map[key];
                    }
                }
            };
        }
    };
}), angular.module("ui.bootstrap.dropdown", [ "ui.bootstrap.multiMap", "ui.bootstrap.position" ]).constant("uibDropdownConfig", {
    appendToOpenClass: "uib-dropdown-open",
    openClass: "open"
}).service("uibDropdownService", [ "$document", "$rootScope", "$$multiMap", function($document, $rootScope, $$multiMap) {
    var openScope = null, openedContainers = $$multiMap.createNew();
    this.isOnlyOpen = function(dropdownScope, appendTo) {
        var openedDropdowns = openedContainers.get(appendTo);
        if (openedDropdowns) {
            if (openedDropdowns.reduce(function(toClose, dropdown) {
                return dropdown.scope === dropdownScope ? dropdown : toClose;
            }, {})) return 1 === openedDropdowns.length;
        }
        return !1;
    }, this.open = function(dropdownScope, element, appendTo) {
        if (openScope || $document.on("click", closeDropdown), openScope && openScope !== dropdownScope && (openScope.isOpen = !1), 
        openScope = dropdownScope, appendTo) {
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                -1 === openedDropdowns.map(function(dropdown) {
                    return dropdown.scope;
                }).indexOf(dropdownScope) && openedContainers.put(appendTo, {
                    scope: dropdownScope
                });
            } else openedContainers.put(appendTo, {
                scope: dropdownScope
            });
        }
    }, this.close = function(dropdownScope, element, appendTo) {
        if (openScope === dropdownScope && ($document.off("click", closeDropdown), $document.off("keydown", this.keybindFilter), 
        openScope = null), appendTo) {
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var dropdownToClose = openedDropdowns.reduce(function(toClose, dropdown) {
                    return dropdown.scope === dropdownScope ? dropdown : toClose;
                }, {});
                dropdownToClose && openedContainers.remove(appendTo, dropdownToClose);
            }
        }
    };
    var closeDropdown = function(evt) {
        if (openScope && openScope.isOpen && !(evt && "disabled" === openScope.getAutoClose() || evt && 3 === evt.which)) {
            var toggleElement = openScope.getToggleElement();
            if (!(evt && toggleElement && toggleElement[0].contains(evt.target))) {
                var dropdownElement = openScope.getDropdownElement();
                evt && "outsideClick" === openScope.getAutoClose() && dropdownElement && dropdownElement[0].contains(evt.target) || (openScope.focusToggleElement(), 
                openScope.isOpen = !1, $rootScope.$$phase || openScope.$apply());
            }
        }
    };
    this.keybindFilter = function(evt) {
        if (openScope) {
            var dropdownElement = openScope.getDropdownElement(), toggleElement = openScope.getToggleElement(), dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target), toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
            27 === evt.which ? (evt.stopPropagation(), openScope.focusToggleElement(), closeDropdown()) : openScope.isKeynavEnabled() && -1 !== [ 38, 40 ].indexOf(evt.which) && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted) && (evt.preventDefault(), 
            evt.stopPropagation(), openScope.focusDropdownEntry(evt.which));
        }
    };
} ]).controller("UibDropdownController", [ "$scope", "$element", "$attrs", "$parse", "uibDropdownConfig", "uibDropdownService", "$animate", "$uibPosition", "$document", "$compile", "$templateRequest", function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    function removeDropdownMenu() {
        $element.append(self.dropdownMenu);
    }
    var templateScope, getIsOpen, self = this, scope = $scope.$new(), appendToOpenClass = dropdownConfig.appendToOpenClass, openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, keynavEnabled = !1, body = $document.find("body");
    $element.addClass("dropdown"), this.init = function() {
        $attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, 
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
        })), keynavEnabled = angular.isDefined($attrs.keyboardNav);
    }, this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen, angular.isFunction(setIsOpen) && setIsOpen(scope, scope.isOpen), 
        scope.isOpen;
    }, this.isOpen = function() {
        return scope.isOpen;
    }, scope.getToggleElement = function() {
        return self.toggleElement;
    }, scope.getAutoClose = function() {
        return $attrs.autoClose || "always";
    }, scope.getElement = function() {
        return $element;
    }, scope.isKeynavEnabled = function() {
        return keynavEnabled;
    }, scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find("a") : $element.find("ul").eq(0).find("a");
        switch (keyCode) {
          case 40:
            angular.isNumber(self.selectedOption) ? self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1 : self.selectedOption = 0;
            break;

          case 38:
            angular.isNumber(self.selectedOption) ? self.selectedOption = 0 === self.selectedOption ? 0 : self.selectedOption - 1 : self.selectedOption = elems.length - 1;
        }
        elems[self.selectedOption].focus();
    }, scope.getDropdownElement = function() {
        return self.dropdownMenu;
    }, scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus();
    }, scope.$watch("isOpen", function(isOpen, wasOpen) {
        var appendTo = null, appendToBody = !1;
        if (angular.isDefined($attrs.dropdownAppendTo)) {
            var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
            appendToEl && (appendTo = angular.element(appendToEl));
        }
        if (angular.isDefined($attrs.dropdownAppendToBody)) {
            !1 !== $parse($attrs.dropdownAppendToBody)(scope) && (appendToBody = !0);
        }
        if (appendToBody && !appendTo && (appendTo = body), appendTo && self.dropdownMenu && (isOpen ? (appendTo.append(self.dropdownMenu), 
        $element.on("$destroy", removeDropdownMenu)) : ($element.off("$destroy", removeDropdownMenu), 
        removeDropdownMenu())), appendTo && self.dropdownMenu) {
            var css, rightalign, scrollbarPadding, pos = $position.positionElements($element, self.dropdownMenu, "bottom-left", !0), scrollbarWidth = 0;
            if (css = {
                top: pos.top + "px",
                display: isOpen ? "block" : "none"
            }, rightalign = self.dropdownMenu.hasClass("dropdown-menu-right"), rightalign ? (css.left = "auto", 
            scrollbarPadding = $position.scrollbarPadding(appendTo), scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && (scrollbarWidth = scrollbarPadding.scrollbarWidth), 
            css.right = window.innerWidth - scrollbarWidth - (pos.left + $element.prop("offsetWidth")) + "px") : (css.left = pos.left + "px", 
            css.right = "auto"), !appendToBody) {
                var appendOffset = $position.offset(appendTo);
                css.top = pos.top - appendOffset.top + "px", rightalign ? css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop("offsetWidth")) + "px" : css.left = pos.left - appendOffset.left + "px";
            }
            self.dropdownMenu.css(css);
        }
        var openContainer = appendTo || $element, dropdownOpenClass = appendTo ? appendToOpenClass : openClass, hasOpenClass = openContainer.hasClass(dropdownOpenClass), isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);
        if (hasOpenClass === !isOpen) {
            var toggleClass;
            toggleClass = appendTo ? isOnlyOpen ? "removeClass" : "addClass" : isOpen ? "addClass" : "removeClass", 
            $animate[toggleClass](openContainer, dropdownOpenClass).then(function() {
                angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
                    open: !!isOpen
                });
            });
        }
        if (isOpen) self.dropdownMenuTemplateUrl ? $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new(), $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl, $document.on("keydown", uibDropdownService.keybindFilter);
            });
        }) : $document.on("keydown", uibDropdownService.keybindFilter), scope.focusToggleElement(), 
        uibDropdownService.open(scope, $element, appendTo); else {
            if (uibDropdownService.close(scope, $element, appendTo), self.dropdownMenuTemplateUrl) {
                templateScope && templateScope.$destroy();
                var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl;
            }
            self.selectedOption = null;
        }
        angular.isFunction(setIsOpen) && setIsOpen($scope, isOpen);
    });
} ]).directive("uibDropdown", function() {
    return {
        controller: "UibDropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init();
        }
    };
}).directive("uibDropdownMenu", function() {
    return {
        restrict: "A",
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl && !angular.isDefined(attrs.dropdownNested)) {
                element.addClass("dropdown-menu");
                var tplUrl = attrs.templateUrl;
                tplUrl && (dropdownCtrl.dropdownMenuTemplateUrl = tplUrl), dropdownCtrl.dropdownMenu || (dropdownCtrl.dropdownMenu = element);
            }
        }
    };
}).directive("uibDropdownToggle", function() {
    return {
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                element.addClass("dropdown-toggle"), dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                };
                element.on("click", toggleDropdown), element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }), scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen);
                }), scope.$on("$destroy", function() {
                    element.off("click", toggleDropdown);
                });
            }
        }
    };
}), angular.module("ui.bootstrap.stackedMap", []).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key === stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key === stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.pop();
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}), angular.module("ui.bootstrap.modal", [ "ui.bootstrap.multiMap", "ui.bootstrap.stackedMap", "ui.bootstrap.position" ]).provider("$uibResolve", function() {
    var resolve = this;
    this.resolver = null, this.setResolver = function(resolver) {
        this.resolver = resolver;
    }, this.$get = [ "$injector", "$q", function($injector, $q) {
        var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
        return {
            resolve: function(invocables, locals, parent, self) {
                if (resolver) return resolver.resolve(invocables, locals, parent, self);
                var promises = [];
                return angular.forEach(invocables, function(value) {
                    angular.isFunction(value) || angular.isArray(value) ? promises.push($q.resolve($injector.invoke(value))) : angular.isString(value) ? promises.push($q.resolve($injector.get(value))) : promises.push($q.resolve(value));
                }), $q.all(promises).then(function(resolves) {
                    var resolveObj = {}, resolveIter = 0;
                    return angular.forEach(invocables, function(value, key) {
                        resolveObj[key] = resolves[resolveIter++];
                    }), resolveObj;
                });
            }
        };
    } ];
}).directive("uibModalBackdrop", [ "$animate", "$injector", "$uibModalStack", function($animate, $injector, $modalStack) {
    function linkFn(scope, element, attrs) {
        attrs.modalInClass && ($animate.addClass(element, attrs.modalInClass), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            scope.modalOptions.animation ? $animate.removeClass(element, attrs.modalInClass).then(done) : done();
        }));
    }
    return {
        restrict: "A",
        compile: function(tElement, tAttrs) {
            return tElement.addClass(tAttrs.backdropClass), linkFn;
        }
    };
} ]).directive("uibModalWindow", [ "$uibModalStack", "$q", "$animateCss", "$document", function($modalStack, $q, $animateCss, $document) {
    return {
        scope: {
            index: "@"
        },
        restrict: "A",
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "uib/template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowTopClass || ""), scope.size = attrs.size, scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" !== modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            }, element.on("click", scope.close), scope.$isRendered = !0;
            var modalRenderDeferObj = $q.defer();
            scope.$$postDigest(function() {
                modalRenderDeferObj.resolve();
            }), modalRenderDeferObj.promise.then(function() {
                var animationPromise = null;
                attrs.modalInClass && (animationPromise = $animateCss(element, {
                    addClass: attrs.modalInClass
                }).start(), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                    var done = setIsAsync();
                    $animateCss(element, {
                        removeClass: attrs.modalInClass
                    }).start().then(done);
                })), $q.when(animationPromise).then(function() {
                    var modal = $modalStack.getTop();
                    if (modal && $modalStack.modalRendered(modal.key), !$document[0].activeElement || !element[0].contains($document[0].activeElement)) {
                        var inputWithAutofocus = element[0].querySelector("[autofocus]");
                        inputWithAutofocus ? inputWithAutofocus.focus() : element[0].focus();
                    }
                });
            });
        }
    };
} ]).directive("uibModalAnimationClass", function() {
    return {
        compile: function(tElement, tAttrs) {
            tAttrs.modalAnimation && tElement.addClass(tAttrs.uibModalAnimationClass);
        }
    };
}).directive("uibModalTransclude", [ "$animate", function($animate) {
    return {
        link: function(scope, element, attrs, controller, transclude) {
            transclude(scope.$parent, function(clone) {
                element.empty(), $animate.enter(clone, element);
            });
        }
    };
} ]).factory("$uibModalStack", [ "$animate", "$animateCss", "$document", "$compile", "$rootScope", "$q", "$$multiMap", "$$stackedMap", "$uibPosition", function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
    function snake_case(name) {
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? "-" : "") + letter.toLowerCase();
        });
    }
    function isVisible(element) {
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
    }
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex > -1 && topBackdropIndex < topModalIndex && (topBackdropIndex = topModalIndex), 
        topBackdropIndex;
    }
    function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value, appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance), previousTopOpenedModal = openedWindows.top(), 
        previousTopOpenedModal && (topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr("index"), 10)), 
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
            var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
            openedClasses.remove(modalBodyClass, modalInstance);
            var areAnyOpen = openedClasses.hasKey(modalBodyClass);
            appendToElement.toggleClass(modalBodyClass, areAnyOpen), !areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && (scrollbarPadding.originalRight ? appendToElement.css({
                paddingRight: scrollbarPadding.originalRight + "px"
            }) : appendToElement.css({
                paddingRight: ""
            }), scrollbarPadding = null), toggleTopWindowClass(!0);
        }, modalWindow.closedDeferred), checkRemoveBackdrop(), elementToReceiveFocus && elementToReceiveFocus.focus ? elementToReceiveFocus.focus() : appendToElement.focus && appendToElement.focus();
    }
    function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        openedWindows.length() > 0 && (modalWindow = openedWindows.top().value, modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || "", toggleSwitch));
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && -1 === backdropIndex()) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function() {
                backdropScopeRef = null;
            }), backdropDomEl = void 0, backdropScope = void 0;
        }
    }
    function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, $animate.leave(domEl).then(function() {
                done && done(), domEl.remove(), closedDeferred && closedDeferred.resolve();
            }), scope.$destroy());
        }
        var asyncDeferred, asyncPromise = null, setIsAsync = function() {
            return asyncDeferred || (asyncDeferred = $q.defer(), asyncPromise = asyncDeferred.promise), 
            function() {
                asyncDeferred.resolve();
            };
        };
        return scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync), $q.when(asyncPromise).then(afterAnimating);
    }
    function keydownListener(evt) {
        if (evt.isDefaultPrevented()) return evt;
        var modal = openedWindows.top();
        if (modal) switch (evt.which) {
          case 27:
            modal.value.keyboard && (evt.preventDefault(), $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, "escape key press");
            }));
            break;

          case 9:
            var list = $modalStack.loadFocusElementList(modal), focusChanged = !1;
            evt.shiftKey ? ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) && (focusChanged = $modalStack.focusLastFocusableElement(list)) : $modalStack.isFocusInLastItem(evt, list) && (focusChanged = $modalStack.focusFirstFocusableElement(list)), 
            focusChanged && (evt.preventDefault(), evt.stopPropagation());
        }
    }
    function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast("modal.closing", resultOrReason, closing).defaultPrevented;
    }
    function unhideBackgroundElements() {
        Array.prototype.forEach.call(document.querySelectorAll("[" + ARIA_HIDDEN_ATTRIBUTE_NAME + "]"), function(hiddenEl) {
            var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10), newHiddenCount = ariaHiddenCount - 1;
            hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount), newHiddenCount || (hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 
            hiddenEl.removeAttribute("aria-hidden"));
        });
    }
    var backdropDomEl, backdropScope, scrollbarPadding, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), openedClasses = $$multiMap.createNew(), $modalStack = {
        NOW_CLOSING_EVENT: "modal.stack.now-closing"
    }, topModalIndex = 0, previousTopOpenedModal = null, ARIA_HIDDEN_ATTRIBUTE_NAME = "data-bootstrap-modal-aria-hidden-count", SNAKE_CASE_REGEXP = /[A-Z]/g;
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.on("keydown", keydownListener), $rootScope.$on("$destroy", function() {
        $document.off("keydown", keydownListener);
    }), $modalStack.open = function(modalInstance, modal) {
        function applyAriaHidden(el) {
            if (el && "BODY" !== el[0].tagName) return function(el) {
                var children = el.parent() ? el.parent().children() : [];
                return Array.prototype.filter.call(children, function(child) {
                    return child !== el[0];
                });
            }(el).forEach(function(sibling) {
                var elemIsAlreadyHidden = "true" === sibling.getAttribute("aria-hidden"), ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);
                ariaHiddenCount || (ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0), sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1), 
                sibling.setAttribute("aria-hidden", "true");
            }), applyAriaHidden(el.parent());
        }
        var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(!1), previousTopOpenedModal = openedWindows.top(), openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            renderDeferred: modal.renderDeferred,
            closedDeferred: modal.closedDeferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard,
            openedClass: modal.openedClass,
            windowTopClass: modal.windowTopClass,
            animation: modal.animation,
            appendTo: modal.appendTo
        }), openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo, currBackdropIndex = backdropIndex();
        currBackdropIndex >= 0 && !backdropDomEl && (backdropScope = $rootScope.$new(!0), 
        backdropScope.modalOptions = modal, backdropScope.index = currBackdropIndex, backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'), 
        backdropDomEl.attr({
            class: "modal-backdrop",
            "ng-style": "{'z-index': 1040 + (index && 1 || 0) + index*10}",
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in"
        }), modal.backdropClass && backdropDomEl.addClass(modal.backdropClass), modal.animation && backdropDomEl.attr("modal-animation", "true"), 
        $compile(backdropDomEl)(backdropScope), $animate.enter(backdropDomEl, appendToElement), 
        $uibPosition.isScrollable(appendToElement) && (scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement), 
        scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && appendToElement.css({
            paddingRight: scrollbarPadding.right + "px"
        })));
        var content;
        modal.component ? (content = document.createElement(snake_case(modal.component.name)), 
        content = angular.element(content), content.attr({
            resolve: "$resolve",
            "modal-instance": "$uibModalInstance",
            close: "$close($value)",
            dismiss: "$dismiss($value)"
        })) : content = modal.content, topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr("index"), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
            class: "modal",
            "template-url": modal.windowTemplateUrl,
            "window-top-class": modal.windowTopClass,
            role: "dialog",
            "aria-labelledby": modal.ariaLabelledBy,
            "aria-describedby": modal.ariaDescribedBy,
            size: modal.size,
            index: topModalIndex,
            animate: "animate",
            "ng-style": "{'z-index': 1050 + $$topModalIndex*10, display: 'block'}",
            tabindex: -1,
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in"
        }).append(content), modal.windowClass && angularDomEl.addClass(modal.windowClass), 
        modal.animation && angularDomEl.attr("modal-animation", "true"), appendToElement.addClass(modalBodyClass), 
        modal.scope && (modal.scope.$$topModalIndex = topModalIndex), $animate.enter($compile(angularDomEl)(modal.scope), appendToElement), 
        openedWindows.top().value.modalDomEl = angularDomEl, openedWindows.top().value.modalOpener = modalOpener, 
        applyAriaHidden(angularDomEl);
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        return unhideBackgroundElements(), modalWindow && broadcastClosing(modalWindow, result, !0) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.resolve(result), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        return unhideBackgroundElements(), modalWindow && broadcastClosing(modalWindow, reason, !1) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.reject(reason), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal && this.dismiss(topModal.key, reason); ) topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        modalWindow && modalWindow.value.renderDeferred.resolve();
    }, $modalStack.focusFirstFocusableElement = function(list) {
        return list.length > 0 && (list[0].focus(), !0);
    }, $modalStack.focusLastFocusableElement = function(list) {
        return list.length > 0 && (list[list.length - 1].focus(), !0);
    }, $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
            var modalDomEl = modalWindow.value.modalDomEl;
            if (modalDomEl && modalDomEl.length) return (evt.target || evt.srcElement) === modalDomEl[0];
        }
        return !1;
    }, $modalStack.isFocusInFirstItem = function(evt, list) {
        return list.length > 0 && (evt.target || evt.srcElement) === list[0];
    }, $modalStack.isFocusInLastItem = function(evt, list) {
        return list.length > 0 && (evt.target || evt.srcElement) === list[list.length - 1];
    }, $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 && modalDomE1.length) {
                var elements = modalDomE1[0].querySelectorAll("a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]");
                return elements ? Array.prototype.filter.call(elements, function(element) {
                    return isVisible(element);
                }) : elements;
            }
        }
    }, $modalStack;
} ]).provider("$uibModal", function() {
    var $modalProvider = {
        options: {
            animation: !0,
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$rootScope", "$q", "$document", "$templateRequest", "$controller", "$uibResolve", "$uibModalStack", function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
            }
            var $modal = {}, promiseChain = null;
            return $modal.getPromiseChain = function() {
                return promiseChain;
            }, $modal.open = function(modalOptions) {
                function resolveWithTemplate() {
                    return templateAndResolvePromise;
                }
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalClosedDeferred = $q.defer(), modalRenderDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    closed: modalClosedDeferred.promise,
                    rendered: modalRenderDeferred.promise,
                    close: function(result) {
                        return $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        return $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, 
                modalOptions.appendTo = modalOptions.appendTo || $document.find("body").eq(0), !modalOptions.appendTo.length) throw new Error("appendTo element not found. Make sure that the element passed is in DOM.");
                if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of component or template or templateUrl options is required.");
                var templateAndResolvePromise;
                templateAndResolvePromise = modalOptions.component ? $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null)) : $q.all([ getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null) ]);
                var samePromise;
                return samePromise = promiseChain = $q.all([ promiseChain ]).then(resolveWithTemplate, resolveWithTemplate).then(function(tplAndVars) {
                    function constructLocals(obj, template, instanceOnScope, injectable) {
                        obj.$scope = modalScope, obj.$scope.$resolve = {}, instanceOnScope ? obj.$scope.$uibModalInstance = modalInstance : obj.$uibModalInstance = modalInstance;
                        var resolves = template ? tplAndVars[1] : tplAndVars;
                        angular.forEach(resolves, function(value, key) {
                            injectable && (obj[key] = value), obj.$scope.$resolve[key] = value;
                        });
                    }
                    var providedScope = modalOptions.scope || $rootScope, modalScope = providedScope.$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss, 
                    modalScope.$on("$destroy", function() {
                        modalScope.$$uibDestructionScheduled || modalScope.$dismiss("$uibUnscheduledDestruction");
                    });
                    var ctrlInstance, ctrlInstantiate, modal = {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        renderDeferred: modalRenderDeferred,
                        closedDeferred: modalClosedDeferred,
                        animation: modalOptions.animation,
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        backdropClass: modalOptions.backdropClass,
                        windowTopClass: modalOptions.windowTopClass,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        ariaLabelledBy: modalOptions.ariaLabelledBy,
                        ariaDescribedBy: modalOptions.ariaDescribedBy,
                        size: modalOptions.size,
                        openedClass: modalOptions.openedClass,
                        appendTo: modalOptions.appendTo
                    }, component = {}, ctrlLocals = {};
                    modalOptions.component ? (constructLocals(component, !1, !0, !1), component.name = modalOptions.component, 
                    modal.component = component) : modalOptions.controller && (constructLocals(ctrlLocals, !0, !1, !0), 
                    ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, !0, modalOptions.controllerAs), 
                    modalOptions.controllerAs && modalOptions.bindToController && (ctrlInstance = ctrlInstantiate.instance, 
                    ctrlInstance.$close = modalScope.$close, ctrlInstance.$dismiss = modalScope.$dismiss, 
                    angular.extend(ctrlInstance, {
                        $resolve: ctrlLocals.$scope.$resolve
                    }, providedScope)), ctrlInstance = ctrlInstantiate(), angular.isFunction(ctrlInstance.$onInit) && ctrlInstance.$onInit()), 
                    modalOptions.component || (modal.content = tplAndVars[0]), $modalStack.open(modalInstance, modal), 
                    modalOpenedDeferred.resolve(!0);
                }, function(reason) {
                    modalOpenedDeferred.reject(reason), modalResultDeferred.reject(reason);
                }).finally(function() {
                    promiseChain === samePromise && (promiseChain = null);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("ui.bootstrap.paging", []).factory("uibPaging", [ "$parse", function($parse) {
    return {
        create: function(ctrl, $scope, $attrs) {
            ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop, 
            ctrl.ngModelCtrl = {
                $setViewValue: angular.noop
            }, ctrl._watchers = [], ctrl.init = function(ngModelCtrl, config) {
                ctrl.ngModelCtrl = ngModelCtrl, ctrl.config = config, ngModelCtrl.$render = function() {
                    ctrl.render();
                }, $attrs.itemsPerPage ? ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
                    ctrl.itemsPerPage = parseInt(value, 10), $scope.totalPages = ctrl.calculateTotalPages(), 
                    ctrl.updatePage();
                })) : ctrl.itemsPerPage = config.itemsPerPage, $scope.$watch("totalItems", function(newTotal, oldTotal) {
                    (angular.isDefined(newTotal) || newTotal !== oldTotal) && ($scope.totalPages = ctrl.calculateTotalPages(), 
                    ctrl.updatePage());
                });
            }, ctrl.calculateTotalPages = function() {
                var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
                return Math.max(totalPages || 0, 1);
            }, ctrl.render = function() {
                $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
            }, $scope.selectPage = function(page, evt) {
                evt && evt.preventDefault(), (!$scope.ngDisabled || !evt) && $scope.page !== page && page > 0 && page <= $scope.totalPages && (evt && evt.target && evt.target.blur(), 
                ctrl.ngModelCtrl.$setViewValue(page), ctrl.ngModelCtrl.$render());
            }, $scope.getText = function(key) {
                return $scope[key + "Text"] || ctrl.config[key + "Text"];
            }, $scope.noPrevious = function() {
                return 1 === $scope.page;
            }, $scope.noNext = function() {
                return $scope.page === $scope.totalPages;
            }, ctrl.updatePage = function() {
                ctrl.setNumPages($scope.$parent, $scope.totalPages), $scope.page > $scope.totalPages ? $scope.selectPage($scope.totalPages) : ctrl.ngModelCtrl.$render();
            }, $scope.$on("$destroy", function() {
                for (;ctrl._watchers.length; ) ctrl._watchers.shift()();
            });
        }
    };
} ]), angular.module("ui.bootstrap.pager", [ "ui.bootstrap.paging", "ui.bootstrap.tabindex" ]).controller("UibPagerController", [ "$scope", "$attrs", "uibPaging", "uibPagerConfig", function($scope, $attrs, uibPaging, uibPagerConfig) {
    $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align, 
    uibPaging.create(this, $scope, $attrs);
} ]).constant("uibPagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: !0
}).directive("uibPager", [ "uibPagerConfig", function(uibPagerConfig) {
    return {
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@",
            ngDisabled: "="
        },
        require: [ "uibPager", "?ngModel" ],
        restrict: "A",
        controller: "UibPagerController",
        controllerAs: "pager",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/pager/pager.html";
        },
        link: function(scope, element, attrs, ctrls) {
            element.addClass("pager");
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && paginationCtrl.init(ngModelCtrl, uibPagerConfig);
        }
    };
} ]), angular.module("ui.bootstrap.pagination", [ "ui.bootstrap.paging", "ui.bootstrap.tabindex" ]).controller("UibPaginationController", [ "$scope", "$attrs", "$parse", "uibPaging", "uibPaginationConfig", function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
    function makePage(number, text, isActive) {
        return {
            number: number,
            text: text,
            active: isActive
        };
    }
    function getPages(currentPage, totalPages) {
        var pages = [], startPage = 1, endPage = totalPages, isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
        isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1), 
        (endPage = startPage + maxSize - 1) > totalPages && (endPage = totalPages, startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
        endPage = Math.min(startPage + maxSize - 1, totalPages)));
        for (var number = startPage; number <= endPage; number++) {
            var page = makePage(number, pageLabel(number), number === currentPage);
            pages.push(page);
        }
        if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
            if (startPage > 1) {
                if (!boundaryLinkNumbers || startPage > 3) {
                    var previousPageSet = makePage(startPage - 1, "...", !1);
                    pages.unshift(previousPageSet);
                }
                if (boundaryLinkNumbers) {
                    if (3 === startPage) {
                        var secondPageLink = makePage(2, "2", !1);
                        pages.unshift(secondPageLink);
                    }
                    var firstPageLink = makePage(1, "1", !1);
                    pages.unshift(firstPageLink);
                }
            }
            if (endPage < totalPages) {
                if (!boundaryLinkNumbers || endPage < totalPages - 2) {
                    var nextPageSet = makePage(endPage + 1, "...", !1);
                    pages.push(nextPageSet);
                }
                if (boundaryLinkNumbers) {
                    if (endPage === totalPages - 2) {
                        var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, !1);
                        pages.push(secondToLastPageLink);
                    }
                    var lastPageLink = makePage(totalPages, totalPages, !1);
                    pages.push(lastPageLink);
                }
            }
        }
        return pages;
    }
    var ctrl = this, maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize, rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate, forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses, boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers, pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) {
        return $scope.$parent.$eval($attrs.pageLabel, {
            $page: idx
        });
    } : angular.identity;
    $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks, 
    $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks, 
    $attrs.$set("role", "menu"), uibPaging.create(this, $scope, $attrs), $attrs.maxSize && ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
        maxSize = parseInt(value, 10), ctrl.render();
    }));
    var originalRender = this.render;
    this.render = function() {
        originalRender(), $scope.page > 0 && $scope.page <= $scope.totalPages && ($scope.pages = getPages($scope.page, $scope.totalPages));
    };
} ]).constant("uibPaginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    boundaryLinkNumbers: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0,
    forceEllipses: !1
}).directive("uibPagination", [ "$parse", "uibPaginationConfig", function($parse, uibPaginationConfig) {
    return {
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@",
            ngDisabled: "="
        },
        require: [ "uibPagination", "?ngModel" ],
        restrict: "A",
        controller: "UibPaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/pagination/pagination.html";
        },
        link: function(scope, element, attrs, ctrls) {
            element.addClass("pagination");
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
        }
    };
} ]), angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.stackedMap" ]).provider("$uibTooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g;
        return name.replace(regexp, function(letter, pos) {
            return (pos ? "-" : "") + letter.toLowerCase();
        });
    }
    var defaultOptions = {
        placement: "top",
        placementClassPrefix: "",
        animation: !0,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: !1
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        outsideClick: "outsideClick",
        focus: "blur",
        none: ""
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$document", "$uibPosition", "$interpolate", "$rootScope", "$parse", "$$stackedMap", function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        function keypressListener(e) {
            if (27 === e.which) {
                var last = openedTooltips.top();
                last && (last.value.close(), last = null);
            }
        }
        var openedTooltips = $$stackedMap.createNew();
        return $document.on("keyup", keypressListener), $rootScope.$on("$destroy", function() {
            $document.off("keyup", keypressListener);
        }), function(ttType, prefix, defaultTriggerShow, options) {
            function getTriggers(trigger) {
                var show = (trigger || options.trigger || defaultTriggerShow).split(" ");
                return {
                    show: show,
                    hide: show.map(function(trigger) {
                        return triggerMap[trigger] || trigger;
                    })
                };
            }
            options = angular.extend({}, defaultOptions, globalOptions, options);
            var directiveName = snake_case(ttType), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup uib-title="' + startSym + "title" + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + "content" + endSym + '" ') + 'origin-scope="origScope" class="uib-position-measure ' + prefix + '" tooltip-animation-class="fade"uib-tooltip-classes ng-class="{ in: isOpen }" ></div>';
            return {
                compile: function(tElem, tAttrs) {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs, tooltipCtrl) {
                        function toggleTooltipBind() {
                            ttScope.isOpen ? hideTooltipBind() : showTooltipBind();
                        }
                        function showTooltipBind() {
                            hasEnableExp && !scope.$eval(attrs[prefix + "Enable"]) || (cancelHide(), prepareTooltip(), 
                            ttScope.popupDelay ? showTimeout || (showTimeout = $timeout(show, ttScope.popupDelay, !1)) : show());
                        }
                        function hideTooltipBind() {
                            cancelShow(), ttScope.popupCloseDelay ? hideTimeout || (hideTimeout = $timeout(hide, ttScope.popupCloseDelay, !1)) : hide();
                        }
                        function show() {
                            return cancelShow(), cancelHide(), ttScope.content ? (createTooltip(), void ttScope.$evalAsync(function() {
                                ttScope.isOpen = !0, assignIsOpen(!0), positionTooltip();
                            })) : angular.noop;
                        }
                        function cancelShow() {
                            showTimeout && ($timeout.cancel(showTimeout), showTimeout = null), positionTimeout && ($timeout.cancel(positionTimeout), 
                            positionTimeout = null);
                        }
                        function hide() {
                            ttScope && ttScope.$evalAsync(function() {
                                ttScope && (ttScope.isOpen = !1, assignIsOpen(!1), ttScope.animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 150, !1)) : removeTooltip());
                            });
                        }
                        function cancelHide() {
                            hideTimeout && ($timeout.cancel(hideTimeout), hideTimeout = null), transitionTimeout && ($timeout.cancel(transitionTimeout), 
                            transitionTimeout = null);
                        }
                        function createTooltip() {
                            tooltip || (tooltipLinkedScope = ttScope.$new(), tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                                appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip);
                            }), openedTooltips.add(ttScope, {
                                close: hide
                            }), prepObservers());
                        }
                        function removeTooltip() {
                            cancelShow(), cancelHide(), unregisterObservers(), tooltip && (tooltip.remove(), 
                            tooltip = null, adjustmentTimeout && $timeout.cancel(adjustmentTimeout)), openedTooltips.remove(ttScope), 
                            tooltipLinkedScope && (tooltipLinkedScope.$destroy(), tooltipLinkedScope = null);
                        }
                        function prepareTooltip() {
                            ttScope.title = attrs[prefix + "Title"], ttScope.content = contentParse ? contentParse(scope) : attrs[ttType], 
                            ttScope.popupClass = attrs[prefix + "Class"], ttScope.placement = angular.isDefined(attrs[prefix + "Placement"]) ? attrs[prefix + "Placement"] : options.placement;
                            var placement = $position.parsePlacement(ttScope.placement);
                            lastPlacement = placement[1] ? placement[0] + "-" + placement[1] : placement[0];
                            var delay = parseInt(attrs[prefix + "PopupDelay"], 10), closeDelay = parseInt(attrs[prefix + "PopupCloseDelay"], 10);
                            ttScope.popupDelay = isNaN(delay) ? options.popupDelay : delay, ttScope.popupCloseDelay = isNaN(closeDelay) ? options.popupCloseDelay : closeDelay;
                        }
                        function assignIsOpen(isOpen) {
                            isOpenParse && angular.isFunction(isOpenParse.assign) && isOpenParse.assign(scope, isOpen);
                        }
                        function prepObservers() {
                            observers.length = 0, contentParse ? (observers.push(scope.$watch(contentParse, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen && hide();
                            })), observers.push(tooltipLinkedScope.$watch(function() {
                                repositionScheduled || (repositionScheduled = !0, tooltipLinkedScope.$$postDigest(function() {
                                    repositionScheduled = !1, ttScope && ttScope.isOpen && positionTooltip();
                                }));
                            }))) : observers.push(attrs.$observe(ttType, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen ? hide() : positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Title", function(val) {
                                ttScope.title = val, ttScope.isOpen && positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Placement", function(val) {
                                ttScope.placement = val || options.placement, ttScope.isOpen && positionTooltip();
                            }));
                        }
                        function unregisterObservers() {
                            observers.length && (angular.forEach(observers, function(observer) {
                                observer();
                            }), observers.length = 0);
                        }
                        function bodyHideTooltipBind(e) {
                            ttScope && ttScope.isOpen && tooltip && (element[0].contains(e.target) || tooltip[0].contains(e.target) || hideTooltipBind());
                        }
                        function hideOnEscapeKey(e) {
                            27 === e.which && hideTooltipBind();
                        }
                        var tooltip, tooltipLinkedScope, transitionTimeout, showTimeout, hideTimeout, positionTimeout, adjustmentTimeout, lastPlacement, appendToBody = !!angular.isDefined(options.appendToBody) && options.appendToBody, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), ttScope = scope.$new(!0), repositionScheduled = !1, isOpenParse = !!angular.isDefined(attrs[prefix + "IsOpen"]) && $parse(attrs[prefix + "IsOpen"]), contentParse = !!options.useContentExp && $parse(attrs[ttType]), observers = [], positionTooltip = function() {
                            tooltip && tooltip.html() && (positionTimeout || (positionTimeout = $timeout(function() {
                                var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody), initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop("offsetHeight"), elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                                tooltip.css({
                                    top: ttPosition.top + "px",
                                    left: ttPosition.left + "px"
                                });
                                var placementClasses = ttPosition.placement.split("-");
                                tooltip.hasClass(placementClasses[0]) || (tooltip.removeClass(lastPlacement.split("-")[0]), 
                                tooltip.addClass(placementClasses[0])), tooltip.hasClass(options.placementClassPrefix + ttPosition.placement) || (tooltip.removeClass(options.placementClassPrefix + lastPlacement), 
                                tooltip.addClass(options.placementClassPrefix + ttPosition.placement)), adjustmentTimeout = $timeout(function() {
                                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop("offsetHeight"), adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                                    adjustment && tooltip.css(adjustment), adjustmentTimeout = null;
                                }, 0, !1), tooltip.hasClass("uib-position-measure") ? ($position.positionArrow(tooltip, ttPosition.placement), 
                                tooltip.removeClass("uib-position-measure")) : lastPlacement !== ttPosition.placement && $position.positionArrow(tooltip, ttPosition.placement), 
                                lastPlacement = ttPosition.placement, positionTimeout = null;
                            }, 0, !1)));
                        };
                        ttScope.origScope = scope, ttScope.isOpen = !1, ttScope.contentExp = function() {
                            return ttScope.content;
                        }, attrs.$observe("disabled", function(val) {
                            val && cancelShow(), val && ttScope.isOpen && hide();
                        }), isOpenParse && scope.$watch(isOpenParse, function(val) {
                            ttScope && !val === ttScope.isOpen && toggleTooltipBind();
                        });
                        var unregisterTriggers = function() {
                            triggers.show.forEach(function(trigger) {
                                "outsideClick" === trigger ? element.off("click", toggleTooltipBind) : (element.off(trigger, showTooltipBind), 
                                element.off(trigger, toggleTooltipBind)), element.off("keypress", hideOnEscapeKey);
                            }), triggers.hide.forEach(function(trigger) {
                                "outsideClick" === trigger ? $document.off("click", bodyHideTooltipBind) : element.off(trigger, hideTooltipBind);
                            });
                        };
                        !function() {
                            var showTriggers = [], hideTriggers = [], val = scope.$eval(attrs[prefix + "Trigger"]);
                            unregisterTriggers(), angular.isObject(val) ? (Object.keys(val).forEach(function(key) {
                                showTriggers.push(key), hideTriggers.push(val[key]);
                            }), triggers = {
                                show: showTriggers,
                                hide: hideTriggers
                            }) : triggers = getTriggers(val), "none" !== triggers.show && triggers.show.forEach(function(trigger, idx) {
                                "outsideClick" === trigger ? (element.on("click", toggleTooltipBind), $document.on("click", bodyHideTooltipBind)) : trigger === triggers.hide[idx] ? element.on(trigger, toggleTooltipBind) : trigger && (element.on(trigger, showTooltipBind), 
                                element.on(triggers.hide[idx], hideTooltipBind)), element.on("keypress", hideOnEscapeKey);
                            });
                        }();
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                        var appendToBodyVal, appendKey = prefix + "AppendToBody";
                        appendToBodyVal = appendKey in attrs && void 0 === attrs[appendKey] || scope.$eval(attrs[appendKey]), 
                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody, 
                        scope.$on("$destroy", function() {
                            unregisterTriggers(), removeTooltip(), ttScope = null;
                        });
                    };
                }
            };
        };
    } ];
}).directive("uibTooltipTemplateTransclude", [ "$animate", "$sce", "$compile", "$templateRequest", function($animate, $sce, $compile, $templateRequest) {
    return {
        link: function(scope, elem, attrs) {
            var currentScope, previousElement, currentElement, origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope), changeCounter = 0, cleanupLastIncludeContent = function() {
                previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                    previousElement = null;
                }), previousElement = currentElement, currentElement = null);
            };
            scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
                var thisChangeId = ++changeCounter;
                src ? ($templateRequest(src, !0).then(function(response) {
                    if (thisChangeId === changeCounter) {
                        var newScope = origScope.$new(), template = response, clone = $compile(template)(newScope, function(clone) {
                            cleanupLastIncludeContent(), $animate.enter(clone, elem);
                        });
                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src);
                    }
                }, function() {
                    thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                }), scope.$emit("$includeContentRequested", src)) : cleanupLastIncludeContent();
            }), scope.$on("$destroy", cleanupLastIncludeContent);
        }
    };
} ]).directive("uibTooltipClasses", [ "$uibPosition", function($uibPosition) {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            if (scope.placement) {
                var position = $uibPosition.parsePlacement(scope.placement);
                element.addClass(position[0]);
            }
            scope.popupClass && element.addClass(scope.popupClass), scope.animation && element.addClass(attrs.tooltipAnimationClass);
        }
    };
} ]).directive("uibTooltipPopup", function() {
    return {
        restrict: "A",
        scope: {
            content: "@"
        },
        templateUrl: "uib/template/tooltip/tooltip-popup.html"
    };
}).directive("uibTooltip", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltip", "tooltip", "mouseenter");
} ]).directive("uibTooltipTemplatePopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&",
            originScope: "&"
        },
        templateUrl: "uib/template/tooltip/tooltip-template-popup.html"
    };
}).directive("uibTooltipTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipTemplate", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]).directive("uibTooltipHtmlPopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&"
        },
        templateUrl: "uib/template/tooltip/tooltip-html-popup.html"
    };
}).directive("uibTooltipHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipHtml", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]), angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("uibPopoverTemplatePopup", function() {
    return {
        restrict: "A",
        scope: {
            uibTitle: "@",
            contentExp: "&",
            originScope: "&"
        },
        templateUrl: "uib/template/popover/popover-template.html"
    };
}).directive("uibPopoverTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverTemplate", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverHtmlPopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&",
            uibTitle: "@"
        },
        templateUrl: "uib/template/popover/popover-html.html"
    };
}).directive("uibPopoverHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverHtml", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverPopup", function() {
    return {
        restrict: "A",
        scope: {
            uibTitle: "@",
            content: "@"
        },
        templateUrl: "uib/template/popover/popover.html"
    };
}).directive("uibPopover", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopover", "popover", "click");
} ]), angular.module("ui.bootstrap.progressbar", []).constant("uibProgressConfig", {
    animate: !0,
    max: 100
}).controller("UibProgressController", [ "$scope", "$attrs", "uibProgressConfig", function($scope, $attrs, progressConfig) {
    function getMaxOrDefault() {
        return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
    }
    var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [], $scope.max = getMaxOrDefault(), this.addBar = function(bar, element, attrs) {
        animate || element.css({
            transition: "none"
        }), this.bars.push(bar), bar.max = getMaxOrDefault(), bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : "progressbar", 
        bar.$watch("value", function(value) {
            bar.recalculatePercentage();
        }), bar.recalculatePercentage = function() {
            var totalPercentage = self.bars.reduce(function(total, bar) {
                return bar.percent = +(100 * bar.value / bar.max).toFixed(2), total + bar.percent;
            }, 0);
            totalPercentage > 100 && (bar.percent -= totalPercentage - 100);
        }, bar.$on("$destroy", function() {
            element = null, self.removeBar(bar);
        });
    }, this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1), this.bars.forEach(function(bar) {
            bar.recalculatePercentage();
        });
    }, $scope.$watch("maxParam", function(maxParam) {
        self.bars.forEach(function(bar) {
            bar.max = getMaxOrDefault(), bar.recalculatePercentage();
        });
    });
} ]).directive("uibProgress", function() {
    return {
        replace: !0,
        transclude: !0,
        controller: "UibProgressController",
        require: "uibProgress",
        scope: {
            maxParam: "=?max"
        },
        templateUrl: "uib/template/progressbar/progress.html"
    };
}).directive("uibBar", function() {
    return {
        replace: !0,
        transclude: !0,
        require: "^uibProgress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "uib/template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element, attrs);
        }
    };
}).directive("uibProgressbar", function() {
    return {
        replace: !0,
        transclude: !0,
        controller: "UibProgressController",
        scope: {
            value: "=",
            maxParam: "=?max",
            type: "@"
        },
        templateUrl: "uib/template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]), {
                title: attrs.title
            });
        }
    };
}), angular.module("ui.bootstrap.rating", []).constant("uibRatingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null,
    enableReset: !0,
    titles: [ "one", "two", "three", "four", "five" ]
}).controller("UibRatingController", [ "$scope", "$attrs", "uibRatingConfig", function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
        $setViewValue: angular.noop
    }, self = this;
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, ngModelCtrl.$formatters.push(function(value) {
            return angular.isNumber(value) && value << 0 !== value && (value = Math.round(value)), 
            value;
        }), this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn, 
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff, 
        this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
    }, this.buildTemplateObjects = function(states) {
        for (var i = 0, n = states.length; i < n; i++) states[i] = angular.extend({
            index: i
        }, {
            stateOn: this.stateOn,
            stateOff: this.stateOff,
            title: this.getTitle(i)
        }, states[i]);
        return states;
    }, this.getTitle = function(index) {
        return index >= this.titles.length ? index + 1 : this.titles[index];
    }, $scope.rate = function(value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
            var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
            ngModelCtrl.$setViewValue(newViewValue), ngModelCtrl.$render();
        }
    }, $scope.enter = function(value) {
        $scope.readonly || ($scope.value = value), $scope.onHover({
            value: value
        });
    }, $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.onLeave();
    }, $scope.onKeydown = function(evt) {
        /(37|38|39|40)/.test(evt.which) && (evt.preventDefault(), evt.stopPropagation(), 
        $scope.rate($scope.value + (38 === evt.which || 39 === evt.which ? 1 : -1)));
    }, this.render = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.title = self.getTitle($scope.value - 1);
    };
} ]).directive("uibRating", function() {
    return {
        require: [ "uibRating", "ngModel" ],
        restrict: "A",
        scope: {
            readonly: "=?readOnly",
            onHover: "&",
            onLeave: "&"
        },
        controller: "UibRatingController",
        templateUrl: "uib/template/rating/rating.html",
        link: function(scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
}), angular.module("ui.bootstrap.tabs", []).controller("UibTabsetController", [ "$scope", function($scope) {
    function findTabIndex(index) {
        for (var i = 0; i < ctrl.tabs.length; i++) if (ctrl.tabs[i].index === index) return i;
    }
    var oldIndex, ctrl = this;
    ctrl.tabs = [], ctrl.select = function(index, evt) {
        if (!destroyed) {
            var previousIndex = findTabIndex(oldIndex), previousSelected = ctrl.tabs[previousIndex];
            if (previousSelected) {
                if (previousSelected.tab.onDeselect({
                    $event: evt,
                    $selectedIndex: index
                }), evt && evt.isDefaultPrevented()) return;
                previousSelected.tab.active = !1;
            }
            var selected = ctrl.tabs[index];
            selected ? (selected.tab.onSelect({
                $event: evt
            }), selected.tab.active = !0, ctrl.active = selected.index, oldIndex = selected.index) : !selected && angular.isDefined(oldIndex) && (ctrl.active = null, 
            oldIndex = null);
        }
    }, ctrl.addTab = function(tab) {
        if (ctrl.tabs.push({
            tab: tab,
            index: tab.index
        }), ctrl.tabs.sort(function(t1, t2) {
            return t1.index > t2.index ? 1 : t1.index < t2.index ? -1 : 0;
        }), tab.index === ctrl.active || !angular.isDefined(ctrl.active) && 1 === ctrl.tabs.length) {
            var newActiveIndex = findTabIndex(tab.index);
            ctrl.select(newActiveIndex);
        }
    }, ctrl.removeTab = function(tab) {
        for (var index, i = 0; i < ctrl.tabs.length; i++) if (ctrl.tabs[i].tab === tab) {
            index = i;
            break;
        }
        if (ctrl.tabs[index].index === ctrl.active) {
            var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
            ctrl.select(newActiveTabIndex);
        }
        ctrl.tabs.splice(index, 1);
    }, $scope.$watch("tabset.active", function(val) {
        angular.isDefined(val) && val !== oldIndex && ctrl.select(findTabIndex(val));
    });
    var destroyed;
    $scope.$on("$destroy", function() {
        destroyed = !0;
    });
} ]).directive("uibTabset", function() {
    return {
        transclude: !0,
        replace: !0,
        scope: {},
        bindToController: {
            active: "=?",
            type: "@"
        },
        controller: "UibTabsetController",
        controllerAs: "tabset",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/tabs/tabset.html";
        },
        link: function(scope, element, attrs) {
            scope.vertical = !!angular.isDefined(attrs.vertical) && scope.$parent.$eval(attrs.vertical), 
            scope.justified = !!angular.isDefined(attrs.justified) && scope.$parent.$eval(attrs.justified);
        }
    };
}).directive("uibTab", [ "$parse", function($parse) {
    return {
        require: "^uibTabset",
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/tabs/tab.html";
        },
        transclude: !0,
        scope: {
            heading: "@",
            index: "=?",
            classes: "@?",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        controllerAs: "tab",
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
            scope.disabled = !1, attrs.disable && scope.$parent.$watch($parse(attrs.disable), function(value) {
                scope.disabled = !!value;
            }), angular.isUndefined(attrs.index) && (tabsetCtrl.tabs && tabsetCtrl.tabs.length ? scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) {
                return t.index;
            })) + 1 : scope.index = 0), angular.isUndefined(attrs.classes) && (scope.classes = ""), 
            scope.select = function(evt) {
                if (!scope.disabled) {
                    for (var index, i = 0; i < tabsetCtrl.tabs.length; i++) if (tabsetCtrl.tabs[i].tab === scope) {
                        index = i;
                        break;
                    }
                    tabsetCtrl.select(index, evt);
                }
            }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                tabsetCtrl.removeTab(scope);
            }), scope.$transcludeFn = transclude;
        }
    };
} ]).directive("uibTabHeadingTransclude", function() {
    return {
        restrict: "A",
        require: "^uibTab",
        link: function(scope, elm) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
}).directive("uibTabContentTransclude", function() {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("uib-tab-heading") || node.hasAttribute("data-uib-tab-heading") || node.hasAttribute("x-uib-tab-heading") || "uib-tab-heading" === node.tagName.toLowerCase() || "data-uib-tab-heading" === node.tagName.toLowerCase() || "x-uib-tab-heading" === node.tagName.toLowerCase() || "uib:tab-heading" === node.tagName.toLowerCase());
    }
    return {
        restrict: "A",
        require: "^uibTabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node);
                });
            });
        }
    };
}), angular.module("ui.bootstrap.timepicker", []).constant("uibTimepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: !0,
    showSeconds: !1,
    meridians: null,
    readonlyInput: !1,
    mousewheel: !0,
    arrowkeys: !0,
    showSpinners: !0,
    templateUrl: "uib/template/timepicker/timepicker.html"
}).controller("UibTimepickerController", [ "$scope", "$element", "$attrs", "$parse", "$log", "$locale", "uibTimepickerConfig", function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
    function getHoursFromTemplate() {
        var hours = +$scope.hours;
        if (($scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24) && "" !== $scope.hours) return $scope.showMeridian && (12 === hours && (hours = 0), 
        $scope.meridian === meridians[1] && (hours += 12)), hours;
    }
    function getMinutesFromTemplate() {
        var minutes = +$scope.minutes;
        if (minutes >= 0 && minutes < 60 && "" !== $scope.minutes) return minutes;
    }
    function getSecondsFromTemplate() {
        var seconds = +$scope.seconds;
        return seconds >= 0 && seconds < 60 ? seconds : void 0;
    }
    function pad(value, noPad) {
        return null === value ? "" : angular.isDefined(value) && value.toString().length < 2 && !noPad ? "0" + value : value.toString();
    }
    function refresh(keyboardChange) {
        makeValid(), ngModelCtrl.$setViewValue(new Date(selected)), updateTemplate(keyboardChange);
    }
    function makeValid() {
        hoursModelCtrl && hoursModelCtrl.$setValidity("hours", !0), minutesModelCtrl && minutesModelCtrl.$setValidity("minutes", !0), 
        secondsModelCtrl && secondsModelCtrl.$setValidity("seconds", !0), ngModelCtrl.$setValidity("time", !0), 
        $scope.invalidHours = !1, $scope.invalidMinutes = !1, $scope.invalidSeconds = !1;
    }
    function updateTemplate(keyboardChange) {
        if (ngModelCtrl.$modelValue) {
            var hours = selected.getHours(), minutes = selected.getMinutes(), seconds = selected.getSeconds();
            $scope.showMeridian && (hours = 0 === hours || 12 === hours ? 12 : hours % 12), 
            $scope.hours = "h" === keyboardChange ? hours : pad(hours, !padHours), "m" !== keyboardChange && ($scope.minutes = pad(minutes)), 
            $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1], "s" !== keyboardChange && ($scope.seconds = pad(seconds)), 
            $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        } else $scope.hours = null, $scope.minutes = null, $scope.seconds = null, $scope.meridian = meridians[0];
    }
    function addSecondsToSelected(seconds) {
        selected = addSeconds(selected, seconds), refresh();
    }
    function addMinutes(selected, minutes) {
        return addSeconds(selected, 60 * minutes);
    }
    function addSeconds(date, seconds) {
        var dt = new Date(date.getTime() + 1e3 * seconds), newDate = new Date(date);
        return newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds()), newDate;
    }
    function modelIsEmpty() {
        return (null === $scope.hours || "" === $scope.hours) && (null === $scope.minutes || "" === $scope.minutes) && (!$scope.showSeconds || $scope.showSeconds && (null === $scope.seconds || "" === $scope.seconds));
    }
    var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl, selected = new Date(), watchers = [], ngModelCtrl = {
        $setViewValue: angular.noop
    }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS, padHours = !angular.isDefined($attrs.padHours) || $scope.$parent.$eval($attrs.padHours);
    $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0, $element.removeAttr("tabindex"), 
    this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, ngModelCtrl.$formatters.unshift(function(modelValue) {
            return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), secondsInputEl = inputs.eq(2);
        hoursModelCtrl = hoursInputEl.controller("ngModel"), minutesModelCtrl = minutesInputEl.controller("ngModel"), 
        secondsModelCtrl = secondsInputEl.controller("ngModel"), (angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel) && this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl), 
        (angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys) && this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl), 
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput, 
        this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    $attrs.hourStep && watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = +value;
    }));
    var minuteStep = timepickerConfig.minuteStep;
    $attrs.minuteStep && watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = +value;
    }));
    var min;
    watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
        var dt = new Date(value);
        min = isNaN(dt) ? void 0 : dt;
    }));
    var max;
    watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
        var dt = new Date(value);
        max = isNaN(dt) ? void 0 : dt;
    }));
    var disabled = !1;
    $attrs.ngDisabled && watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
        disabled = value;
    })), $scope.noIncrementHours = function() {
        var incrementedSelected = addMinutes(selected, 60 * hourStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
    }, $scope.noDecrementHours = function() {
        var decrementedSelected = addMinutes(selected, 60 * -hourStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noIncrementMinutes = function() {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
    }, $scope.noDecrementMinutes = function() {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noIncrementSeconds = function() {
        var incrementedSelected = addSeconds(selected, secondStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
    }, $scope.noDecrementSeconds = function() {
        var decrementedSelected = addSeconds(selected, -secondStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noToggleMeridian = function() {
        return selected.getHours() < 12 ? disabled || addMinutes(selected, 720) > max : disabled || addMinutes(selected, -720) < min;
    };
    var secondStep = timepickerConfig.secondStep;
    $attrs.secondStep && watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
        secondStep = +value;
    })), $scope.showSeconds = timepickerConfig.showSeconds, $attrs.showSeconds && watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
        $scope.showSeconds = !!value;
    })), $scope.showMeridian = timepickerConfig.showMeridian, $attrs.showMeridian && watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        if ($scope.showMeridian = !!value, ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            angular.isDefined(hours) && angular.isDefined(minutes) && (selected.setHours(hours), 
            refresh());
        } else updateTemplate();
    })), this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        var isScrollingUp = function(e) {
            e.originalEvent && (e = e.originalEvent);
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
        };
        hoursInputEl.on("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours()), 
            e.preventDefault();
        }), minutesInputEl.on("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes()), 
            e.preventDefault();
        }), secondsInputEl.on("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds()), 
            e.preventDefault();
        });
    }, this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        hoursInputEl.on("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementHours(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementHours(), $scope.$apply()));
        }), minutesInputEl.on("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementMinutes(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementMinutes(), $scope.$apply()));
        }), secondsInputEl.on("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementSeconds(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementSeconds(), $scope.$apply()));
        });
    }, this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        if ($scope.readonlyInput) return $scope.updateHours = angular.noop, $scope.updateMinutes = angular.noop, 
        void ($scope.updateSeconds = angular.noop);
        var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
            ngModelCtrl.$setViewValue(null), ngModelCtrl.$setValidity("time", !1), angular.isDefined(invalidHours) && ($scope.invalidHours = invalidHours, 
            hoursModelCtrl && hoursModelCtrl.$setValidity("hours", !1)), angular.isDefined(invalidMinutes) && ($scope.invalidMinutes = invalidMinutes, 
            minutesModelCtrl && minutesModelCtrl.$setValidity("minutes", !1)), angular.isDefined(invalidSeconds) && ($scope.invalidSeconds = invalidSeconds, 
            secondsModelCtrl && secondsModelCtrl.$setValidity("seconds", !1));
        };
        $scope.updateHours = function() {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(hours) && angular.isDefined(minutes) ? (selected.setHours(hours), 
            selected.setMinutes(minutes), selected < min || selected > max ? invalidate(!0) : refresh("h")) : invalidate(!0);
        }, hoursInputEl.on("blur", function(e) {
            ngModelCtrl.$setTouched(), modelIsEmpty() ? makeValid() : null === $scope.hours || "" === $scope.hours ? invalidate(!0) : !$scope.invalidHours && $scope.hours < 10 && $scope.$apply(function() {
                $scope.hours = pad($scope.hours, !padHours);
            });
        }), $scope.updateMinutes = function() {
            var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(minutes) && angular.isDefined(hours) ? (selected.setHours(hours), 
            selected.setMinutes(minutes), selected < min || selected > max ? invalidate(void 0, !0) : refresh("m")) : invalidate(void 0, !0);
        }, minutesInputEl.on("blur", function(e) {
            ngModelCtrl.$setTouched(), modelIsEmpty() ? makeValid() : null === $scope.minutes ? invalidate(void 0, !0) : !$scope.invalidMinutes && $scope.minutes < 10 && $scope.$apply(function() {
                $scope.minutes = pad($scope.minutes);
            });
        }), $scope.updateSeconds = function() {
            var seconds = getSecondsFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(seconds) ? (selected.setSeconds(seconds), 
            refresh("s")) : invalidate(void 0, void 0, !0);
        }, secondsInputEl.on("blur", function(e) {
            modelIsEmpty() ? makeValid() : !$scope.invalidSeconds && $scope.seconds < 10 && $scope.$apply(function() {
                $scope.seconds = pad($scope.seconds);
            });
        });
    }, this.render = function() {
        var date = ngModelCtrl.$viewValue;
        isNaN(date) ? (ngModelCtrl.$setValidity("time", !1), $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (date && (selected = date), 
        selected < min || selected > max ? (ngModelCtrl.$setValidity("time", !1), $scope.invalidHours = !0, 
        $scope.invalidMinutes = !0) : makeValid(), updateTemplate());
    }, $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners, 
    $scope.incrementHours = function() {
        $scope.noIncrementHours() || addSecondsToSelected(60 * hourStep * 60);
    }, $scope.decrementHours = function() {
        $scope.noDecrementHours() || addSecondsToSelected(60 * -hourStep * 60);
    }, $scope.incrementMinutes = function() {
        $scope.noIncrementMinutes() || addSecondsToSelected(60 * minuteStep);
    }, $scope.decrementMinutes = function() {
        $scope.noDecrementMinutes() || addSecondsToSelected(60 * -minuteStep);
    }, $scope.incrementSeconds = function() {
        $scope.noIncrementSeconds() || addSecondsToSelected(secondStep);
    }, $scope.decrementSeconds = function() {
        $scope.noDecrementSeconds() || addSecondsToSelected(-secondStep);
    }, $scope.toggleMeridian = function() {
        var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
        $scope.noToggleMeridian() || (angular.isDefined(minutes) && angular.isDefined(hours) ? addSecondsToSelected(720 * (selected.getHours() < 12 ? 60 : -60)) : $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0]);
    }, $scope.blur = function() {
        ngModelCtrl.$setTouched();
    }, $scope.$on("$destroy", function() {
        for (;watchers.length; ) watchers.shift()();
    });
} ]).directive("uibTimepicker", [ "uibTimepickerConfig", function(uibTimepickerConfig) {
    return {
        require: [ "uibTimepicker", "?^ngModel" ],
        restrict: "A",
        controller: "UibTimepickerController",
        controllerAs: "timepicker",
        scope: {},
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || uibTimepickerConfig.templateUrl;
        },
        link: function(scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && timepickerCtrl.init(ngModelCtrl, element.find("input"));
        }
    };
} ]), angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.debounce", "ui.bootstrap.position" ]).factory("uibTypeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + input + '".');
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).controller("UibTypeaheadController", [ "$scope", "$element", "$attrs", "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$$debounce", "$uibPosition", "uibTypeaheadParser", function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
    function fireRecalculating() {
        scope.moveInProgress || (scope.moveInProgress = !0, scope.$digest()), debouncedRecalculate();
    }
    function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
        scope.position.top += element.prop("offsetHeight");
    }
    function extractOptions(ngModelCtrl) {
        var ngModelOptions;
        return angular.version.minor < 6 ? (ngModelOptions = ngModelCtrl.$options || {}, 
        ngModelOptions.getOption = function(key) {
            return ngModelOptions[key];
        }) : ngModelOptions = ngModelCtrl.$options, ngModelOptions;
    }
    var modelCtrl, ngModelOptions, HOT_KEYS = [ 9, 13, 27, 38, 40 ], minLength = originalScope.$eval(attrs.typeaheadMinLength);
    minLength || 0 === minLength || (minLength = 1), originalScope.$watch(attrs.typeaheadMinLength, function(newVal) {
        minLength = newVal || 0 === newVal ? newVal : 1;
    });
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = !1 !== originalScope.$eval(attrs.typeaheadEditable);
    originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
        isEditable = !1 !== newVal;
    });
    var hasFocus, selected, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
        var evt = vals.$event;
        return 13 === evt.which || 9 === evt.which;
    }, onSelectCallback = $parse(attrs.typeaheadOnSelect), isSelectOnBlur = !!angular.isDefined(attrs.typeaheadSelectOnBlur) && originalScope.$eval(attrs.typeaheadSelectOnBlur), isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop, inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = !!attrs.typeaheadAppendToBody && originalScope.$eval(attrs.typeaheadAppendToBody), appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null, focusFirst = !1 !== originalScope.$eval(attrs.typeaheadFocusFirst), selectOnExact = !!attrs.typeaheadSelectOnExact && originalScope.$eval(attrs.typeaheadSelectOnExact), isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop, showHint = originalScope.$eval(attrs.typeaheadShowHint) || !1, parsedModel = $parse(attrs.ngModel), invokeModelSetter = $parse(attrs.ngModel + "($$$p)"), $setModelValue = function(scope, newValue) {
        return angular.isFunction(parsedModel(originalScope)) && ngModelOptions.getOption("getterSetter") ? invokeModelSetter(scope, {
            $$$p: newValue
        }) : parsedModel.assign(scope, newValue);
    }, parserResult = typeaheadParser.parse(attrs.uibTypeahead), scope = originalScope.$new(), offDestroy = originalScope.$on("$destroy", function() {
        scope.$destroy();
    });
    scope.$on("$destroy", offDestroy);
    var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
    element.attr({
        "aria-autocomplete": "list",
        "aria-expanded": !1,
        "aria-owns": popupId
    });
    var inputsContainer, hintInputElem;
    showHint && (inputsContainer = angular.element("<div></div>"), inputsContainer.css("position", "relative"), 
    element.after(inputsContainer), hintInputElem = element.clone(), hintInputElem.attr("placeholder", ""), 
    hintInputElem.attr("tabindex", "-1"), hintInputElem.val(""), hintInputElem.css({
        position: "absolute",
        top: "0px",
        left: "0px",
        "border-color": "transparent",
        "box-shadow": "none",
        opacity: 1,
        background: "none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)",
        color: "#999"
    }), element.css({
        position: "relative",
        "vertical-align": "top",
        "background-color": "transparent"
    }), hintInputElem.attr("id") && hintInputElem.removeAttr("id"), inputsContainer.append(hintInputElem), 
    hintInputElem.after(element));
    var popUpEl = angular.element("<div uib-typeahead-popup></div>");
    popUpEl.attr({
        id: popupId,
        matches: "matches",
        active: "activeIdx",
        select: "select(activeIdx, evt)",
        "move-in-progress": "moveInProgress",
        query: "query",
        position: "position",
        "assign-is-open": "assignIsOpen(isOpen)",
        debounce: "debounceUpdate"
    }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl), 
    angular.isDefined(attrs.typeaheadPopupTemplateUrl) && popUpEl.attr("popup-template-url", attrs.typeaheadPopupTemplateUrl);
    var resetHint = function() {
        showHint && hintInputElem.val("");
    }, resetMatches = function() {
        scope.matches = [], scope.activeIdx = -1, element.attr("aria-expanded", !1), resetHint();
    }, getMatchId = function(index) {
        return popupId + "-option-" + index;
    };
    scope.$watch("activeIdx", function(index) {
        index < 0 ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index));
    });
    var inputIsExactMatch = function(inputValue, index) {
        return !!(scope.matches.length > index && inputValue) && inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
    }, getMatchesAsync = function(inputValue, evt) {
        var locals = {
            $viewValue: inputValue
        };
        isLoadingSetter(originalScope, !0), isNoResultsSetter(originalScope, !1), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
            var onCurrentRequest = inputValue === modelCtrl.$viewValue;
            if (onCurrentRequest && hasFocus) if (matches && matches.length > 0) {
                scope.activeIdx = focusFirst ? 0 : -1, isNoResultsSetter(originalScope, !1), scope.matches.length = 0;
                for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                });
                if (scope.query = inputValue, recalculatePosition(), element.attr("aria-expanded", !0), 
                selectOnExact && 1 === scope.matches.length && inputIsExactMatch(inputValue, 0) && (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate) ? $$debounce(function() {
                    scope.select(0, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate.default) : scope.select(0, evt)), 
                showHint) {
                    var firstLabel = scope.matches[0].label;
                    angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase() ? hintInputElem.val(inputValue + firstLabel.slice(inputValue.length)) : hintInputElem.val("");
                }
            } else resetMatches(), isNoResultsSetter(originalScope, !0);
            onCurrentRequest && isLoadingSetter(originalScope, !1);
        }, function() {
            resetMatches(), isLoadingSetter(originalScope, !1), isNoResultsSetter(originalScope, !0);
        });
    };
    appendToBody && (angular.element($window).on("resize", fireRecalculating), $document.find("body").on("scroll", fireRecalculating));
    var debouncedRecalculate = $$debounce(function() {
        scope.matches.length && recalculatePosition(), scope.moveInProgress = !1;
    }, 200);
    scope.moveInProgress = !1, scope.query = void 0;
    var timeoutPromise, scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
            getMatchesAsync(inputValue);
        }, waitTime);
    }, cancelPreviousTimeout = function() {
        timeoutPromise && $timeout.cancel(timeoutPromise);
    };
    resetMatches(), scope.assignIsOpen = function(isOpen) {
        isOpenSetter(originalScope, isOpen);
    }, scope.select = function(activeIdx, evt) {
        var model, item, locals = {};
        selected = !0, locals[parserResult.itemName] = item = scope.matches[activeIdx].model, 
        model = parserResult.modelMapper(originalScope, locals), $setModelValue(originalScope, model), 
        modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0), onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals),
            $event: evt
        }), resetMatches(), !1 !== scope.$eval(attrs.typeaheadFocusOnSelect) && $timeout(function() {
            element[0].focus();
        }, 0, !1);
    }, element.on("keydown", function(evt) {
        if (0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which)) {
            var shouldSelect = isSelectEvent(originalScope, {
                $event: evt
            });
            if (-1 === scope.activeIdx && shouldSelect || 9 === evt.which && evt.shiftKey) return resetMatches(), 
            void scope.$digest();
            evt.preventDefault();
            var target;
            switch (evt.which) {
              case 27:
                evt.stopPropagation(), resetMatches(), originalScope.$digest();
                break;

              case 38:
                scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1, 
                scope.$digest(), target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[scope.activeIdx], 
                target.parentNode.scrollTop = target.offsetTop;
                break;

              case 40:
                scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, scope.$digest(), 
                target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[scope.activeIdx], target.parentNode.scrollTop = target.offsetTop;
                break;

              default:
                shouldSelect && scope.$apply(function() {
                    angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate) ? $$debounce(function() {
                        scope.select(scope.activeIdx, evt);
                    }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate.default) : scope.select(scope.activeIdx, evt);
                });
            }
        }
    }), element.on("focus", function(evt) {
        hasFocus = !0, 0 !== minLength || modelCtrl.$viewValue || $timeout(function() {
            getMatchesAsync(modelCtrl.$viewValue, evt);
        }, 0);
    }), element.on("blur", function(evt) {
        isSelectOnBlur && scope.matches.length && -1 !== scope.activeIdx && !selected && (selected = !0, 
        scope.$apply(function() {
            angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur) ? $$debounce(function() {
                scope.select(scope.activeIdx, evt);
            }, scope.debounceUpdate.blur) : scope.select(scope.activeIdx, evt);
        })), !isEditable && modelCtrl.$error.editable && (modelCtrl.$setViewValue(), scope.$apply(function() {
            modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0);
        }), element.val("")), hasFocus = !1, selected = !1;
    });
    var dismissClickHandler = function(evt) {
        element[0] !== evt.target && 3 !== evt.which && 0 !== scope.matches.length && (resetMatches(), 
        $rootScope.$$phase || originalScope.$digest());
    };
    $document.on("click", dismissClickHandler), originalScope.$on("$destroy", function() {
        $document.off("click", dismissClickHandler), (appendToBody || appendTo) && $popup.remove(), 
        appendToBody && (angular.element($window).off("resize", fireRecalculating), $document.find("body").off("scroll", fireRecalculating)), 
        popUpEl.remove(), showHint && inputsContainer.remove();
    });
    var $popup = $compile(popUpEl)(scope);
    appendToBody ? $document.find("body").append($popup) : appendTo ? angular.element(appendTo).eq(0).append($popup) : element.after($popup), 
    this.init = function(_modelCtrl) {
        modelCtrl = _modelCtrl, ngModelOptions = extractOptions(modelCtrl), scope.debounceUpdate = $parse(ngModelOptions.getOption("debounce"))(originalScope), 
        modelCtrl.$parsers.unshift(function(inputValue) {
            return hasFocus = !0, 0 === minLength || inputValue && inputValue.length >= minLength ? waitTime > 0 ? (cancelPreviousTimeout(), 
            scheduleSearchWithTimeout(inputValue)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
            cancelPreviousTimeout(), resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
            null);
        }), modelCtrl.$formatters.push(function(modelValue) {
            var candidateViewValue, emptyViewValue, locals = {};
            return isEditable || modelCtrl.$setValidity("editable", !0), inputFormatter ? (locals.$model = modelValue, 
            inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
            candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
            emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
        });
    };
} ]).directive("uibTypeahead", function() {
    return {
        controller: "UibTypeaheadController",
        require: [ "ngModel", "uibTypeahead" ],
        link: function(originalScope, element, attrs, ctrls) {
            ctrls[1].init(ctrls[0]);
        }
    };
}).directive("uibTypeaheadPopup", [ "$$debounce", function($$debounce) {
    return {
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "&",
            moveInProgress: "=",
            select: "&",
            assignIsOpen: "&",
            debounce: "&"
        },
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.popupTemplateUrl || "uib/template/typeahead/typeahead-popup.html";
        },
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                var isDropdownOpen = scope.matches.length > 0;
                return scope.assignIsOpen({
                    isOpen: isDropdownOpen
                }), isDropdownOpen;
            }, scope.isActive = function(matchIdx) {
                return scope.active === matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx, evt) {
                var debounce = scope.debounce();
                angular.isNumber(debounce) || angular.isObject(debounce) ? $$debounce(function() {
                    scope.select({
                        activeIdx: activeIdx,
                        evt: evt
                    });
                }, angular.isNumber(debounce) ? debounce : debounce.default) : scope.select({
                    activeIdx: activeIdx,
                    evt: evt
                });
            };
        }
    };
} ]).directive("uibTypeaheadMatch", [ "$templateRequest", "$compile", "$parse", function($templateRequest, $compile, $parse) {
    return {
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "uib/template/typeahead/typeahead-match.html";
            $templateRequest(tplUrl).then(function(tplContent) {
                var tplEl = angular.element(tplContent.trim());
                element.replaceWith(tplEl), $compile(tplEl)(scope);
            });
        }
    };
} ]).filter("uibTypeaheadHighlight", [ "$sce", "$injector", "$log", function($sce, $injector, $log) {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
    }
    var isSanitizePresent;
    return isSanitizePresent = $injector.has("$sanitize"), function(matchItem, query) {
        return !isSanitizePresent && containsHtml(matchItem) && $log.warn("Unsafe use of typeahead please use ngSanitize"), 
        matchItem = query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem, 
        isSanitizePresent || (matchItem = $sce.trustAsHtml(matchItem)), matchItem;
    };
} ]), angular.module("uib/template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/accordion/accordion-group.html", '<div role="tab" id="{{::headingId}}" aria-selected="{{isOpen}}" class="panel-heading" ng-keypress="toggleOpen($event)">\n  <h4 class="panel-title">\n    <a role="button" data-toggle="collapse" href aria-expanded="{{isOpen}}" aria-controls="{{::panelId}}" tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading" ng-disabled="isDisabled" uib-tabindex-toggle><span uib-accordion-header ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n  </h4>\n</div>\n<div id="{{::panelId}}" aria-labelledby="{{::headingId}}" aria-hidden="{{!isOpen}}" role="tabpanel" class="panel-collapse collapse" uib-collapse="!isOpen">\n  <div class="panel-body" ng-transclude></div>\n</div>\n');
} ]), angular.module("uib/template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/accordion/accordion.html", '<div role="tablist" class="panel-group" ng-transclude></div>');
} ]), angular.module("uib/template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/alert/alert.html", '<button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n  <span aria-hidden="true">&times;</span>\n  <span class="sr-only">Close</span>\n</button>\n<div ng-transclude></div>\n');
} ]), angular.module("uib/template/carousel/carousel.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/carousel/carousel.html", '<div class="carousel-inner" ng-transclude></div>\n<a role="button" href class="left carousel-control" ng-click="prev()" ng-class="{ disabled: isPrevDisabled() }" ng-show="slides.length > 1">\n  <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n  <span class="sr-only">previous</span>\n</a>\n<a role="button" href class="right carousel-control" ng-click="next()" ng-class="{ disabled: isNextDisabled() }" ng-show="slides.length > 1">\n  <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n  <span class="sr-only">next</span>\n</a>\n<ol class="carousel-indicators" ng-show="slides.length > 1">\n  <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n    <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n  </li>\n</ol>\n');
} ]), angular.module("uib/template/carousel/slide.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/carousel/slide.html", '<div class="text-center" ng-transclude></div>\n');
} ]), angular.module("uib/template/datepicker/datepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/datepicker.html", '<div ng-switch="datepickerMode">\n  <div uib-daypicker ng-switch-when="day" tabindex="0" class="uib-daypicker"></div>\n  <div uib-monthpicker ng-switch-when="month" tabindex="0" class="uib-monthpicker"></div>\n  <div uib-yearpicker ng-switch-when="year" tabindex="0" class="uib-yearpicker"></div>\n</div>\n');
} ]), angular.module("uib/template/datepicker/day.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/day.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n    </tr>\n    <tr>\n      <th ng-if="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-weeks" ng-repeat="row in rows track by $index" role="row">\n      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default btn-sm"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepicker/month.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/month.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::yearHeaderColspan}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-months" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepicker/year.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/year.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-years" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepickerPopup/popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepickerPopup/popup.html", '<ul role="presentation" class="uib-datepicker-popup dropdown-menu uib-position-measure" dropdown-nested ng-if="isOpen" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n  <li ng-transclude></li>\n  <li ng-if="showButtonBar" class="uib-button-bar">\n    <span class="btn-group pull-left">\n      <button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\', $event)" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n      <button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null, $event)">{{ getText(\'clear\') }}</button>\n    </span>\n    <button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close($event)">{{ getText(\'close\') }}</button>\n  </li>\n</ul>\n');
} ]), angular.module("uib/template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n");
} ]), angular.module("uib/template/pager/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/pager/pager.html", '<li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n<li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n');
} ]), angular.module("uib/template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/pagination/pagination.html", '<li role="menuitem" ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'first\')}}</a></li>\n<li role="menuitem" ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n<li role="menuitem" ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)" ng-disabled="ngDisabled&&!page.active" uib-tabindex-toggle>{{page.text}}</a></li>\n<li role="menuitem" ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n<li role="menuitem" ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'last\')}}</a></li>\n');
} ]), angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n');
} ]), angular.module("uib/template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind="content"></div>\n');
} ]), angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner"\n  uib-tooltip-template-transclude="contentExp()"\n  tooltip-template-transclude-scope="originScope()"></div>\n');
} ]), angular.module("uib/template/popover/popover-html.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-html.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind-html="contentExp()"></div>\n</div>\n');
} ]), angular.module("uib/template/popover/popover-template.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-template.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content"\n      uib-tooltip-template-transclude="contentExp()"\n      tooltip-template-transclude-scope="originScope()"></div>\n</div>\n');
} ]), angular.module("uib/template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind="content"></div>\n</div>\n');
} ]), angular.module("uib/template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n');
} ]), angular.module("uib/template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/progress.html", '<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>');
} ]), angular.module("uib/template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/progressbar.html", '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n</div>\n');
} ]), angular.module("uib/template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}" aria-valuetext="{{title}}">\n    <span ng-repeat-start="r in range track by $index" class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}"></i>\n</span>\n');
} ]), angular.module("uib/template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tabs/tab.html", '<li ng-class="[{active: active, disabled: disabled}, classes]" class="uib-tab nav-item">\n  <a href ng-click="select($event)" class="nav-link" uib-tab-heading-transclude>{{heading}}</a>\n</li>\n');
} ]), angular.module("uib/template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tabs/tabset.html", '<div>\n  <ul class="nav nav-{{tabset.type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane"\n         ng-repeat="tab in tabset.tabs"\n         ng-class="{active: tabset.active === tab.index}"\n         uib-tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n');
} ]), angular.module("uib/template/timepicker/timepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/timepicker/timepicker.html", '<table class="uib-timepicker">\n  <tbody>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-increment hours"><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-increment minutes"><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-increment seconds"><a ng-click="incrementSeconds()" ng-class="{disabled: noIncrementSeconds()}" class="btn btn-link" ng-disabled="noIncrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n    <tr>\n      <td class="form-group uib-time hours" ng-class="{\'has-error\': invalidHours}">\n        <input type="text" placeholder="HH" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementHours()" ng-blur="blur()">\n      </td>\n      <td class="uib-separator">:</td>\n      <td class="form-group uib-time minutes" ng-class="{\'has-error\': invalidMinutes}">\n        <input type="text" placeholder="MM" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementMinutes()" ng-blur="blur()">\n      </td>\n      <td ng-show="showSeconds" class="uib-separator">:</td>\n      <td class="form-group uib-time seconds" ng-class="{\'has-error\': invalidSeconds}" ng-show="showSeconds">\n        <input type="text" placeholder="SS" ng-model="seconds" ng-change="updateSeconds()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementSeconds()" ng-blur="blur()">\n      </td>\n      <td ng-show="showMeridian" class="uib-time am-pm"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n    </tr>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-decrement hours"><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-decrement minutes"><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-decrement seconds"><a ng-click="decrementSeconds()" ng-class="{disabled: noDecrementSeconds()}" class="btn btn-link" ng-disabled="noDecrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-match.html", '<a href\n   tabindex="-1"\n   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n   ng-attr-title="{{match.label}}"></a>\n');
} ]), angular.module("uib/template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li class="uib-typeahead-match" ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n');
} ]), angular.module("ui.bootstrap.carousel").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find("head").prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'), 
    angular.$$uibCarouselCss = !0;
}), angular.module("ui.bootstrap.datepicker").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'), 
    angular.$$uibDatepickerCss = !0;
}), angular.module("ui.bootstrap.position").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'), 
    angular.$$uibPositionCss = !0;
}), angular.module("ui.bootstrap.datepickerPopup").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'), 
    angular.$$uibDatepickerpopupCss = !0;
}), angular.module("ui.bootstrap.tooltip").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'), 
    angular.$$uibTooltipCss = !0;
}), angular.module("ui.bootstrap.timepicker").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-time input{width:50px;}</style>'), 
    angular.$$uibTimepickerCss = !0;
}), angular.module("ui.bootstrap.typeahead").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'), 
    angular.$$uibTypeaheadCss = !0;
}), define("angular-bootstrap", [ "angular" ], function() {}), function() {
    function addMapEntry(map, pair) {
        return map.set(pair[0], pair[1]), map;
    }
    function addSetEntry(set, value) {
        return set.add(value), set;
    }
    function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);

          case 1:
            return func.call(thisArg, args[0]);

          case 2:
            return func.call(thisArg, args[0], args[1]);

          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
    }
    function arrayEach(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length && !1 !== iteratee(array[index], index, array); ) ;
        return array;
    }
    function arrayEachRight(array, iteratee) {
        for (var length = null == array ? 0 : array.length; length-- && !1 !== iteratee(array[length], length, array); ) ;
        return array;
    }
    function arrayEvery(array, predicate) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (!predicate(array[index], index, array)) return !1;
        return !0;
    }
    function arrayFilter(array, predicate) {
        for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
            var value = array[index];
            predicate(value, index, array) && (result[resIndex++] = value);
        }
        return result;
    }
    function arrayIncludes(array, value) {
        return !!(null == array ? 0 : array.length) && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (comparator(value, array[index])) return !0;
        return !1;
    }
    function arrayMap(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; ) result[index] = iteratee(array[index], index, array);
        return result;
    }
    function arrayPush(array, values) {
        for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
        return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = null == array ? 0 : array.length;
        for (initAccum && length && (accumulator = array[++index]); ++index < length; ) accumulator = iteratee(accumulator, array[index], index, array);
        return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = null == array ? 0 : array.length;
        for (initAccum && length && (accumulator = array[--length]); length--; ) accumulator = iteratee(accumulator, array[length], length, array);
        return accumulator;
    }
    function arraySome(array, predicate) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (predicate(array[index], index, array)) return !0;
        return !1;
    }
    function asciiToArray(string) {
        return string.split("");
    }
    function asciiWords(string) {
        return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
        var result;
        return eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) return result = key, !1;
        }), result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
        for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
        return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (comparator(array[index], value)) return index;
        return -1;
    }
    function baseIsNaN(value) {
        return value !== value;
    }
    function baseMean(array, iteratee) {
        var length = null == array ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
        return function(object) {
            return null == object ? undefined : object[key];
        };
    }
    function basePropertyOf(object) {
        return function(key) {
            return null == object ? undefined : object[key];
        };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        return eachFunc(collection, function(value, index, collection) {
            accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection);
        }), accumulator;
    }
    function baseSortBy(array, comparer) {
        var length = array.length;
        for (array.sort(comparer); length--; ) array[length] = array[length].value;
        return array;
    }
    function baseSum(array, iteratee) {
        for (var result, index = -1, length = array.length; ++index < length; ) {
            var current = iteratee(array[index]);
            current !== undefined && (result = result === undefined ? current : result + current);
        }
        return result;
    }
    function baseTimes(n, iteratee) {
        for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
        return result;
    }
    function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
            return [ key, object[key] ];
        });
    }
    function baseUnary(func) {
        return function(value) {
            return func(value);
        };
    }
    function baseValues(object, props) {
        return arrayMap(props, function(key) {
            return object[key];
        });
    }
    function cacheHas(cache, key) {
        return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
        for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
        return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
        for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
        return index;
    }
    function countHolders(array, placeholder) {
        for (var length = array.length, result = 0; length--; ) array[length] === placeholder && ++result;
        return result;
    }
    function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
        return null == object ? undefined : object[key];
    }
    function hasUnicode(string) {
        return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
        for (var data, result = []; !(data = iterator.next()).done; ) result.push(data.value);
        return result;
    }
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        return map.forEach(function(value, key) {
            result[++index] = [ key, value ];
        }), result;
    }
    function overArg(func, transform) {
        return function(arg) {
            return func(transform(arg));
        };
    }
    function replaceHolders(array, placeholder) {
        for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
            var value = array[index];
            value !== placeholder && value !== PLACEHOLDER || (array[index] = PLACEHOLDER, result[resIndex++] = index);
        }
        return result;
    }
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        return set.forEach(function(value) {
            result[++index] = value;
        }), result;
    }
    function setToPairs(set) {
        var index = -1, result = Array(set.size);
        return set.forEach(function(value) {
            result[++index] = [ value, value ];
        }), result;
    }
    function strictIndexOf(array, value, fromIndex) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (array[index] === value) return index;
        return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
        for (var index = fromIndex + 1; index--; ) if (array[index] === value) return index;
        return index;
    }
    function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeSize(string) {
        for (var result = reUnicode.lastIndex = 0; reUnicode.test(string); ) ++result;
        return result;
    }
    function unicodeToArray(string) {
        return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
    }
    var undefined, LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e308, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [ [ "ary", WRAP_ARY_FLAG ], [ "bind", WRAP_BIND_FLAG ], [ "bindKey", WRAP_BIND_KEY_FLAG ], [ "curry", WRAP_CURRY_FLAG ], [ "curryRight", WRAP_CURRY_RIGHT_FLAG ], [ "flip", WRAP_FLIP_FLAG ], [ "partial", WRAP_PARTIAL_FLAG ], [ "partialRight", WRAP_PARTIAL_RIGHT_FLAG ], [ "rearg", WRAP_REARG_FLAG ] ], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsComboRange = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", rsBreakRange = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsLower = "[a-z\\xdf-\\xf6\\xf8-\\xff]", rsMisc = "[^\\ud800-\\udfff" + rsBreakRange + "\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", reOptMod = "(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?", rsOptJoin = "(?:\\u200d(?:" + [ "[^\\ud800-\\udfff]", rsRegional, rsSurrPair ].join("|") + ")[\\ufe0e\\ufe0f]?" + reOptMod + ")*", rsSeq = "[\\ufe0e\\ufe0f]?" + reOptMod + rsOptJoin, rsEmoji = "(?:" + [ "[\\u2700-\\u27bf]", rsRegional, rsSurrPair ].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [ "[^\\ud800-\\udfff]" + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, "[\\ud800-\\udfff]" ].join("|") + ")", reApos = RegExp("[']", "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([ rsUpper + "?" + rsLower + "+(?:['](?:d|ll|m|re|s|t|ve))?(?=" + [ rsBreak, rsUpper, "$" ].join("|") + ")", "(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=" + [ rsBreak, rsUpper + rsMiscLower, "$" ].join("|") + ")", rsUpper + "?" + rsMiscLower + "+(?:['](?:d|ll|m|re|s|t|ve))?", rsUpper + "+(?:['](?:D|LL|M|RE|S|T|VE))?", "\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)", "\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)", "\\d+", rsEmoji ].join("|"), "g"), reHasUnicode = RegExp("[\\u200d\\ud800-\\udfff" + rsComboRange + "\\ufe0e\\ufe0f]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = [ "Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout" ], templateCounter = -1, typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, 
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, 
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
    var deburredLetters = {
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
    }, htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
    }, htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
    }, stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
        try {
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {}
    }(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, asciiSize = baseProperty("length"), deburrLetter = basePropertyOf(deburredLetters), escapeHtmlChar = basePropertyOf(htmlEscapes), unescapeHtmlChar = basePropertyOf(htmlUnescapes), _ = function runInContext(context) {
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) return value;
                if (hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value);
            }
            return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, 
            this.__values__ = undefined;
        }
        function LazyWrapper(value) {
            this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, 
            this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
        }
        function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            return result.__actions__ = copyArray(this.__actions__), result.__dir__ = this.__dir__, 
            result.__filtered__ = this.__filtered__, result.__iteratees__ = copyArray(this.__iteratees__), 
            result.__takeCount__ = this.__takeCount__, result.__views__ = copyArray(this.__views__), 
            result;
        }
        function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1, result.__filtered__ = !0;
            } else result = this.clone(), result.__dir__ *= -1;
            return result;
        }
        function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
            var result = [];
            outer: for (;length-- && resIndex < takeCount; ) {
                index += dir;
                for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength; ) {
                    var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                    if (type == LAZY_MAP_FLAG) value = computed; else if (!computed) {
                        if (type == LAZY_FILTER_FLAG) continue outer;
                        break outer;
                    }
                }
                result[resIndex++] = value;
            }
            return result;
        }
        function Hash(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length; ) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
        }
        function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            return this.size -= result ? 1 : 0, result;
        }
        function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }
        function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
            var data = this.__data__;
            return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value, 
            this;
        }
        function ListCache(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length; ) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function listCacheClear() {
            this.__data__ = [], this.size = 0;
        }
        function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), 
            --this.size, !0);
        }
        function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
        }
        function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? (++this.size, data.push([ key, value ])) : data[index][1] = value, 
            this;
        }
        function MapCache(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            for (this.clear(); ++index < length; ) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
            }
        }
        function mapCacheClear() {
            this.size = 0, this.__data__ = {
                hash: new Hash(),
                map: new (Map || ListCache)(),
                string: new Hash()
            };
        }
        function mapCacheDelete(key) {
            var result = getMapData(this, key).delete(key);
            return this.size -= result ? 1 : 0, result;
        }
        function mapCacheGet(key) {
            return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
            return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
        }
        function SetCache(values) {
            var index = -1, length = null == values ? 0 : values.length;
            for (this.__data__ = new MapCache(); ++index < length; ) this.add(values[index]);
        }
        function setCacheAdd(value) {
            return this.__data__.set(value, HASH_UNDEFINED), this;
        }
        function setCacheHas(value) {
            return this.__data__.has(value);
        }
        function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
        }
        function stackClear() {
            this.__data__ = new ListCache(), this.size = 0;
        }
        function stackDelete(key) {
            var data = this.__data__, result = data.delete(key);
            return this.size = data.size, result;
        }
        function stackGet(key) {
            return this.__data__.get(key);
        }
        function stackHas(key) {
            return this.__data__.has(key);
        }
        function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
                var pairs = data.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([ key, value ]), 
                this.size = ++data.size, this;
                data = this.__data__ = new MapCache(pairs);
            }
            return data.set(key, value), this.size = data.size, this;
        }
        function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
            return result;
        }
        function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined;
        }
        function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
            (value === undefined || eq(object[key], value)) && (value !== undefined || key in object) || baseAssignValue(object, key, value);
        }
        function assignValue(object, key, value) {
            var objValue = object[key];
            hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || baseAssignValue(object, key, value);
        }
        function assocIndexOf(array, key) {
            for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
            return -1;
        }
        function baseAggregator(collection, setter, iteratee, accumulator) {
            return baseEach(collection, function(value, key, collection) {
                setter(accumulator, value, iteratee(value), collection);
            }), accumulator;
        }
        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
            "__proto__" == key && defineProperty ? defineProperty(object, key, {
                configurable: !0,
                enumerable: !0,
                value: value,
                writable: !0
            }) : object[key] = value;
        }
        function baseAt(object, paths) {
            for (var index = -1, length = paths.length, result = Array(length), skip = null == object; ++index < length; ) result[index] = skip ? undefined : get(object, paths[index]);
            return result;
        }
        function baseClamp(number, lower, upper) {
            return number === number && (upper !== undefined && (number = number <= upper ? number : upper), 
            lower !== undefined && (number = number >= lower ? number : lower)), number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)), 
            result !== undefined) return result;
            if (!isObject(value)) return value;
            var isArr = isArray(value);
            if (isArr) {
                if (result = initCloneArray(value), !isDeep) return copyArray(value, result);
            } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) return cloneBuffer(value, isDeep);
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                } else {
                    if (!cloneableTags[tag]) return object ? value : {};
                    result = initCloneByTag(value, tag, baseClone, isDeep);
                }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) return stacked;
            stack.set(value, result);
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys, props = isArr ? undefined : keysFunc(value);
            return arrayEach(props || value, function(subValue, key) {
                props && (key = subValue, subValue = value[key]), assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            }), result;
        }
        function baseConforms(source) {
            var props = keys(source);
            return function(object) {
                return baseConformsTo(object, source, props);
            };
        }
        function baseConformsTo(object, source, props) {
            var length = props.length;
            if (null == object) return !length;
            for (object = Object(object); length--; ) {
                var key = props[length], predicate = source[key], value = object[key];
                if (value === undefined && !(key in object) || !predicate(value)) return !1;
            }
            return !0;
        }
        function baseDelay(func, wait, args) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        function baseDifference(array, values, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, isCommon = !0, length = array.length, result = [], valuesLength = values.length;
            if (!length) return result;
            iteratee && (values = arrayMap(values, baseUnary(iteratee))), comparator ? (includes = arrayIncludesWith, 
            isCommon = !1) : values.length >= LARGE_ARRAY_SIZE && (includes = cacheHas, isCommon = !1, 
            values = new SetCache(values));
            outer: for (;++index < length; ) {
                var value = array[index], computed = null == iteratee ? value : iteratee(value);
                if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                    for (var valuesIndex = valuesLength; valuesIndex--; ) if (values[valuesIndex] === computed) continue outer;
                    result.push(value);
                } else includes(values, computed, comparator) || result.push(value);
            }
            return result;
        }
        function baseEvery(collection, predicate) {
            var result = !0;
            return baseEach(collection, function(value, index, collection) {
                return result = !!predicate(value, index, collection);
            }), result;
        }
        function baseExtremum(array, iteratee, comparator) {
            for (var index = -1, length = array.length; ++index < length; ) {
                var value = array[index], current = iteratee(value);
                if (null != current && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
            }
            return result;
        }
        function baseFill(array, value, start, end) {
            var length = array.length;
            for (start = toInteger(start), start < 0 && (start = -start > length ? 0 : length + start), 
            end = end === undefined || end > length ? length : toInteger(end), end < 0 && (end += length), 
            end = start > end ? 0 : toLength(end); start < end; ) array[start++] = value;
            return array;
        }
        function baseFilter(collection, predicate) {
            var result = [];
            return baseEach(collection, function(value, index, collection) {
                predicate(value, index, collection) && result.push(value);
            }), result;
        }
        function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length; ) {
                var value = array[index];
                depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value);
            }
            return result;
        }
        function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
                return isFunction(object[key]);
            });
        }
        function baseGet(object, path) {
            path = castPath(path, object);
            for (var index = 0, length = path.length; null != object && index < length; ) object = object[toKey(path[index++])];
            return index && index == length ? object : undefined;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseGetTag(value) {
            return null == value ? value === undefined ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
            return value > other;
        }
        function baseHas(object, key) {
            return null != object && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
            return null != object && key in Object(object);
        }
        function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee, comparator) {
            for (var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = 1 / 0, result = []; othIndex--; ) {
                var array = arrays[othIndex];
                othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))), maxLength = nativeMin(array.length, maxLength), 
                caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer: for (;++index < length && result.length < maxLength; ) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                if (value = comparator || 0 !== value ? value : 0, !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                    for (othIndex = othLength; --othIndex; ) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer;
                    }
                    seen && seen.push(computed), result.push(value);
                }
            }
            return result;
        }
        function baseInverter(object, setter, iteratee, accumulator) {
            return baseForOwn(object, function(value, key, object) {
                setter(accumulator, iteratee(value), key, object);
            }), accumulator;
        }
        function baseInvoke(object, path, args) {
            path = castPath(path, object), object = parent(object, path);
            var func = null == object ? object : object[toKey(last(path))];
            return null == func ? undefined : apply(func, object, args);
        }
        function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
            return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack));
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
                if (!isBuffer(other)) return !1;
                objIsArr = !0, objIsObj = !1;
            }
            if (isSameTag && !objIsObj) return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                }
            }
            return !!isSameTag && (stack || (stack = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack));
        }
        function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (null == object) return !length;
            for (object = Object(object); index--; ) {
                var data = matchData[index];
                if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return !1;
            }
            for (;++index < length; ) {
                data = matchData[index];
                var key = data[0], objValue = object[key], srcValue = data[1];
                if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) return !1;
                } else {
                    var stack = new Stack();
                    if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return !1;
                }
            }
            return !0;
        }
        function baseIsNative(value) {
            return !(!isObject(value) || isMasked(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
        }
        function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
            return "function" == typeof value ? value : null == value ? identity : "object" == typeof value ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
        }
        function baseKeys(object) {
            if (!isPrototype(object)) return nativeKeys(object);
            var result = [];
            for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
            return result;
        }
        function baseKeysIn(object) {
            if (!isObject(object)) return nativeKeysIn(object);
            var isProto = isPrototype(object), result = [];
            for (var key in object) ("constructor" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);
            return result;
        }
        function baseLt(value, other) {
            return value < other;
        }
        function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            return baseEach(collection, function(value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            }), result;
        }
        function baseMatches(source) {
            var matchData = getMatchData(source);
            return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
                return object === source || baseIsMatch(object, source, matchData);
            };
        }
        function baseMatchesProperty(path, srcValue) {
            return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
            object !== source && baseFor(source, function(srcValue, key) {
                if (isObject(srcValue)) stack || (stack = new Stack()), baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); else {
                    var newValue = customizer ? customizer(object[key], srcValue, key + "", object, source, stack) : undefined;
                    newValue === undefined && (newValue = srcValue), assignMergeValue(object, key, newValue);
                }
            }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
            if (stacked) return void assignMergeValue(object, key, stacked);
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined, isCommon = newValue === undefined;
            if (isCommon) {
                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, 
                newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue, 
                isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject(objValue) || srcIndex && isFunction(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
            }
            isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), 
            stack.delete(srcValue)), assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
            var length = array.length;
            if (length) return n += n < 0 ? length : 0, isIndex(n, length) ? array[n] : undefined;
        }
        function baseOrderBy(collection, iteratees, orders) {
            var index = -1;
            return iteratees = arrayMap(iteratees.length ? iteratees : [ identity ], baseUnary(getIteratee())), 
            baseSortBy(baseMap(collection, function(value, key, collection) {
                return {
                    criteria: arrayMap(iteratees, function(iteratee) {
                        return iteratee(value);
                    }),
                    index: ++index,
                    value: value
                };
            }), function(object, other) {
                return compareMultiple(object, other, orders);
            });
        }
        function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
                return hasIn(object, path);
            });
        }
        function basePickBy(object, paths, predicate) {
            for (var index = -1, length = paths.length, result = {}; ++index < length; ) {
                var path = paths[index], value = baseGet(object, path);
                predicate(value, path) && baseSet(result, castPath(path, object), value);
            }
            return result;
        }
        function basePropertyDeep(path) {
            return function(object) {
                return baseGet(object, path);
            };
        }
        function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
            for (array === values && (values = copyArray(values)), iteratee && (seen = arrayMap(array, baseUnary(iteratee))); ++index < length; ) for (var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1; ) seen !== array && splice.call(seen, fromIndex, 1), 
            splice.call(array, fromIndex, 1);
            return array;
        }
        function basePullAt(array, indexes) {
            for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
                var index = indexes[length];
                if (length == lastIndex || index !== previous) {
                    var previous = index;
                    isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index);
                }
            }
            return array;
        }
        function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
            for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--; ) result[fromRight ? length : ++index] = start, 
            start += step;
            return result;
        }
        function baseRepeat(string, n) {
            var result = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) return result;
            do {
                n % 2 && (result += string), (n = nativeFloor(n / 2)) && (string += string);
            } while (n);
            return result;
        }
        function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
            return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
            if (!isObject(object)) return object;
            path = castPath(path, object);
            for (var index = -1, length = path.length, lastIndex = length - 1, nested = object; null != nested && ++index < length; ) {
                var key = toKey(path[index]), newValue = value;
                if (index != lastIndex) {
                    var objValue = nested[key];
                    (newValue = customizer ? customizer(objValue, key, nested) : undefined) === undefined && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {});
                }
                assignValue(nested, key, newValue), nested = nested[key];
            }
            return object;
        }
        function baseShuffle(collection) {
            return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end, 
            end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
            for (var result = Array(length); ++index < length; ) result[index] = array[index + start];
            return result;
        }
        function baseSome(collection, predicate) {
            var result;
            return baseEach(collection, function(value, index, collection) {
                return !(result = predicate(value, index, collection));
            }), !!result;
        }
        function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = null == array ? low : array.length;
            if ("number" == typeof value && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                for (;low < high; ) {
                    var mid = low + high >>> 1, computed = array[mid];
                    null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid;
                }
                return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            for (var low = 0, high = null == array ? 0 : array.length, valIsNaN = value !== value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; low < high; ) {
                var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = null === computed, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                if (valIsNaN) var setLow = retHighest || othIsReflexive; else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value);
                setLow ? low = mid + 1 : high = mid;
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee) {
            for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                if (!index || !eq(computed, seen)) {
                    var seen = computed;
                    result[resIndex++] = 0 === value ? 0 : value;
                }
            }
            return result;
        }
        function baseToNumber(value) {
            return "number" == typeof value ? value : isSymbol(value) ? NAN : +value;
        }
        function baseToString(value) {
            if ("string" == typeof value) return value;
            if (isArray(value)) return arrayMap(value, baseToString) + "";
            if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result;
        }
        function baseUniq(array, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, length = array.length, isCommon = !0, result = [], seen = result;
            if (comparator) isCommon = !1, includes = arrayIncludesWith; else if (length >= LARGE_ARRAY_SIZE) {
                var set = iteratee ? null : createSet(array);
                if (set) return setToArray(set);
                isCommon = !1, includes = cacheHas, seen = new SetCache();
            } else seen = iteratee ? [] : result;
            outer: for (;++index < length; ) {
                var value = array[index], computed = iteratee ? iteratee(value) : value;
                if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                    for (var seenIndex = seen.length; seenIndex--; ) if (seen[seenIndex] === computed) continue outer;
                    iteratee && seen.push(computed), result.push(value);
                } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), 
                result.push(value));
            }
            return result;
        }
        function baseUnset(object, path) {
            return path = castPath(path, object), null == (object = parent(object, path)) || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
            for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array); ) ;
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
            var result = value;
            return result instanceof LazyWrapper && (result = result.value()), arrayReduce(actions, function(result, action) {
                return action.func.apply(action.thisArg, arrayPush([ result ], action.args));
            }, result);
        }
        function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length;
            if (length < 2) return length ? baseUniq(arrays[0]) : [];
            for (var index = -1, result = Array(length); ++index < length; ) for (var array = arrays[index], othIndex = -1; ++othIndex < length; ) othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator));
            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }
        function baseZipObject(props, values, assignFunc) {
            for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length; ) {
                var value = index < valsLength ? values[index] : undefined;
                assignFunc(result, props[index], value);
            }
            return result;
        }
        function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
            return "function" == typeof value ? value : identity;
        }
        function castPath(value, object) {
            return isArray(value) ? value : isKey(value, object) ? [ value ] : stringToPath(toString(value));
        }
        function castSlice(array, start, end) {
            var length = array.length;
            return end = end === undefined ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
        }
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            return buffer.copy(result), result;
        }
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result;
        }
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map, isDeep, cloneFunc) {
            return arrayReduce(isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map), addMapEntry, new map.constructor());
        }
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            return result.lastIndex = regexp.lastIndex, result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
            return arrayReduce(isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set), addSetEntry, new set.constructor());
        }
        function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
            if (value !== other) {
                var valIsDefined = value !== undefined, valIsNull = null === value, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined, othIsNull = null === other, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
                if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
            }
            return 0;
        }
        function compareMultiple(object, other, orders) {
            for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
                var result = compareAscending(objCriteria[index], othCriteria[index]);
                if (result) {
                    if (index >= ordersLength) return result;
                    return result * ("desc" == orders[index] ? -1 : 1);
                }
            }
            return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
            for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; ) result[leftIndex] = partials[leftIndex];
            for (;++argsIndex < holdersLength; ) (isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex]);
            for (;rangeLength--; ) result[leftIndex++] = args[argsIndex++];
            return result;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
            for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; ) result[argsIndex] = args[argsIndex];
            for (var offset = argsIndex; ++rightIndex < rightLength; ) result[offset + rightIndex] = partials[rightIndex];
            for (;++holdersIndex < holdersLength; ) (isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
            return result;
        }
        function copyArray(source, array) {
            var index = -1, length = source.length;
            for (array || (array = Array(length)); ++index < length; ) array[index] = source[index];
            return array;
        }
        function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            for (var index = -1, length = props.length; ++index < length; ) {
                var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                newValue === undefined && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
            }
            return object;
        }
        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
            return function(collection, iteratee) {
                var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                return func(collection, setter, getIteratee(iteratee, 2), accumulator);
            };
        }
        function createAssigner(assigner) {
            return baseRest(function(object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                for (customizer = assigner.length > 3 && "function" == typeof customizer ? (length--, 
                customizer) : undefined, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined : customizer, 
                length = 1), object = Object(object); ++index < length; ) {
                    var source = sources[index];
                    source && assigner(object, source, index, customizer);
                }
                return object;
            });
        }
        function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
                if (null == collection) return collection;
                if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
                for (var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); (fromRight ? index-- : ++index < length) && !1 !== iteratee(iterable[index], index, iterable); ) ;
                return collection;
            };
        }
        function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
                for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
                    var key = props[fromRight ? length : ++index];
                    if (!1 === iteratee(iterable[key], key, iterable)) break;
                }
                return object;
            };
        }
        function createBind(func, bitmask, thisArg) {
            function wrapper() {
                return (this && this !== root && this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, arguments);
            }
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            return wrapper;
        }
        function createCaseFirst(methodName) {
            return function(string) {
                string = toString(string);
                var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                return chr[methodName]() + trailing;
            };
        }
        function createCompounder(callback) {
            return function(string) {
                return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
        }
        function createCtor(Ctor) {
            return function() {
                var args = arguments;
                switch (args.length) {
                  case 0:
                    return new Ctor();

                  case 1:
                    return new Ctor(args[0]);

                  case 2:
                    return new Ctor(args[0], args[1]);

                  case 3:
                    return new Ctor(args[0], args[1], args[2]);

                  case 4:
                    return new Ctor(args[0], args[1], args[2], args[3]);

                  case 5:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                  case 6:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                  case 7:
                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                }
                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                return isObject(result) ? result : thisBinding;
            };
        }
        function createCurry(func, bitmask, arity) {
            function wrapper() {
                for (var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); index--; ) args[index] = arguments[index];
                var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                return (length -= holders.length) < arity ? createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length) : apply(this && this !== root && this instanceof wrapper ? Ctor : func, this, args);
            }
            var Ctor = createCtor(func);
            return wrapper;
        }
        function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
                var iterable = Object(collection);
                if (!isArrayLike(collection)) {
                    var iteratee = getIteratee(predicate, 3);
                    collection = keys(collection), predicate = function(key) {
                        return iteratee(iterable[key], key, iterable);
                    };
                }
                var index = findIndexFunc(collection, predicate, fromIndex);
                return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
            };
        }
        function createFlow(fromRight) {
            return flatRest(function(funcs) {
                var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                for (fromRight && funcs.reverse(); index--; ) {
                    var func = funcs[index];
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    if (prereq && !wrapper && "wrapper" == getFuncName(func)) var wrapper = new LodashWrapper([], !0);
                }
                for (index = wrapper ? index : length; ++index < length; ) {
                    func = funcs[index];
                    var funcName = getFuncName(func), data = "wrapper" == funcName ? getData(func) : undefined;
                    wrapper = data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
                return function() {
                    var args = arguments, value = args[0];
                    if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value();
                    for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length; ) result = funcs[index].call(this, result);
                    return result;
                };
            });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            function wrapper() {
                for (var length = arguments.length, args = Array(length), index = length; index--; ) args[index] = arguments[index];
                if (isCurried) var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), 
                length -= holdersCount, isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                }
                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), 
                isAry && ary < length && (args.length = ary), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)), 
                fn.apply(thisBinding, args);
            }
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
            return wrapper;
        }
        function createInverter(setter, toIteratee) {
            return function(object, iteratee) {
                return baseInverter(object, setter, toIteratee(iteratee), {});
            };
        }
        function createMathOperation(operator, defaultValue) {
            return function(value, other) {
                var result;
                if (value === undefined && other === undefined) return defaultValue;
                if (value !== undefined && (result = value), other !== undefined) {
                    if (result === undefined) return other;
                    "string" == typeof value || "string" == typeof other ? (value = baseToString(value), 
                    other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), 
                    result = operator(value, other);
                }
                return result;
            };
        }
        function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
                return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee) {
                        return apply(iteratee, thisArg, args);
                    });
                });
            });
        }
        function createPadding(length, chars) {
            chars = chars === undefined ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
            function wrapper() {
                for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; ) args[leftIndex] = partials[leftIndex];
                for (;argsLength--; ) args[leftIndex++] = arguments[++argsIndex];
                return apply(fn, isBind ? thisArg : this, args);
            }
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            return wrapper;
        }
        function createRange(fromRight) {
            return function(start, end, step) {
                return step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined), 
                start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end), 
                step = step === undefined ? start < end ? 1 : -1 : toFinite(step), baseRange(start, end, step, fromRight);
            };
        }
        function createRelationalOperation(operator) {
            return function(value, other) {
                return "string" == typeof value && "string" == typeof other || (value = toNumber(value), 
                other = toNumber(other)), operator(value, other);
            };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, (bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG)) & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
            var newData = [ func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity ], result = wrapFunc.apply(undefined, newData);
            return isLaziable(func) && setData(result, newData), result.placeholder = placeholder, 
            setWrapToString(result, func, bitmask);
        }
        function createRound(methodName) {
            var func = Math[methodName];
            return function(number, precision) {
                if (number = toNumber(number), precision = null == precision ? 0 : nativeMin(toInteger(precision), 292)) {
                    var pair = (toString(number) + "e").split("e");
                    return pair = (toString(func(pair[0] + "e" + (+pair[1] + precision))) + "e").split("e"), 
                    +(pair[0] + "e" + (+pair[1] - precision));
                }
                return func(number);
            };
        }
        function createToPairs(keysFunc) {
            return function(object) {
                var tag = getTag(object);
                return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object));
            };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            var length = partials ? partials.length : 0;
            if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), partials = holders = undefined), 
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0), arity = arity === undefined ? arity : toInteger(arity), 
            length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials, holdersRight = holders;
                partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func), newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
            if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], 
            partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0), 
            !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)), 
            bitmask && bitmask != WRAP_BIND_FLAG) result = bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? createCurry(func, bitmask, arity) : bitmask != WRAP_PARTIAL_FLAG && bitmask != (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG) || holders.length ? createHybrid.apply(undefined, newData) : createPartial(func, bitmask, thisArg, partials); else var result = createBind(func, bitmask, thisArg);
            return setWrapToString((data ? baseSetData : setData)(result, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
            return objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key) ? srcValue : objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            return isObject(objValue) && isObject(srcValue) && (stack.set(srcValue, objValue), 
            baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack), stack.delete(srcValue)), 
            objValue;
        }
        function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1;
            var stacked = stack.get(array);
            if (stacked && stack.get(other)) return stacked == other;
            var index = -1, result = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
            for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
                var arrValue = array[index], othValue = other[index];
                if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                if (compared !== undefined) {
                    if (compared) continue;
                    result = !1;
                    break;
                }
                if (seen) {
                    if (!arraySome(other, function(othValue, othIndex) {
                        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                    })) {
                        result = !1;
                        break;
                    }
                } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                    result = !1;
                    break;
                }
            }
            return stack.delete(array), stack.delete(other), result;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                object = object.buffer, other = other.buffer;

              case arrayBufferTag:
                return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));

              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case regexpTag:
              case stringTag:
                return object == other + "";

              case mapTag:
                var convert = mapToArray;

              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                var stacked = stack.get(object);
                if (stacked) return stacked == other;
                bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                return stack.delete(object), result;

              case symbolTag:
                if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
            return !1;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length;
            if (objLength != getAllKeys(other).length && !isPartial) return !1;
            for (var index = objLength; index--; ) {
                var key = objProps[index];
                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1;
            }
            var stacked = stack.get(object);
            if (stacked && stack.get(other)) return stacked == other;
            var result = !0;
            stack.set(object, other), stack.set(other, object);
            for (var skipCtor = isPartial; ++index < objLength; ) {
                key = objProps[index];
                var objValue = object[key], othValue = other[key];
                if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = !1;
                    break;
                }
                skipCtor || (skipCtor = "constructor" == key);
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1);
            }
            return stack.delete(object), stack.delete(other), result;
        }
        function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + "");
        }
        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        function getFuncName(func) {
            for (var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; length--; ) {
                var data = array[length], otherFunc = data.func;
                if (null == otherFunc || otherFunc == func) return data.name;
            }
            return result;
        }
        function getHolder(func) {
            return (hasOwnProperty.call(lodash, "placeholder") ? lodash : func).placeholder;
        }
        function getIteratee() {
            var result = lodash.iteratee || iteratee;
            return result = result === iteratee ? baseIteratee : result, arguments.length ? result(arguments[0], arguments[1]) : result;
        }
        function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
            for (var result = keys(object), length = result.length; length--; ) {
                var key = result[length], value = object[key];
                result[length] = [ key, value, isStrictComparable(value) ];
            }
            return result;
        }
        function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
        }
        function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = undefined;
                var unmasked = !0;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), 
            result;
        }
        function getView(start, end, transforms) {
            for (var index = -1, length = transforms.length; ++index < length; ) {
                var data = transforms[index], size = data.size;
                switch (data.type) {
                  case "drop":
                    start += size;
                    break;

                  case "dropRight":
                    end -= size;
                    break;

                  case "take":
                    end = nativeMin(end, start + size);
                    break;

                  case "takeRight":
                    start = nativeMax(start, end - size);
                }
            }
            return {
                start: start,
                end: end
            };
        }
        function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            for (var index = -1, length = path.length, result = !1; ++index < length; ) {
                var key = toKey(path[index]);
                if (!(result = null != object && hasFunc(object, key))) break;
                object = object[key];
            }
            return result || ++index != length ? result : !!(length = null == object ? 0 : object.length) && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
            var length = array.length, result = array.constructor(length);
            return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, 
            result.input = array.input), result;
        }
        function initCloneObject(object) {
            return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
        }
        function initCloneByTag(object, tag, cloneFunc, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case dataViewTag:
                return cloneDataView(object, isDeep);

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);

              case mapTag:
                return cloneMap(object, isDeep, cloneFunc);

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                return cloneRegExp(object);

              case setTag:
                return cloneSet(object, isDeep, cloneFunc);

              case symbolTag:
                return cloneSymbol(object);
            }
        }
        function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) return source;
            var lastIndex = length - 1;
            return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "), 
            source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
            return !!(length = null == length ? MAX_SAFE_INTEGER : length) && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) return !1;
            var type = typeof index;
            return !!("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) && eq(object[index], value);
        }
        function isKey(value, object) {
            if (isArray(value)) return !1;
            var type = typeof value;
            return !("number" != type && "symbol" != type && "boolean" != type && null != value && !isSymbol(value)) || reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object);
        }
        function isKeyable(value) {
            var type = typeof value;
            return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
        }
        function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return !1;
            if (func === other) return !0;
            var data = getData(other);
            return !!data && func === data[0];
        }
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
            var Ctor = value && value.constructor;
            return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
        }
        function isStrictComparable(value) {
            return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
            return function(object) {
                return null != object && object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
        }
        function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG), isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!isCommon && !isCombo) return data;
            srcBitmask & WRAP_BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            return value = source[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : value, 
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]), value = source[7], 
            value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8])), 
            null == data[9] && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask, 
            data;
        }
        function nativeKeysIn(object) {
            var result = [];
            if (null != object) for (var key in Object(object)) result.push(key);
            return result;
        }
        function objectToString(value) {
            return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform) {
            return start = nativeMax(start === undefined ? func.length - 1 : start, 0), function() {
                for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; ) array[index] = args[start + index];
                index = -1;
                for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index];
                return otherArgs[start] = transform(array), apply(func, this, otherArgs);
            };
        }
        function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
            for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--; ) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }
        function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                if (lastCalled = stamp, remaining > 0) {
                    if (++count >= HOT_COUNT) return arguments[0];
                } else count = 0;
                return func.apply(undefined, arguments);
            };
        }
        function shuffleSelf(array, size) {
            var index = -1, length = array.length, lastIndex = length - 1;
            for (size = size === undefined ? length : size; ++index < size; ) {
                var rand = baseRandom(index, lastIndex), value = array[rand];
                array[rand] = array[index], array[index] = value;
            }
            return array.length = size, array;
        }
        function toKey(value) {
            if ("string" == typeof value || isSymbol(value)) return value;
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result;
        }
        function toSource(func) {
            if (null != func) {
                try {
                    return funcToString.call(func);
                } catch (e) {}
                try {
                    return func + "";
                } catch (e) {}
            }
            return "";
        }
        function updateWrapDetails(details, bitmask) {
            return arrayEach(wrapFlags, function(pair) {
                var value = "_." + pair[0];
                bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
            }), details.sort();
        }
        function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) return wrapper.clone();
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            return result.__actions__ = copyArray(wrapper.__actions__), result.__index__ = wrapper.__index__, 
            result.__values__ = wrapper.__values__, result;
        }
        function chunk(array, size, guard) {
            size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
            var length = null == array ? 0 : array.length;
            if (!length || size < 1) return [];
            for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); index < length; ) result[resIndex++] = baseSlice(array, index, index += size);
            return result;
        }
        function compact(array) {
            for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                var value = array[index];
                value && (result[resIndex++] = value);
            }
            return result;
        }
        function concat() {
            var length = arguments.length;
            if (!length) return [];
            for (var args = Array(length - 1), array = arguments[0], index = length; index--; ) args[index - 1] = arguments[index];
            return arrayPush(isArray(array) ? copyArray(array) : [ array ], baseFlatten(args, 1));
        }
        function drop(array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? (n = guard || n === undefined ? 1 : toInteger(n), baseSlice(array, n < 0 ? 0 : n, length)) : [];
        }
        function dropRight(array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n, 
            baseSlice(array, 0, n < 0 ? 0 : n)) : [];
        }
        function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : [];
        }
        function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : [];
        }
        function fill(array, value, start, end) {
            var length = null == array ? 0 : array.length;
            return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0, 
            end = length), baseFill(array, value, start, end)) : [];
        }
        function findIndex(array, predicate, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = null == fromIndex ? 0 : toInteger(fromIndex);
            return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = length - 1;
            return fromIndex !== undefined && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), 
            baseFindIndex(array, getIteratee(predicate, 3), index, !0);
        }
        function flatten(array) {
            return (null == array ? 0 : array.length) ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
            return (null == array ? 0 : array.length) ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
            return (null == array ? 0 : array.length) ? (depth = depth === undefined ? 1 : toInteger(depth), 
            baseFlatten(array, depth)) : [];
        }
        function fromPairs(pairs) {
            for (var index = -1, length = null == pairs ? 0 : pairs.length, result = {}; ++index < length; ) {
                var pair = pairs[index];
                result[pair[0]] = pair[1];
            }
            return result;
        }
        function head(array) {
            return array && array.length ? array[0] : undefined;
        }
        function indexOf(array, value, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = null == fromIndex ? 0 : toInteger(fromIndex);
            return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index);
        }
        function initial(array) {
            return (null == array ? 0 : array.length) ? baseSlice(array, 0, -1) : [];
        }
        function join(array, separator) {
            return null == array ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
            var length = null == array ? 0 : array.length;
            return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = length;
            return fromIndex !== undefined && (index = toInteger(fromIndex), index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), 
            value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0);
        }
        function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
        }
        function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
        }
        function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
        }
        function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
        }
        function remove(array, predicate) {
            var result = [];
            if (!array || !array.length) return result;
            var index = -1, indexes = [], length = array.length;
            for (predicate = getIteratee(predicate, 3); ++index < length; ) {
                var value = array[index];
                predicate(value, index, array) && (result.push(value), indexes.push(index));
            }
            return basePullAt(array, indexes), result;
        }
        function reverse(array) {
            return null == array ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
            var length = null == array ? 0 : array.length;
            return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) ? (start = 0, 
            end = length) : (start = null == start ? 0 : toInteger(start), end = end === undefined ? length : toInteger(end)), 
            baseSlice(array, start, end)) : [];
        }
        function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }
        function sortedIndexOf(array, value) {
            var length = null == array ? 0 : array.length;
            if (length) {
                var index = baseSortedIndex(array, value);
                if (index < length && eq(array[index], value)) return index;
            }
            return -1;
        }
        function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, !0);
        }
        function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), !0);
        }
        function sortedLastIndexOf(array, value) {
            if (null == array ? 0 : array.length) {
                var index = baseSortedIndex(array, value, !0) - 1;
                if (eq(array[index], value)) return index;
            }
            return -1;
        }
        function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
        }
        function tail(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
            return array && array.length ? (n = guard || n === undefined ? 1 : toInteger(n), 
            baseSlice(array, 0, n < 0 ? 0 : n)) : [];
        }
        function takeRight(array, n, guard) {
            var length = null == array ? 0 : array.length;
            return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n, 
            baseSlice(array, n < 0 ? 0 : n, length)) : [];
        }
        function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : [];
        }
        function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }
        function uniqWith(array, comparator) {
            return comparator = "function" == typeof comparator ? comparator : undefined, array && array.length ? baseUniq(array, undefined, comparator) : [];
        }
        function unzip(array) {
            if (!array || !array.length) return [];
            var length = 0;
            return array = arrayFilter(array, function(group) {
                if (isArrayLikeObject(group)) return length = nativeMax(group.length, length), !0;
            }), baseTimes(length, function(index) {
                return arrayMap(array, baseProperty(index));
            });
        }
        function unzipWith(array, iteratee) {
            if (!array || !array.length) return [];
            var result = unzip(array);
            return null == iteratee ? result : arrayMap(result, function(group) {
                return apply(iteratee, undefined, group);
            });
        }
        function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
        }
        function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
        }
        function chain(value) {
            var result = lodash(value);
            return result.__chain__ = !0, result;
        }
        function tap(value, interceptor) {
            return interceptor(value), value;
        }
        function thru(value, interceptor) {
            return interceptor(value);
        }
        function wrapperChain() {
            return chain(this);
        }
        function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
            this.__values__ === undefined && (this.__values__ = toArray(this.value()));
            var done = this.__index__ >= this.__values__.length;
            return {
                done: done,
                value: done ? undefined : this.__values__[this.__index__++]
            };
        }
        function wrapperToIterator() {
            return this;
        }
        function wrapperPlant(value) {
            for (var result, parent = this; parent instanceof baseLodash; ) {
                var clone = wrapperClone(parent);
                clone.__index__ = 0, clone.__values__ = undefined, result ? previous.__wrapped__ = clone : result = clone;
                var previous = clone;
                parent = parent.__wrapped__;
            }
            return previous.__wrapped__ = value, result;
        }
        function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                var wrapped = value;
                return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), 
                wrapped.__actions__.push({
                    func: thru,
                    args: [ reverse ],
                    thisArg: undefined
                }), new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
        }
        function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), 
            func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
            return (isArray(collection) ? arrayFilter : baseFilter)(collection, getIteratee(predicate, 3));
        }
        function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1);
        }
        function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY);
        }
        function flatMapDepth(collection, iteratee, depth) {
            return depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(map(collection, iteratee), depth);
        }
        function forEach(collection, iteratee) {
            return (isArray(collection) ? arrayEach : baseEach)(collection, getIteratee(iteratee, 3));
        }
        function forEachRight(collection, iteratee) {
            return (isArray(collection) ? arrayEachRight : baseEachRight)(collection, getIteratee(iteratee, 3));
        }
        function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        function map(collection, iteratee) {
            return (isArray(collection) ? arrayMap : baseMap)(collection, getIteratee(iteratee, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
            return null == collection ? [] : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [ iteratees ]), 
            orders = guard ? undefined : orders, isArray(orders) || (orders = null == orders ? [] : [ orders ]), 
            baseOrderBy(collection, iteratees, orders));
        }
        function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
            return (isArray(collection) ? arrayFilter : baseFilter)(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
            return (isArray(collection) ? arraySample : baseSample)(collection);
        }
        function sampleSize(collection, n, guard) {
            return n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : toInteger(n), 
            (isArray(collection) ? arraySampleSize : baseSampleSize)(collection, n);
        }
        function shuffle(collection) {
            return (isArray(collection) ? arrayShuffle : baseShuffle)(collection);
        }
        function size(collection) {
            if (null == collection) return 0;
            if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
            var tag = getTag(collection);
            return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), 
            func(collection, getIteratee(predicate, 3));
        }
        function after(n, func) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return n = toInteger(n), function() {
                if (--n < 1) return func.apply(this, arguments);
            };
        }
        function ary(func, n, guard) {
            return n = guard ? undefined : n, n = func && null == n ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
            var result;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return n = toInteger(n), function() {
                return --n > 0 && (result = func.apply(this, arguments)), n <= 1 && (func = undefined), 
                result;
            };
        }
        function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            return result.placeholder = curry.placeholder, result;
        }
        function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            return result.placeholder = curryRight.placeholder, result;
        }
        function debounce(func, wait, options) {
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                return lastArgs = lastThis = undefined, lastInvokeTime = time, result = func.apply(thisArg, args);
            }
            function leadingEdge(time) {
                return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = now();
                return shouldInvoke(time) ? trailingEdge(time) : void (timerId = setTimeout(timerExpired, remainingWait(time)));
            }
            function trailingEdge(time) {
                return timerId = undefined, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined, 
                result);
            }
            function cancel() {
                timerId !== undefined && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined;
            }
            function flush() {
                return timerId === undefined ? result : trailingEdge(now());
            }
            function debounced() {
                var time = now(), isInvoking = shouldInvoke(time);
                if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                    if (timerId === undefined) return leadingEdge(lastCallTime);
                    if (maxing) return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
                }
                return timerId === undefined && (timerId = setTimeout(timerExpired, wait)), result;
            }
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, 
            maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, 
            trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, 
            debounced.flush = flush, debounced;
        }
        function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
            if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT);
            var memoized = function() {
                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                if (cache.has(key)) return cache.get(key);
                var result = func.apply(this, args);
                return memoized.cache = cache.set(key, result) || cache, result;
            };
            return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
        }
        function negate(predicate) {
            if ("function" != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT);
            return function() {
                var args = arguments;
                switch (args.length) {
                  case 0:
                    return !predicate.call(this);

                  case 1:
                    return !predicate.call(this, args[0]);

                  case 2:
                    return !predicate.call(this, args[0], args[1]);

                  case 3:
                    return !predicate.call(this, args[0], args[1], args[2]);
                }
                return !predicate.apply(this, args);
            };
        }
        function once(func) {
            return before(2, func);
        }
        function rest(func, start) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return start = start === undefined ? start : toInteger(start), baseRest(func, start);
        }
        function spread(func, start) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return start = null == start ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
                var array = args[start], otherArgs = castSlice(args, 0, start);
                return array && arrayPush(otherArgs, array), apply(func, this, otherArgs);
            });
        }
        function throttle(func, wait, options) {
            var leading = !0, trailing = !0;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, 
            trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
                leading: leading,
                maxWait: wait,
                trailing: trailing
            });
        }
        function unary(func) {
            return ary(func, 1);
        }
        function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
        }
        function castArray() {
            if (!arguments.length) return [];
            var value = arguments[0];
            return isArray(value) ? value : [ value ];
        }
        function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
            return null == source || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        function isArrayLike(value) {
            return null != value && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
            return !0 === value || !1 === value || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        function isElement(value) {
            return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value);
        }
        function isEmpty(value) {
            if (null == value) return !0;
            if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) return !value.size;
            if (isPrototype(value)) return !baseKeys(value).length;
            for (var key in value) if (hasOwnProperty.call(value, key)) return !1;
            return !0;
        }
        function isEqual(value, other) {
            return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
            customizer = "function" == typeof customizer ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
        }
        function isError(value) {
            if (!isObjectLike(value)) return !1;
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value);
        }
        function isFinite(value) {
            return "number" == typeof value && nativeIsFinite(value);
        }
        function isFunction(value) {
            if (!isObject(value)) return !1;
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
            return "number" == typeof value && value == toInteger(value);
        }
        function isLength(value) {
            return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
            var type = typeof value;
            return null != value && ("object" == type || "function" == type);
        }
        function isObjectLike(value) {
            return null != value && "object" == typeof value;
        }
        function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNative(value) {
            if (isMaskable(value)) throw new Error(CORE_ERROR_TEXT);
            return baseIsNative(value);
        }
        function isNull(value) {
            return null === value;
        }
        function isNil(value) {
            return null == value;
        }
        function isNumber(value) {
            return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1;
            var proto = getPrototype(value);
            if (null === proto) return !0;
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        function isString(value) {
            return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
            return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        function isUndefined(value) {
            return value === undefined;
        }
        function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        function toArray(value) {
            if (!value) return [];
            if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
            if (symIterator && value[symIterator]) return iteratorToArray(value[symIterator]());
            var tag = getTag(value);
            return (tag == mapTag ? mapToArray : tag == setTag ? setToArray : values)(value);
        }
        function toFinite(value) {
            if (!value) return 0 === value ? value : 0;
            if ((value = toNumber(value)) === INFINITY || value === -INFINITY) {
                return (value < 0 ? -1 : 1) * MAX_INTEGER;
            }
            return value === value ? value : 0;
        }
        function toInteger(value) {
            var result = toFinite(value), remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
        }
        function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
            if ("number" == typeof value) return value;
            if (isSymbol(value)) return NAN;
            if (isObject(value)) {
                var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                value = isObject(other) ? other + "" : other;
            }
            if ("string" != typeof value) return 0 === value ? value : +value;
            value = value.replace(reTrim, "");
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
            return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : 0 === value ? value : 0;
        }
        function toString(value) {
            return null == value ? "" : baseToString(value);
        }
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return null == properties ? result : baseAssign(result, properties);
        }
        function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee) {
            return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }
        function forInRight(object, iteratee) {
            return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }
        function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3));
        }
        function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }
        function functions(object) {
            return null == object ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
            return null == object ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
            var result = null == object ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
            return null != object && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
            return null != object && hasPath(object, path, baseHasIn);
        }
        function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee) {
            var result = {};
            return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function(value, key, object) {
                baseAssignValue(result, iteratee(value, key, object), value);
            }), result;
        }
        function mapValues(object, iteratee) {
            var result = {};
            return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function(value, key, object) {
                baseAssignValue(result, key, iteratee(value, key, object));
            }), result;
        }
        function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
        }
        function pickBy(object, predicate) {
            if (null == object) return {};
            var props = arrayMap(getAllKeysIn(object), function(prop) {
                return [ prop ];
            });
            return predicate = getIteratee(predicate), basePickBy(object, props, function(value, path) {
                return predicate(value, path[0]);
            });
        }
        function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            for (length || (length = 1, object = undefined); ++index < length; ) {
                var value = null == object ? undefined : object[toKey(path[index])];
                value === undefined && (index = length, value = defaultValue), object = isFunction(value) ? value.call(object) : value;
            }
            return object;
        }
        function set(object, path, value) {
            return null == object ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseSet(object, path, value, customizer);
        }
        function transform(object, iteratee, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            if (iteratee = getIteratee(iteratee, 4), null == accumulator) {
                var Ctor = object && object.constructor;
                accumulator = isArrLike ? isArr ? new Ctor() : [] : isObject(object) && isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
            return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                return iteratee(accumulator, value, index, object);
            }), accumulator;
        }
        function unset(object, path) {
            return null == object || baseUnset(object, path);
        }
        function update(object, path, updater) {
            return null == object ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
            return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
            return null == object ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
            return null == object ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
            return upper === undefined && (upper = lower, lower = undefined), upper !== undefined && (upper = toNumber(upper), 
            upper = upper === upper ? upper : 0), lower !== undefined && (lower = toNumber(lower), 
            lower = lower === lower ? lower : 0), baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
            return start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end), 
            number = toNumber(number), baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
            if (floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined), 
            floating === undefined && ("boolean" == typeof upper ? (floating = upper, upper = undefined) : "boolean" == typeof lower && (floating = lower, 
            lower = undefined)), lower === undefined && upper === undefined ? (lower = 0, upper = 1) : (lower = toFinite(lower), 
            upper === undefined ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
                var temp = lower;
                lower = upper, upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
                var rand = nativeRandom();
                return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
        }
        function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
            return (string = toString(string)) && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
            string = toString(string), target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            return (position -= target.length) >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
            return string = toString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
            return string = toString(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        function pad(string, length, chars) {
            string = toString(string), length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) return string;
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
            string = toString(string), length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
            string = toString(string), length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt(string, radix, guard) {
            return guard || null == radix ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
            return n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n), 
            baseRepeat(toString(string), n);
        }
        function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        function split(string, separator, limit) {
            return limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined), 
            (limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0) ? (string = toString(string), 
            string && ("string" == typeof separator || null != separator && !isRegExp(separator)) && !(separator = baseToString(separator)) && hasUnicode(string) ? castSlice(stringToArray(string), 0, limit) : string.split(separator, limit)) : [];
        }
        function startsWith(string, target, position) {
            return string = toString(string), position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length), 
            target = baseToString(target), string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
            var settings = lodash.templateSettings;
            guard && isIterateeCall(string, options, guard) && (options = undefined), string = toString(string), 
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var isEscaping, isEvaluating, imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"), sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                return interpolateValue || (interpolateValue = esTemplateValue), source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), 
                escapeValue && (isEscaping = !0, source += "' +\n__e(" + escapeValue + ") +\n'"), 
                evaluateValue && (isEvaluating = !0, source += "';\n" + evaluateValue + ";\n__p += '"), 
                interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), 
                index = offset + match.length, match;
            }), source += "';\n";
            var variable = options.variable;
            variable || (source = "with (obj) {\n" + source + "\n}\n"), source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), 
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result = attempt(function() {
                return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
            });
            if (result.source = source, isError(result)) throw result;
            return result;
        }
        function toLower(value) {
            return toString(value).toLowerCase();
        }
        function toUpper(value) {
            return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
            if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrim, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars);
            return castSlice(strSymbols, charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1).join("");
        }
        function trimEnd(string, chars, guard) {
            if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrimEnd, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string);
            return castSlice(strSymbols, 0, charsEndIndex(strSymbols, stringToArray(chars)) + 1).join("");
        }
        function trimStart(string, chars, guard) {
            if ((string = toString(string)) && (guard || chars === undefined)) return string.replace(reTrimStart, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string);
            return castSlice(strSymbols, charsStartIndex(strSymbols, stringToArray(chars))).join("");
        }
        function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
                var separator = "separator" in options ? options.separator : separator;
                length = "length" in options ? toInteger(options.length) : length, omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
                var strSymbols = stringToArray(string);
                strLength = strSymbols.length;
            }
            if (length >= strLength) return string;
            var end = length - stringSize(omission);
            if (end < 1) return omission;
            var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined) return result + omission;
            if (strSymbols && (end += result.length - end), isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match, substring = result;
                    for (separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g")), 
                    separator.lastIndex = 0; match = separator.exec(substring); ) var newEnd = match.index;
                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                }
            } else if (string.indexOf(baseToString(separator), end) != end) {
                var index = result.lastIndexOf(separator);
                index > -1 && (result = result.slice(0, index));
            }
            return result + omission;
        }
        function unescape(string) {
            return string = toString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
            return string = toString(string), pattern = guard ? undefined : pattern, pattern === undefined ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
        }
        function cond(pairs) {
            var length = null == pairs ? 0 : pairs.length, toIteratee = getIteratee();
            return pairs = length ? arrayMap(pairs, function(pair) {
                if ("function" != typeof pair[1]) throw new TypeError(FUNC_ERROR_TEXT);
                return [ toIteratee(pair[0]), pair[1] ];
            }) : [], baseRest(function(args) {
                for (var index = -1; ++index < length; ) {
                    var pair = pairs[index];
                    if (apply(pair[0], this, args)) return apply(pair[1], this, args);
                }
            });
        }
        function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        function defaultTo(value, defaultValue) {
            return null == value || value !== value ? defaultValue : value;
        }
        function identity(value) {
            return value;
        }
        function iteratee(func) {
            return baseIteratee("function" == typeof func ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            null != options || isObject(source) && (methodNames.length || !props.length) || (options = source, 
            source = object, object = this, methodNames = baseFunctions(source, keys(source)));
            var chain = !(isObject(options) && "chain" in options && !options.chain), isFunc = isFunction(object);
            return arrayEach(methodNames, function(methodName) {
                var func = source[methodName];
                object[methodName] = func, isFunc && (object.prototype[methodName] = function() {
                    var chainAll = this.__chain__;
                    if (chain || chainAll) {
                        var result = object(this.__wrapped__);
                        return (result.__actions__ = copyArray(this.__actions__)).push({
                            func: func,
                            args: arguments,
                            thisArg: object
                        }), result.__chain__ = chainAll, result;
                    }
                    return func.apply(object, arrayPush([ this.value() ], arguments));
                });
            }), object;
        }
        function noConflict() {
            return root._ === this && (root._ = oldDash), this;
        }
        function noop() {}
        function nthArg(n) {
            return n = toInteger(n), baseRest(function(args) {
                return baseNth(args, n);
            });
        }
        function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
            return function(path) {
                return null == object ? undefined : baseGet(object, path);
            };
        }
        function stubArray() {
            return [];
        }
        function stubFalse() {
            return !1;
        }
        function stubObject() {
            return {};
        }
        function stubString() {
            return "";
        }
        function stubTrue() {
            return !0;
        }
        function times(n, iteratee) {
            if ((n = toInteger(n)) < 1 || n > MAX_SAFE_INTEGER) return [];
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee), n -= MAX_ARRAY_LENGTH;
            for (var result = baseTimes(length, iteratee); ++index < n; ) iteratee(index);
            return result;
        }
        function toPath(value) {
            return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [ value ] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
        }
        function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
        }
        function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
        }
        function mean(array) {
            return baseMean(array, identity);
        }
        function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2));
        }
        function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
        }
        function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
        }
        function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
        }
        context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = context["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, idCounter = 0, maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
        }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object), oldDash = root._, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined, defineProperty = function() {
            try {
                var func = getNative(Object, "defineProperty");
                return func({}, "", {}), func;
            } catch (e) {}
        }(), ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout, nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse, DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create"), metaMap = WeakMap && new WeakMap(), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined, baseCreate = function() {
            function object() {}
            return function(proto) {
                if (!isObject(proto)) return {};
                if (objectCreate) return objectCreate(proto);
                object.prototype = proto;
                var result = new object();
                return object.prototype = undefined, result;
            };
        }();
        lodash.templateSettings = {
            escape: reEscape,
            evaluate: reEvaluate,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        }, lodash.prototype = baseLodash.prototype, lodash.prototype.constructor = lodash, 
        LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper, 
        LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper, 
        Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, 
        Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, ListCache.prototype.clear = listCacheClear, 
        ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, 
        ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet, 
        MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, 
        MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, 
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas, 
        Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, 
        Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
        var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0), baseFor = createBaseFor(), baseForRight = createBaseFor(!0), baseSetData = metaMap ? function(func, data) {
            return metaMap.set(func, data), func;
        } : identity, baseSetToString = defineProperty ? function(func, string) {
            return defineProperty(func, "toString", {
                configurable: !0,
                enumerable: !1,
                value: constant(string),
                writable: !0
            });
        } : identity, castRest = baseRest, clearTimeout = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
        }, createSet = Set && 1 / setToArray(new Set([ , -0 ]))[1] == INFINITY ? function(values) {
            return new Set(values);
        } : noop, getData = metaMap ? function(func) {
            return metaMap.get(func);
        } : noop, getSymbols = nativeGetSymbols ? function(object) {
            return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
                return propertyIsEnumerable.call(object, symbol);
            }));
        } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object) {
            for (var result = []; object; ) arrayPush(result, getSymbols(object)), object = getPrototype(object);
            return result;
        } : stubArray, getTag = baseGetTag;
        (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && "[object Promise]" != getTag(Promise.resolve()) || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) && (getTag = function(value) {
            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;

              case mapCtorString:
                return mapTag;

              case promiseCtorString:
                return "[object Promise]";

              case setCtorString:
                return setTag;

              case weakMapCtorString:
                return weakMapTag;
            }
            return result;
        });
        var isMaskable = coreJsData ? isFunction : stubFalse, setData = shortOut(baseSetData), setTimeout = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
        }, setToString = shortOut(baseSetToString), stringToPath = function(func) {
            var result = memoize(func, function(key) {
                return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key;
            }), cache = result.cache;
            return result;
        }(function(string) {
            var result = [];
            return reLeadingDot.test(string) && result.push(""), string.replace(rePropName, function(match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
            }), result;
        }), difference = baseRest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : [];
        }), differenceBy = baseRest(function(array, values) {
            var iteratee = last(values);
            return isArrayLikeObject(iteratee) && (iteratee = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2)) : [];
        }), differenceWith = baseRest(function(array, values) {
            var comparator = last(values);
            return isArrayLikeObject(comparator) && (comparator = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), undefined, comparator) : [];
        }), intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        }), intersectionBy = baseRest(function(arrays) {
            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            return iteratee === last(mapped) ? iteratee = undefined : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
        }), intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            return comparator = "function" == typeof comparator ? comparator : undefined, comparator && mapped.pop(), 
            mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
        }), pull = baseRest(pullAll), pullAt = flatRest(function(array, indexes) {
            var length = null == array ? 0 : array.length, result = baseAt(array, indexes);
            return basePullAt(array, arrayMap(indexes, function(index) {
                return isIndex(index, length) ? +index : index;
            }).sort(compareAscending)), result;
        }), union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
        }), unionBy = baseRest(function(arrays) {
            var iteratee = last(arrays);
            return isArrayLikeObject(iteratee) && (iteratee = undefined), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2));
        }), unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            return comparator = "function" == typeof comparator ? comparator : undefined, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined, comparator);
        }), without = baseRest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
        }), xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
        }), xorBy = baseRest(function(arrays) {
            var iteratee = last(arrays);
            return isArrayLikeObject(iteratee) && (iteratee = undefined), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        }), xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            return comparator = "function" == typeof comparator ? comparator : undefined, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        }), zip = baseRest(unzip), zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
            return iteratee = "function" == typeof iteratee ? (arrays.pop(), iteratee) : undefined, 
            unzipWith(arrays, iteratee);
        }), wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                return baseAt(object, paths);
            };
            return !(length > 1 || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start) ? (value = value.slice(start, +start + (length ? 1 : 0)), 
            value.__actions__.push({
                func: thru,
                args: [ interceptor ],
                thisArg: undefined
            }), new LodashWrapper(value, this.__chain__).thru(function(array) {
                return length && !array.length && array.push(undefined), array;
            })) : this.thru(interceptor);
        }), countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1);
        }), find = createFind(findIndex), findLast = createFind(findLastIndex), groupBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [ value ]);
        }), invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = "function" == typeof path, result = isArrayLike(collection) ? Array(collection.length) : [];
            return baseEach(collection, function(value) {
                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            }), result;
        }), keyBy = createAggregator(function(result, value, key) {
            baseAssignValue(result, key, value);
        }), partition = createAggregator(function(result, value, key) {
            result[key ? 0 : 1].push(value);
        }, function() {
            return [ [], [] ];
        }), sortBy = baseRest(function(collection, iteratees) {
            if (null == collection) return [];
            var length = iteratees.length;
            return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [ iteratees[0] ]), 
            baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        }), now = ctxNow || function() {
            return root.Date.now();
        }, bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bind));
                bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
        }), bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bindKey));
                bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
        }), defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
        }), delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
        });
        memoize.Cache = MapCache;
        var overArgs = castRest(function(func, transforms) {
            transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
                for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; ) args[index] = transforms[index].call(this, args[index]);
                return apply(func, this, args);
            });
        }), partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
        }), partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        }), rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
        }), gt = createRelationalOperation(baseGt), gte = createRelationalOperation(function(value, other) {
            return value >= other;
        }), isArguments = baseIsArguments(function() {
            return arguments;
        }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        }, isArray = Array.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer, isBuffer = nativeIsBuffer || stubFalse, isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp, isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, lt = createRelationalOperation(baseLt), lte = createRelationalOperation(function(value, other) {
            return value <= other;
        }), assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) return void copyObject(source, keys(source), object);
            for (var key in source) hasOwnProperty.call(source, key) && assignValue(object, key, source[key]);
        }), assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
        }), assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
        }), assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
        }), at = flatRest(baseAt), defaults = baseRest(function(args) {
            return args.push(undefined, customDefaultsAssignIn), apply(assignInWith, undefined, args);
        }), defaultsDeep = baseRest(function(args) {
            return args.push(undefined, customDefaultsMerge), apply(mergeWith, undefined, args);
        }), invert = createInverter(function(result, value, key) {
            result[value] = key;
        }, constant(identity)), invertBy = createInverter(function(result, value, key) {
            hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [ key ];
        }, getIteratee), invoke = baseRest(baseInvoke), merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
        }), mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
        }), omit = flatRest(function(object, paths) {
            var result = {};
            if (null == object) return result;
            var isDeep = !1;
            paths = arrayMap(paths, function(path) {
                return path = castPath(path, object), isDeep || (isDeep = path.length > 1), path;
            }), copyObject(object, getAllKeysIn(object), result), isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
            for (var length = paths.length; length--; ) baseUnset(result, paths[length]);
            return result;
        }), pick = flatRest(function(object, paths) {
            return null == object ? {} : basePick(object, paths);
        }), toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn), camelCase = createCompounder(function(result, word, index) {
            return word = word.toLowerCase(), result + (index ? capitalize(word) : word);
        }), kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? "-" : "") + word.toLowerCase();
        }), lowerCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toLowerCase();
        }), lowerFirst = createCaseFirst("toLowerCase"), snakeCase = createCompounder(function(result, word, index) {
            return result + (index ? "_" : "") + word.toLowerCase();
        }), startCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + upperFirst(word);
        }), upperCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toUpperCase();
        }), upperFirst = createCaseFirst("toUpperCase"), attempt = baseRest(function(func, args) {
            try {
                return apply(func, undefined, args);
            } catch (e) {
                return isError(e) ? e : new Error(e);
            }
        }), bindAll = flatRest(function(object, methodNames) {
            return arrayEach(methodNames, function(key) {
                key = toKey(key), baseAssignValue(object, key, bind(object[key], object));
            }), object;
        }), flow = createFlow(), flowRight = createFlow(!0), method = baseRest(function(path, args) {
            return function(object) {
                return baseInvoke(object, path, args);
            };
        }), methodOf = baseRest(function(object, args) {
            return function(path) {
                return baseInvoke(object, path, args);
            };
        }), over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome), range = createRange(), rangeRight = createRange(!0), add = createMathOperation(function(augend, addend) {
            return augend + addend;
        }, 0), ceil = createRound("ceil"), divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
        }, 1), floor = createRound("floor"), multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
        }, 1), round = createRound("round"), subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
        }, 0);
        return lodash.after = after, lodash.ary = ary, lodash.assign = assign, lodash.assignIn = assignIn, 
        lodash.assignInWith = assignInWith, lodash.assignWith = assignWith, lodash.at = at, 
        lodash.before = before, lodash.bind = bind, lodash.bindAll = bindAll, lodash.bindKey = bindKey, 
        lodash.castArray = castArray, lodash.chain = chain, lodash.chunk = chunk, lodash.compact = compact, 
        lodash.concat = concat, lodash.cond = cond, lodash.conforms = conforms, lodash.constant = constant, 
        lodash.countBy = countBy, lodash.create = create, lodash.curry = curry, lodash.curryRight = curryRight, 
        lodash.debounce = debounce, lodash.defaults = defaults, lodash.defaultsDeep = defaultsDeep, 
        lodash.defer = defer, lodash.delay = delay, lodash.difference = difference, lodash.differenceBy = differenceBy, 
        lodash.differenceWith = differenceWith, lodash.drop = drop, lodash.dropRight = dropRight, 
        lodash.dropRightWhile = dropRightWhile, lodash.dropWhile = dropWhile, lodash.fill = fill, 
        lodash.filter = filter, lodash.flatMap = flatMap, lodash.flatMapDeep = flatMapDeep, 
        lodash.flatMapDepth = flatMapDepth, lodash.flatten = flatten, lodash.flattenDeep = flattenDeep, 
        lodash.flattenDepth = flattenDepth, lodash.flip = flip, lodash.flow = flow, lodash.flowRight = flowRight, 
        lodash.fromPairs = fromPairs, lodash.functions = functions, lodash.functionsIn = functionsIn, 
        lodash.groupBy = groupBy, lodash.initial = initial, lodash.intersection = intersection, 
        lodash.intersectionBy = intersectionBy, lodash.intersectionWith = intersectionWith, 
        lodash.invert = invert, lodash.invertBy = invertBy, lodash.invokeMap = invokeMap, 
        lodash.iteratee = iteratee, lodash.keyBy = keyBy, lodash.keys = keys, lodash.keysIn = keysIn, 
        lodash.map = map, lodash.mapKeys = mapKeys, lodash.mapValues = mapValues, lodash.matches = matches, 
        lodash.matchesProperty = matchesProperty, lodash.memoize = memoize, lodash.merge = merge, 
        lodash.mergeWith = mergeWith, lodash.method = method, lodash.methodOf = methodOf, 
        lodash.mixin = mixin, lodash.negate = negate, lodash.nthArg = nthArg, lodash.omit = omit, 
        lodash.omitBy = omitBy, lodash.once = once, lodash.orderBy = orderBy, lodash.over = over, 
        lodash.overArgs = overArgs, lodash.overEvery = overEvery, lodash.overSome = overSome, 
        lodash.partial = partial, lodash.partialRight = partialRight, lodash.partition = partition, 
        lodash.pick = pick, lodash.pickBy = pickBy, lodash.property = property, lodash.propertyOf = propertyOf, 
        lodash.pull = pull, lodash.pullAll = pullAll, lodash.pullAllBy = pullAllBy, lodash.pullAllWith = pullAllWith, 
        lodash.pullAt = pullAt, lodash.range = range, lodash.rangeRight = rangeRight, lodash.rearg = rearg, 
        lodash.reject = reject, lodash.remove = remove, lodash.rest = rest, lodash.reverse = reverse, 
        lodash.sampleSize = sampleSize, lodash.set = set, lodash.setWith = setWith, lodash.shuffle = shuffle, 
        lodash.slice = slice, lodash.sortBy = sortBy, lodash.sortedUniq = sortedUniq, lodash.sortedUniqBy = sortedUniqBy, 
        lodash.split = split, lodash.spread = spread, lodash.tail = tail, lodash.take = take, 
        lodash.takeRight = takeRight, lodash.takeRightWhile = takeRightWhile, lodash.takeWhile = takeWhile, 
        lodash.tap = tap, lodash.throttle = throttle, lodash.thru = thru, lodash.toArray = toArray, 
        lodash.toPairs = toPairs, lodash.toPairsIn = toPairsIn, lodash.toPath = toPath, 
        lodash.toPlainObject = toPlainObject, lodash.transform = transform, lodash.unary = unary, 
        lodash.union = union, lodash.unionBy = unionBy, lodash.unionWith = unionWith, lodash.uniq = uniq, 
        lodash.uniqBy = uniqBy, lodash.uniqWith = uniqWith, lodash.unset = unset, lodash.unzip = unzip, 
        lodash.unzipWith = unzipWith, lodash.update = update, lodash.updateWith = updateWith, 
        lodash.values = values, lodash.valuesIn = valuesIn, lodash.without = without, lodash.words = words, 
        lodash.wrap = wrap, lodash.xor = xor, lodash.xorBy = xorBy, lodash.xorWith = xorWith, 
        lodash.zip = zip, lodash.zipObject = zipObject, lodash.zipObjectDeep = zipObjectDeep, 
        lodash.zipWith = zipWith, lodash.entries = toPairs, lodash.entriesIn = toPairsIn, 
        lodash.extend = assignIn, lodash.extendWith = assignInWith, mixin(lodash, lodash), 
        lodash.add = add, lodash.attempt = attempt, lodash.camelCase = camelCase, lodash.capitalize = capitalize, 
        lodash.ceil = ceil, lodash.clamp = clamp, lodash.clone = clone, lodash.cloneDeep = cloneDeep, 
        lodash.cloneDeepWith = cloneDeepWith, lodash.cloneWith = cloneWith, lodash.conformsTo = conformsTo, 
        lodash.deburr = deburr, lodash.defaultTo = defaultTo, lodash.divide = divide, lodash.endsWith = endsWith, 
        lodash.eq = eq, lodash.escape = escape, lodash.escapeRegExp = escapeRegExp, lodash.every = every, 
        lodash.find = find, lodash.findIndex = findIndex, lodash.findKey = findKey, lodash.findLast = findLast, 
        lodash.findLastIndex = findLastIndex, lodash.findLastKey = findLastKey, lodash.floor = floor, 
        lodash.forEach = forEach, lodash.forEachRight = forEachRight, lodash.forIn = forIn, 
        lodash.forInRight = forInRight, lodash.forOwn = forOwn, lodash.forOwnRight = forOwnRight, 
        lodash.get = get, lodash.gt = gt, lodash.gte = gte, lodash.has = has, lodash.hasIn = hasIn, 
        lodash.head = head, lodash.identity = identity, lodash.includes = includes, lodash.indexOf = indexOf, 
        lodash.inRange = inRange, lodash.invoke = invoke, lodash.isArguments = isArguments, 
        lodash.isArray = isArray, lodash.isArrayBuffer = isArrayBuffer, lodash.isArrayLike = isArrayLike, 
        lodash.isArrayLikeObject = isArrayLikeObject, lodash.isBoolean = isBoolean, lodash.isBuffer = isBuffer, 
        lodash.isDate = isDate, lodash.isElement = isElement, lodash.isEmpty = isEmpty, 
        lodash.isEqual = isEqual, lodash.isEqualWith = isEqualWith, lodash.isError = isError, 
        lodash.isFinite = isFinite, lodash.isFunction = isFunction, lodash.isInteger = isInteger, 
        lodash.isLength = isLength, lodash.isMap = isMap, lodash.isMatch = isMatch, lodash.isMatchWith = isMatchWith, 
        lodash.isNaN = isNaN, lodash.isNative = isNative, lodash.isNil = isNil, lodash.isNull = isNull, 
        lodash.isNumber = isNumber, lodash.isObject = isObject, lodash.isObjectLike = isObjectLike, 
        lodash.isPlainObject = isPlainObject, lodash.isRegExp = isRegExp, lodash.isSafeInteger = isSafeInteger, 
        lodash.isSet = isSet, lodash.isString = isString, lodash.isSymbol = isSymbol, lodash.isTypedArray = isTypedArray, 
        lodash.isUndefined = isUndefined, lodash.isWeakMap = isWeakMap, lodash.isWeakSet = isWeakSet, 
        lodash.join = join, lodash.kebabCase = kebabCase, lodash.last = last, lodash.lastIndexOf = lastIndexOf, 
        lodash.lowerCase = lowerCase, lodash.lowerFirst = lowerFirst, lodash.lt = lt, lodash.lte = lte, 
        lodash.max = max, lodash.maxBy = maxBy, lodash.mean = mean, lodash.meanBy = meanBy, 
        lodash.min = min, lodash.minBy = minBy, lodash.stubArray = stubArray, lodash.stubFalse = stubFalse, 
        lodash.stubObject = stubObject, lodash.stubString = stubString, lodash.stubTrue = stubTrue, 
        lodash.multiply = multiply, lodash.nth = nth, lodash.noConflict = noConflict, lodash.noop = noop, 
        lodash.now = now, lodash.pad = pad, lodash.padEnd = padEnd, lodash.padStart = padStart, 
        lodash.parseInt = parseInt, lodash.random = random, lodash.reduce = reduce, lodash.reduceRight = reduceRight, 
        lodash.repeat = repeat, lodash.replace = replace, lodash.result = result, lodash.round = round, 
        lodash.runInContext = runInContext, lodash.sample = sample, lodash.size = size, 
        lodash.snakeCase = snakeCase, lodash.some = some, lodash.sortedIndex = sortedIndex, 
        lodash.sortedIndexBy = sortedIndexBy, lodash.sortedIndexOf = sortedIndexOf, lodash.sortedLastIndex = sortedLastIndex, 
        lodash.sortedLastIndexBy = sortedLastIndexBy, lodash.sortedLastIndexOf = sortedLastIndexOf, 
        lodash.startCase = startCase, lodash.startsWith = startsWith, lodash.subtract = subtract, 
        lodash.sum = sum, lodash.sumBy = sumBy, lodash.template = template, lodash.times = times, 
        lodash.toFinite = toFinite, lodash.toInteger = toInteger, lodash.toLength = toLength, 
        lodash.toLower = toLower, lodash.toNumber = toNumber, lodash.toSafeInteger = toSafeInteger, 
        lodash.toString = toString, lodash.toUpper = toUpper, lodash.trim = trim, lodash.trimEnd = trimEnd, 
        lodash.trimStart = trimStart, lodash.truncate = truncate, lodash.unescape = unescape, 
        lodash.uniqueId = uniqueId, lodash.upperCase = upperCase, lodash.upperFirst = upperFirst, 
        lodash.each = forEach, lodash.eachRight = forEachRight, lodash.first = head, mixin(lodash, function() {
            var source = {};
            return baseForOwn(lodash, function(func, methodName) {
                hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func);
            }), source;
        }(), {
            chain: !1
        }), lodash.VERSION = "4.17.4", arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
            lodash[methodName].placeholder = lodash;
        }), arrayEach([ "drop", "take" ], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                return result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({
                    size: nativeMin(n, MAX_ARRAY_LENGTH),
                    type: methodName + (result.__dir__ < 0 ? "Right" : "")
                }), result;
            }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
                return this.reverse()[methodName](n).reverse();
            };
        }), arrayEach([ "filter", "map", "takeWhile" ], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || 3 == type;
            LazyWrapper.prototype[methodName] = function(iteratee) {
                var result = this.clone();
                return result.__iteratees__.push({
                    iteratee: getIteratee(iteratee, 3),
                    type: type
                }), result.__filtered__ = result.__filtered__ || isFilter, result;
            };
        }), arrayEach([ "head", "last" ], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
                return this[takeName](1).value()[0];
            };
        }), arrayEach([ "initial", "tail" ], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
        }), LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
        }, LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
        }, LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
        }, LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            return "function" == typeof path ? new LazyWrapper(this) : this.map(function(value) {
                return baseInvoke(value, path, args);
            });
        }), LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
        }, LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result = this;
            return result.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result) : (start < 0 ? result = result.takeRight(-start) : start && (result = result.drop(start)), 
            end !== undefined && (end = toInteger(end), result = end < 0 ? result.dropRight(-end) : result.take(end - start)), 
            result);
        }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
        }, LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
        }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            lodashFunc && (lodash.prototype[methodName] = function() {
                var value = this.__wrapped__, args = isTaker ? [ 1 ] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value), interceptor = function(value) {
                    var result = lodashFunc.apply(lodash, arrayPush([ value ], args));
                    return isTaker && chainAll ? result[0] : result;
                };
                useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = !1);
                var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result = func.apply(value, args);
                    return result.__actions__.push({
                        func: thru,
                        args: [ interceptor ],
                        thisArg: undefined
                    }), new LodashWrapper(result, chainAll);
                }
                return isUnwrapped && onlyLazy ? func.apply(this, args) : (result = this.thru(interceptor), 
                isUnwrapped ? isTaker ? result.value()[0] : result.value() : result);
            });
        }), arrayEach([ "pop", "push", "shift", "sort", "splice", "unshift" ], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray(value) ? value : [], args);
                }
                return this[chainName](function(value) {
                    return func.apply(isArray(value) ? value : [], args);
                });
            };
        }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
                var key = lodashFunc.name + "";
                (realNames[key] || (realNames[key] = [])).push({
                    name: methodName,
                    func: lodashFunc
                });
            }
        }), realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [ {
            name: "wrapper",
            func: undefined
        } ], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse, 
        LazyWrapper.prototype.value = lazyValue, lodash.prototype.at = wrapperAt, lodash.prototype.chain = wrapperChain, 
        lodash.prototype.commit = wrapperCommit, lodash.prototype.next = wrapperNext, lodash.prototype.plant = wrapperPlant, 
        lodash.prototype.reverse = wrapperReverse, lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue, 
        lodash.prototype.first = lodash.prototype.head, symIterator && (lodash.prototype[symIterator] = wrapperToIterator), 
        lodash;
    }();
    "function" == typeof define && "object" == typeof define.amd && define.amd ? (root._ = _, 
    define("lodash", [], function() {
        return _;
    })) : freeModule ? ((freeModule.exports = _)._ = _, freeExports._ = _) : root._ = _;
}.call(this), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? factory(exports) : "function" == typeof define && define.amd ? define("async", [ "exports" ], factory) : factory(global.async = global.async || {});
}(this, function(exports) {
    "use strict";
    function slice(arrayLike, start) {
        start |= 0;
        for (var newLen = Math.max(arrayLike.length - start, 0), newArr = Array(newLen), idx = 0; idx < newLen; idx++) newArr[idx] = arrayLike[start + idx];
        return newArr;
    }
    function isObject(value) {
        var type = typeof value;
        return null != value && ("object" == type || "function" == type);
    }
    function fallback(fn) {
        setTimeout(fn, 0);
    }
    function wrap(defer) {
        return function(fn) {
            var args = slice(arguments, 1);
            defer(function() {
                fn.apply(null, args);
            });
        };
    }
    function asyncify(func) {
        return initialParams(function(args, callback) {
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            isObject(result) && "function" == typeof result.then ? result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            }) : callback(null, result);
        });
    }
    function invokeCallback(callback, error, value) {
        try {
            callback(error, value);
        } catch (e) {
            setImmediate$1(rethrow, e);
        }
    }
    function rethrow(error) {
        throw error;
    }
    function isAsync(fn) {
        return supportsSymbol && "AsyncFunction" === fn[Symbol.toStringTag];
    }
    function wrapAsync(asyncFn) {
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function applyEach$1(eachfn) {
        return function(fns) {
            var args = slice(arguments, 1), go = initialParams(function(args, callback) {
                var that = this;
                return eachfn(fns, function(fn, cb) {
                    wrapAsync(fn).apply(that, args.concat(cb));
                }, callback);
            });
            return args.length ? go.apply(this, args) : go;
        };
    }
    function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
            value[symToStringTag$1] = void 0;
            var unmasked = !0;
        } catch (e) {}
        var result = nativeObjectToString.call(value);
        return unmasked && (isOwn ? value[symToStringTag$1] = tag : delete value[symToStringTag$1]), 
        result;
    }
    function objectToString(value) {
        return nativeObjectToString$1.call(value);
    }
    function baseGetTag(value) {
        return null == value ? void 0 === value ? undefinedTag : nullTag : (value = Object(value), 
        symToStringTag && symToStringTag in value ? getRawTag(value) : objectToString(value));
    }
    function isFunction(value) {
        if (!isObject(value)) return !1;
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
        return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
        return null != value && isLength(value.length) && !isFunction(value);
    }
    function noop() {}
    function once(fn) {
        return function() {
            if (null !== fn) {
                var callFn = fn;
                fn = null, callFn.apply(this, arguments);
            }
        };
    }
    function baseTimes(n, iteratee) {
        for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
        return result;
    }
    function isObjectLike(value) {
        return null != value && "object" == typeof value;
    }
    function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function stubFalse() {
        return !1;
    }
    function isIndex(value, length) {
        return !!(length = null == length ? MAX_SAFE_INTEGER$1 : length) && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) !inherited && !hasOwnProperty$1.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
        return result;
    }
    function isPrototype(value) {
        var Ctor = value && value.constructor;
        return value === ("function" == typeof Ctor && Ctor.prototype || objectProto$5);
    }
    function baseKeys(object) {
        if (!isPrototype(object)) return nativeKeys(object);
        var result = [];
        for (var key in Object(object)) hasOwnProperty$3.call(object, key) && "constructor" != key && result.push(key);
        return result;
    }
    function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function createArrayIterator(coll) {
        var i = -1, len = coll.length;
        return function() {
            return ++i < len ? {
                value: coll[i],
                key: i
            } : null;
        };
    }
    function createES2015Iterator(iterator) {
        var i = -1;
        return function() {
            var item = iterator.next();
            return item.done ? null : (i++, {
                value: item.value,
                key: i
            });
        };
    }
    function createObjectIterator(obj) {
        var okeys = keys(obj), i = -1, len = okeys.length;
        return function() {
            var key = okeys[++i];
            return i < len ? {
                value: obj[key],
                key: key
            } : null;
        };
    }
    function iterator(coll) {
        if (isArrayLike(coll)) return createArrayIterator(coll);
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
        return function() {
            if (null === fn) throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null, callFn.apply(this, arguments);
        };
    }
    function _eachOfLimit(limit) {
        return function(obj, iteratee, callback) {
            function iterateeCallback(err, value) {
                if (running -= 1, err) done = !0, callback(err); else {
                    if (value === breakLoop || done && running <= 0) return done = !0, callback(null);
                    replenish();
                }
            }
            function replenish() {
                for (;running < limit && !done; ) {
                    var elem = nextElem();
                    if (null === elem) return done = !0, void (running <= 0 && callback(null));
                    running += 1, iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
                }
            }
            if (callback = once(callback || noop), limit <= 0 || !obj) return callback(null);
            var nextElem = iterator(obj), done = !1, running = 0;
            replenish();
        };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
        _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
    }
    function doLimit(fn, limit) {
        return function(iterable, iteratee, callback) {
            return fn(iterable, limit, iteratee, callback);
        };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
        function iteratorCallback(err, value) {
            err ? callback(err) : ++completed !== length && value !== breakLoop || callback(null);
        }
        callback = once(callback || noop);
        var index = 0, completed = 0, length = coll.length;
        for (0 === length && callback(null); index < length; index++) iteratee(coll[index], index, onlyOnce(iteratorCallback));
    }
    function doParallel(fn) {
        return function(obj, iteratee, callback) {
            return fn(eachOf, obj, wrapAsync(iteratee), callback);
        };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
        callback = callback || noop, arr = arr || [];
        var results = [], counter = 0, _iteratee = wrapAsync(iteratee);
        eachfn(arr, function(value, _, callback) {
            var index = counter++;
            _iteratee(value, function(err, v) {
                results[index] = v, callback(err);
            });
        }, function(err) {
            callback(err, results);
        });
    }
    function doParallelLimit(fn) {
        return function(obj, limit, iteratee, callback) {
            return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
        };
    }
    function arrayEach(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length; ++index < length && !1 !== iteratee(array[index], index, array); ) ;
        return array;
    }
    function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
        for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
        return -1;
    }
    function baseIsNaN(value) {
        return value !== value;
    }
    function strictIndexOf(array, value, fromIndex) {
        for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (array[index] === value) return index;
        return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function arrayMap(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; ) result[index] = iteratee(array[index], index, array);
        return result;
    }
    function isSymbol(value) {
        return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    function baseToString(value) {
        if ("string" == typeof value) return value;
        if (isArray(value)) return arrayMap(value, baseToString) + "";
        if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
        var result = value + "";
        return "0" == result && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end, 
        end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
        for (var result = Array(length); ++index < length; ) result[index] = array[index + start];
        return result;
    }
    function castSlice(array, start, end) {
        var length = array.length;
        return end = void 0 === end ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
    }
    function charsEndIndex(strSymbols, chrSymbols) {
        for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
        return index;
    }
    function charsStartIndex(strSymbols, chrSymbols) {
        for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; ) ;
        return index;
    }
    function asciiToArray(string) {
        return string.split("");
    }
    function hasUnicode(string) {
        return reHasUnicode.test(string);
    }
    function unicodeToArray(string) {
        return string.match(reUnicode) || [];
    }
    function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function toString(value) {
        return null == value ? "" : baseToString(value);
    }
    function trim(string, chars, guard) {
        if ((string = toString(string)) && (guard || void 0 === chars)) return string.replace(reTrim, "");
        if (!string || !(chars = baseToString(chars))) return string;
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars);
        return castSlice(strSymbols, charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1).join("");
    }
    function parseParams(func) {
        return func = func.toString().replace(STRIP_COMMENTS, ""), func = func.match(FN_ARGS)[2].replace(" ", ""), 
        func = func ? func.split(FN_ARG_SPLIT) : [], func = func.map(function(arg) {
            return trim(arg.replace(FN_ARG, ""));
        });
    }
    function autoInject(tasks, callback) {
        var newTasks = {};
        baseForOwn(tasks, function(taskFn, key) {
            function newTask(results, taskCb) {
                var newArgs = arrayMap(params, function(name) {
                    return results[name];
                });
                newArgs.push(taskCb), wrapAsync(taskFn).apply(null, newArgs);
            }
            var params, fnIsAsync = isAsync(taskFn), hasNoDeps = !fnIsAsync && 1 === taskFn.length || fnIsAsync && 0 === taskFn.length;
            if (isArray(taskFn)) params = taskFn.slice(0, -1), taskFn = taskFn[taskFn.length - 1], 
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn); else if (hasNoDeps) newTasks[key] = taskFn; else {
                if (params = parseParams(taskFn), 0 === taskFn.length && !fnIsAsync && 0 === params.length) throw new Error("autoInject task functions require explicit parameters.");
                fnIsAsync || params.pop(), newTasks[key] = params.concat(newTask);
            }
        }), auto(newTasks, callback);
    }
    function DLL() {
        this.head = this.tail = null, this.length = 0;
    }
    function setInitial(dll, node) {
        dll.length = 1, dll.head = dll.tail = node;
    }
    function queue(worker, concurrency, payload) {
        function _insert(data, insertAtFront, callback) {
            if (null != callback && "function" != typeof callback) throw new Error("task callback must be a function");
            if (q.started = !0, isArray(data) || (data = [ data ]), 0 === data.length && q.idle()) return setImmediate$1(function() {
                q.drain();
            });
            for (var i = 0, l = data.length; i < l; i++) {
                var item = {
                    data: data[i],
                    callback: callback || noop
                };
                insertAtFront ? q._tasks.unshift(item) : q._tasks.push(item);
            }
            setImmediate$1(q.process);
        }
        function _next(tasks) {
            return function(err) {
                numRunning -= 1;
                for (var i = 0, l = tasks.length; i < l; i++) {
                    var task = tasks[i], index = baseIndexOf(workersList, task, 0);
                    index >= 0 && workersList.splice(index, 1), task.callback.apply(task, arguments), 
                    null != err && q.error(err, task.data);
                }
                numRunning <= q.concurrency - q.buffer && q.unsaturated(), q.idle() && q.drain(), 
                q.process();
            };
        }
        if (null == concurrency) concurrency = 1; else if (0 === concurrency) throw new Error("Concurrency must not be zero");
        var _worker = wrapAsync(worker), numRunning = 0, workersList = [], isProcessing = !1, q = {
            _tasks: new DLL(),
            concurrency: concurrency,
            payload: payload,
            saturated: noop,
            unsaturated: noop,
            buffer: concurrency / 4,
            empty: noop,
            drain: noop,
            error: noop,
            started: !1,
            paused: !1,
            push: function(data, callback) {
                _insert(data, !1, callback);
            },
            kill: function() {
                q.drain = noop, q._tasks.empty();
            },
            unshift: function(data, callback) {
                _insert(data, !0, callback);
            },
            remove: function(testFn) {
                q._tasks.remove(testFn);
            },
            process: function() {
                if (!isProcessing) {
                    for (isProcessing = !0; !q.paused && numRunning < q.concurrency && q._tasks.length; ) {
                        var tasks = [], data = [], l = q._tasks.length;
                        q.payload && (l = Math.min(l, q.payload));
                        for (var i = 0; i < l; i++) {
                            var node = q._tasks.shift();
                            tasks.push(node), workersList.push(node), data.push(node.data);
                        }
                        numRunning += 1, 0 === q._tasks.length && q.empty(), numRunning === q.concurrency && q.saturated();
                        var cb = onlyOnce(_next(tasks));
                        _worker(data, cb);
                    }
                    isProcessing = !1;
                }
            },
            length: function() {
                return q._tasks.length;
            },
            running: function() {
                return numRunning;
            },
            workersList: function() {
                return workersList;
            },
            idle: function() {
                return q._tasks.length + numRunning === 0;
            },
            pause: function() {
                q.paused = !0;
            },
            resume: function() {
                !1 !== q.paused && (q.paused = !1, setImmediate$1(q.process));
            }
        };
        return q;
    }
    function cargo(worker, payload) {
        return queue(worker, 1, payload);
    }
    function reduce(coll, memo, iteratee, callback) {
        callback = once(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        eachOfSeries(coll, function(x, i, callback) {
            _iteratee(memo, x, function(err, v) {
                memo = v, callback(err);
            });
        }, function(err) {
            callback(err, memo);
        });
    }
    function seq() {
        var _functions = arrayMap(arguments, wrapAsync);
        return function() {
            var args = slice(arguments), that = this, cb = args[args.length - 1];
            "function" == typeof cb ? args.pop() : cb = noop, reduce(_functions, args, function(newargs, fn, cb) {
                fn.apply(that, newargs.concat(function(err) {
                    var nextargs = slice(arguments, 1);
                    cb(err, nextargs);
                }));
            }, function(err, results) {
                cb.apply(that, [ err ].concat(results));
            });
        };
    }
    function identity(value) {
        return value;
    }
    function _createTester(check, getResult) {
        return function(eachfn, arr, iteratee, cb) {
            cb = cb || noop;
            var testResult, testPassed = !1;
            eachfn(arr, function(value, _, callback) {
                iteratee(value, function(err, result) {
                    err ? callback(err) : check(result) && !testResult ? (testPassed = !0, testResult = getResult(!0, value), 
                    callback(null, breakLoop)) : callback();
                });
            }, function(err) {
                err ? cb(err) : cb(null, testPassed ? testResult : getResult(!1));
            });
        };
    }
    function _findGetResult(v, x) {
        return x;
    }
    function consoleFunc(name) {
        return function(fn) {
            var args = slice(arguments, 1);
            args.push(function(err) {
                var args = slice(arguments, 1);
                "object" == typeof console && (err ? console.error && console.error(err) : console[name] && arrayEach(args, function(x) {
                    console[name](x);
                }));
            }), wrapAsync(fn).apply(null, args);
        };
    }
    function doDuring(fn, test, callback) {
        function next(err) {
            if (err) return callback(err);
            var args = slice(arguments, 1);
            args.push(check), _test.apply(this, args);
        }
        function check(err, truth) {
            return err ? callback(err) : truth ? void _fn(next) : callback(null);
        }
        callback = onlyOnce(callback || noop);
        var _fn = wrapAsync(fn), _test = wrapAsync(test);
        check(null, !0);
    }
    function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback || noop);
        var _iteratee = wrapAsync(iteratee), next = function(err) {
            if (err) return callback(err);
            var args = slice(arguments, 1);
            return test.apply(this, args) ? _iteratee(next) : void callback.apply(null, [ null ].concat(args));
        };
        _iteratee(next);
    }
    function doUntil(iteratee, test, callback) {
        doWhilst(iteratee, function() {
            return !test.apply(this, arguments);
        }, callback);
    }
    function during(test, fn, callback) {
        function next(err) {
            return err ? callback(err) : void _test(check);
        }
        function check(err, truth) {
            return err ? callback(err) : truth ? void _fn(next) : callback(null);
        }
        callback = onlyOnce(callback || noop);
        var _fn = wrapAsync(fn), _test = wrapAsync(test);
        _test(check);
    }
    function _withoutIndex(iteratee) {
        return function(value, index, callback) {
            return iteratee(value, callback);
        };
    }
    function eachLimit(coll, iteratee, callback) {
        eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    function eachLimit$1(coll, limit, iteratee, callback) {
        _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    function ensureAsync(fn) {
        return isAsync(fn) ? fn : initialParams(function(args, callback) {
            var sync = !0;
            args.push(function() {
                var innerArgs = arguments;
                sync ? setImmediate$1(function() {
                    callback.apply(null, innerArgs);
                }) : callback.apply(null, innerArgs);
            }), fn.apply(this, args), sync = !1;
        });
    }
    function notId(v) {
        return !v;
    }
    function baseProperty(key) {
        return function(object) {
            return null == object ? void 0 : object[key];
        };
    }
    function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, function(x, index, callback) {
            iteratee(x, function(err, v) {
                truthValues[index] = !!v, callback(err);
            });
        }, function(err) {
            if (err) return callback(err);
            for (var results = [], i = 0; i < arr.length; i++) truthValues[i] && results.push(arr[i]);
            callback(null, results);
        });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, function(x, index, callback) {
            iteratee(x, function(err, v) {
                err ? callback(err) : (v && results.push({
                    index: index,
                    value: x
                }), callback());
            });
        }, function(err) {
            err ? callback(err) : callback(null, arrayMap(results.sort(function(a, b) {
                return a.index - b.index;
            }), baseProperty("value")));
        });
    }
    function _filter(eachfn, coll, iteratee, callback) {
        (isArrayLike(coll) ? filterArray : filterGeneric)(eachfn, coll, wrapAsync(iteratee), callback || noop);
    }
    function forever(fn, errback) {
        function next(err) {
            return err ? done(err) : void task(next);
        }
        var done = onlyOnce(errback || noop), task = wrapAsync(ensureAsync(fn));
        next();
    }
    function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback || noop);
        var newObj = {}, _iteratee = wrapAsync(iteratee);
        eachOfLimit(obj, limit, function(val, key, next) {
            _iteratee(val, key, function(err, result) {
                return err ? next(err) : (newObj[key] = result, void next());
            });
        }, function(err) {
            callback(err, newObj);
        });
    }
    function has(obj, key) {
        return key in obj;
    }
    function memoize(fn, hasher) {
        var memo = Object.create(null), queues = Object.create(null);
        hasher = hasher || identity;
        var _fn = wrapAsync(fn), memoized = initialParams(function(args, callback) {
            var key = hasher.apply(null, args);
            has(memo, key) ? setImmediate$1(function() {
                callback.apply(null, memo[key]);
            }) : has(queues, key) ? queues[key].push(callback) : (queues[key] = [ callback ], 
            _fn.apply(null, args.concat(function() {
                var args = slice(arguments);
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) q[i].apply(null, args);
            })));
        });
        return memoized.memo = memo, memoized.unmemoized = fn, memoized;
    }
    function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, function(task, key, callback) {
            wrapAsync(task)(function(err, result) {
                arguments.length > 2 && (result = slice(arguments, 1)), results[key] = result, callback(err);
            });
        }, function(err) {
            callback(err, results);
        });
    }
    function parallelLimit(tasks, callback) {
        _parallel(eachOf, tasks, callback);
    }
    function parallelLimit$1(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
    }
    function race(tasks, callback) {
        if (callback = once(callback || noop), !isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length) return callback();
        for (var i = 0, l = tasks.length; i < l; i++) wrapAsync(tasks[i])(callback);
    }
    function reduceRight(array, memo, iteratee, callback) {
        reduce(slice(array).reverse(), memo, iteratee, callback);
    }
    function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function(args, reflectCallback) {
            return args.push(function(error, cbArg) {
                if (error) reflectCallback(null, {
                    error: error
                }); else {
                    var value;
                    value = arguments.length <= 2 ? cbArg : slice(arguments, 1), reflectCallback(null, {
                        value: value
                    });
                }
            }), _fn.apply(this, args);
        });
    }
    function reject$1(eachfn, arr, iteratee, callback) {
        _filter(eachfn, arr, function(value, cb) {
            iteratee(value, function(err, v) {
                cb(err, !v);
            });
        }, callback);
    }
    function reflectAll(tasks) {
        var results;
        return isArray(tasks) ? results = arrayMap(tasks, reflect) : (results = {}, baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
        })), results;
    }
    function constant$1(value) {
        return function() {
            return value;
        };
    }
    function retry(opts, task, callback) {
        function retryAttempt() {
            _task(function(err) {
                err && attempt++ < options.times && ("function" != typeof options.errorFilter || options.errorFilter(err)) ? setTimeout(retryAttempt, options.intervalFunc(attempt)) : callback.apply(null, arguments);
            });
        }
        var DEFAULT_TIMES = 5, DEFAULT_INTERVAL = 0, options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && "function" == typeof opts ? (callback = task || noop, 
        task = opts) : (function(acc, t) {
            if ("object" == typeof t) acc.times = +t.times || DEFAULT_TIMES, acc.intervalFunc = "function" == typeof t.interval ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL), 
            acc.errorFilter = t.errorFilter; else {
                if ("number" != typeof t && "string" != typeof t) throw new Error("Invalid arguments for async.retry");
                acc.times = +t || DEFAULT_TIMES;
            }
        }(options, opts), callback = callback || noop), "function" != typeof task) throw new Error("Invalid arguments for async.retry");
        var _task = wrapAsync(task), attempt = 1;
        retryAttempt();
    }
    function series(tasks, callback) {
        _parallel(eachOfSeries, tasks, callback);
    }
    function sortBy(coll, iteratee, callback) {
        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
        var _iteratee = wrapAsync(iteratee);
        map(coll, function(x, callback) {
            _iteratee(x, function(err, criteria) {
                return err ? callback(err) : void callback(null, {
                    value: x,
                    criteria: criteria
                });
            });
        }, function(err, results) {
            return err ? callback(err) : void callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
        });
    }
    function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams(function(args, callback) {
            function timeoutCallback() {
                var name = asyncFn.name || "anonymous", error = new Error('Callback function "' + name + '" timed out.');
                error.code = "ETIMEDOUT", info && (error.info = info), timedOut = !0, callback(error);
            }
            var timer, timedOut = !1;
            args.push(function() {
                timedOut || (callback.apply(null, arguments), clearTimeout(timer));
            }), timer = setTimeout(timeoutCallback, milliseconds), fn.apply(null, args);
        });
    }
    function baseRange(start, end, step, fromRight) {
        for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--; ) result[fromRight ? length : ++index] = start, 
        start += step;
        return result;
    }
    function timeLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
        arguments.length <= 3 && (callback = iteratee, iteratee = accumulator, accumulator = isArray(coll) ? [] : {}), 
        callback = once(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        eachOf(coll, function(v, k, cb) {
            _iteratee(accumulator, v, k, cb);
        }, function(err) {
            callback(err, accumulator);
        });
    }
    function tryEach(tasks, callback) {
        var result, error = null;
        callback = callback || noop, eachSeries(tasks, function(task, callback) {
            wrapAsync(task)(function(err, res) {
                result = arguments.length > 2 ? slice(arguments, 1) : res, error = err, callback(!err);
            });
        }, function() {
            callback(error, result);
        });
    }
    function unmemoize(fn) {
        return function() {
            return (fn.unmemoized || fn).apply(null, arguments);
        };
    }
    function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        if (!test()) return callback(null);
        var next = function(err) {
            if (err) return callback(err);
            if (test()) return _iteratee(next);
            var args = slice(arguments, 1);
            callback.apply(null, [ null ].concat(args));
        };
        _iteratee(next);
    }
    function until(test, iteratee, callback) {
        whilst(function() {
            return !test.apply(this, arguments);
        }, iteratee, callback);
    }
    var _defer, initialParams = function(fn) {
        return function() {
            var args = slice(arguments), callback = args.pop();
            fn.call(this, args, callback);
        };
    }, hasSetImmediate = "function" == typeof setImmediate && setImmediate, hasNextTick = "object" == typeof process && "function" == typeof process.nextTick;
    _defer = hasSetImmediate ? setImmediate : hasNextTick ? process.nextTick : fallback;
    var setImmediate$1 = wrap(_defer), supportsSymbol = "function" == typeof Symbol, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0, objectProto$1 = Object.prototype, nativeObjectToString$1 = objectProto$1.toString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0, asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]", MAX_SAFE_INTEGER = 9007199254740991, breakLoop = {}, iteratorSymbol = "function" == typeof Symbol && Symbol.iterator, getIterator = function(coll) {
        return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
    }, argsTag = "[object Arguments]", objectProto$3 = Object.prototype, hasOwnProperty$2 = objectProto$3.hasOwnProperty, propertyIsEnumerable = objectProto$3.propertyIsEnumerable, isArguments = baseIsArguments(function() {
        return arguments;
    }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    }, isArray = Array.isArray, freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer = moduleExports ? root.Buffer : void 0, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse, MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/, typedArrayTags = {};
    typedArrayTags["[object Float32Array]"] = typedArrayTags["[object Float64Array]"] = typedArrayTags["[object Int8Array]"] = typedArrayTags["[object Int16Array]"] = typedArrayTags["[object Int32Array]"] = typedArrayTags["[object Uint8Array]"] = typedArrayTags["[object Uint8ClampedArray]"] = typedArrayTags["[object Uint16Array]"] = typedArrayTags["[object Uint32Array]"] = !0, 
    typedArrayTags["[object Arguments]"] = typedArrayTags["[object Array]"] = typedArrayTags["[object ArrayBuffer]"] = typedArrayTags["[object Boolean]"] = typedArrayTags["[object DataView]"] = typedArrayTags["[object Date]"] = typedArrayTags["[object Error]"] = typedArrayTags["[object Function]"] = typedArrayTags["[object Map]"] = typedArrayTags["[object Number]"] = typedArrayTags["[object Object]"] = typedArrayTags["[object RegExp]"] = typedArrayTags["[object Set]"] = typedArrayTags["[object String]"] = typedArrayTags["[object WeakMap]"] = !1;
    var freeExports$1 = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && "object" == typeof module && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal.process, nodeUtil = function() {
        try {
            return freeProcess && freeProcess.binding("util");
        } catch (e) {}
    }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? function(func) {
        return function(value) {
            return func(value);
        };
    }(nodeIsTypedArray) : baseIsTypedArray, objectProto$2 = Object.prototype, hasOwnProperty$1 = objectProto$2.hasOwnProperty, objectProto$5 = Object.prototype, nativeKeys = function(func, transform) {
        return function(arg) {
            return func(transform(arg));
        };
    }(Object.keys, Object), objectProto$4 = Object.prototype, hasOwnProperty$3 = objectProto$4.hasOwnProperty, eachOfGeneric = doLimit(eachOfLimit, 1 / 0), eachOf = function(coll, iteratee, callback) {
        (isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric)(coll, wrapAsync(iteratee), callback);
    }, map = doParallel(_asyncMap), applyEach = applyEach$1(map), mapLimit = doParallelLimit(_asyncMap), mapSeries = doLimit(mapLimit, 1), applyEachSeries = applyEach$1(mapSeries), apply = function(fn) {
        var args = slice(arguments, 1);
        return function() {
            var callArgs = slice(arguments);
            return fn.apply(null, args.concat(callArgs));
        };
    }, baseFor = function(fromRight) {
        return function(object, iteratee, keysFunc) {
            for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
                var key = props[fromRight ? length : ++index];
                if (!1 === iteratee(iterable[key], key, iterable)) break;
            }
            return object;
        };
    }(), auto = function(tasks, concurrency, callback) {
        function enqueueTask(key, task) {
            readyTasks.push(function() {
                runTask(key, task);
            });
        }
        function processQueue() {
            if (0 === readyTasks.length && 0 === runningTasks) return callback(null, results);
            for (;readyTasks.length && runningTasks < concurrency; ) {
                readyTasks.shift()();
            }
        }
        function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            taskListeners || (taskListeners = listeners[taskName] = []), taskListeners.push(fn);
        }
        function taskComplete(taskName) {
            arrayEach(listeners[taskName] || [], function(fn) {
                fn();
            }), processQueue();
        }
        function runTask(key, task) {
            if (!hasError) {
                var taskCallback = onlyOnce(function(err, result) {
                    if (runningTasks--, arguments.length > 2 && (result = slice(arguments, 1)), err) {
                        var safeResults = {};
                        baseForOwn(results, function(val, rkey) {
                            safeResults[rkey] = val;
                        }), safeResults[key] = result, hasError = !0, listeners = Object.create(null), callback(err, safeResults);
                    } else results[key] = result, taskComplete(key);
                });
                runningTasks++;
                var taskFn = wrapAsync(task[task.length - 1]);
                task.length > 1 ? taskFn(results, taskCallback) : taskFn(taskCallback);
            }
        }
        function getDependents(taskName) {
            var result = [];
            return baseForOwn(tasks, function(task, key) {
                isArray(task) && baseIndexOf(task, taskName, 0) >= 0 && result.push(key);
            }), result;
        }
        "function" == typeof concurrency && (callback = concurrency, concurrency = null), 
        callback = once(callback || noop);
        var keys$$1 = keys(tasks), numTasks = keys$$1.length;
        if (!numTasks) return callback(null);
        concurrency || (concurrency = numTasks);
        var results = {}, runningTasks = 0, hasError = !1, listeners = Object.create(null), readyTasks = [], readyToCheck = [], uncheckedDependencies = {};
        baseForOwn(tasks, function(task, key) {
            if (!isArray(task)) return enqueueTask(key, [ task ]), void readyToCheck.push(key);
            var dependencies = task.slice(0, task.length - 1), remainingDependencies = dependencies.length;
            return 0 === remainingDependencies ? (enqueueTask(key, task), void readyToCheck.push(key)) : (uncheckedDependencies[key] = remainingDependencies, 
            void arrayEach(dependencies, function(dependencyName) {
                if (!tasks[dependencyName]) throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
                addListener(dependencyName, function() {
                    0 === --remainingDependencies && enqueueTask(key, task);
                });
            }));
        }), function() {
            for (var currentTask, counter = 0; readyToCheck.length; ) currentTask = readyToCheck.pop(), 
            counter++, arrayEach(getDependents(currentTask), function(dependent) {
                0 == --uncheckedDependencies[dependent] && readyToCheck.push(dependent);
            });
            if (counter !== numTasks) throw new Error("async.auto cannot execute tasks due to a recursive dependency");
        }(), processQueue();
    }, symbolTag = "[object Symbol]", INFINITY = 1 / 0, symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0, reHasUnicode = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"), rsCombo = "[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", reOptMod = "(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?", rsOptJoin = "(?:\\u200d(?:" + [ "[^\\ud800-\\udfff]", rsRegional, rsSurrPair ].join("|") + ")[\\ufe0e\\ufe0f]?" + reOptMod + ")*", rsSeq = "[\\ufe0e\\ufe0f]?" + reOptMod + rsOptJoin, rsSymbol = "(?:" + [ "[^\\ud800-\\udfff]" + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, "[\\ud800-\\udfff]" ].join("|") + ")", reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reTrim = /^\s+|\s+$/g, FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /(=.+)?(\s*)$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    DLL.prototype.removeLink = function(node) {
        return node.prev ? node.prev.next = node.next : this.head = node.next, node.next ? node.next.prev = node.prev : this.tail = node.prev, 
        node.prev = node.next = null, this.length -= 1, node;
    }, DLL.prototype.empty = function() {
        for (;this.head; ) this.shift();
        return this;
    }, DLL.prototype.insertAfter = function(node, newNode) {
        newNode.prev = node, newNode.next = node.next, node.next ? node.next.prev = newNode : this.tail = newNode, 
        node.next = newNode, this.length += 1;
    }, DLL.prototype.insertBefore = function(node, newNode) {
        newNode.prev = node.prev, newNode.next = node, node.prev ? node.prev.next = newNode : this.head = newNode, 
        node.prev = newNode, this.length += 1;
    }, DLL.prototype.unshift = function(node) {
        this.head ? this.insertBefore(this.head, node) : setInitial(this, node);
    }, DLL.prototype.push = function(node) {
        this.tail ? this.insertAfter(this.tail, node) : setInitial(this, node);
    }, DLL.prototype.shift = function() {
        return this.head && this.removeLink(this.head);
    }, DLL.prototype.pop = function() {
        return this.tail && this.removeLink(this.tail);
    }, DLL.prototype.toArray = function() {
        for (var arr = Array(this.length), curr = this.head, idx = 0; idx < this.length; idx++) arr[idx] = curr.data, 
        curr = curr.next;
        return arr;
    }, DLL.prototype.remove = function(testFn) {
        for (var curr = this.head; curr; ) {
            var next = curr.next;
            testFn(curr) && this.removeLink(curr), curr = next;
        }
        return this;
    };
    var _defer$1, eachOfSeries = doLimit(eachOfLimit, 1), compose = function() {
        return seq.apply(null, slice(arguments).reverse());
    }, _concat = Array.prototype.concat, concatLimit = function(coll, limit, iteratee, callback) {
        callback = callback || noop;
        var _iteratee = wrapAsync(iteratee);
        mapLimit(coll, limit, function(val, callback) {
            _iteratee(val, function(err) {
                return err ? callback(err) : callback(null, slice(arguments, 1));
            });
        }, function(err, mapResults) {
            for (var result = [], i = 0; i < mapResults.length; i++) mapResults[i] && (result = _concat.apply(result, mapResults[i]));
            return callback(err, result);
        });
    }, concat = doLimit(concatLimit, 1 / 0), concatSeries = doLimit(concatLimit, 1), constant = function() {
        var values = slice(arguments), args = [ null ].concat(values);
        return function() {
            return arguments[arguments.length - 1].apply(this, args);
        };
    }, detect = doParallel(_createTester(identity, _findGetResult)), detectLimit = doParallelLimit(_createTester(identity, _findGetResult)), detectSeries = doLimit(detectLimit, 1), dir = consoleFunc("dir"), eachSeries = doLimit(eachLimit$1, 1), every = doParallel(_createTester(notId, notId)), everyLimit = doParallelLimit(_createTester(notId, notId)), everySeries = doLimit(everyLimit, 1), filter = doParallel(_filter), filterLimit = doParallelLimit(_filter), filterSeries = doLimit(filterLimit, 1), groupByLimit = function(coll, limit, iteratee, callback) {
        callback = callback || noop;
        var _iteratee = wrapAsync(iteratee);
        mapLimit(coll, limit, function(val, callback) {
            _iteratee(val, function(err, key) {
                return err ? callback(err) : callback(null, {
                    key: key,
                    val: val
                });
            });
        }, function(err, mapResults) {
            for (var result = {}, hasOwnProperty = Object.prototype.hasOwnProperty, i = 0; i < mapResults.length; i++) if (mapResults[i]) {
                var key = mapResults[i].key, val = mapResults[i].val;
                hasOwnProperty.call(result, key) ? result[key].push(val) : result[key] = [ val ];
            }
            return callback(err, result);
        });
    }, groupBy = doLimit(groupByLimit, 1 / 0), groupBySeries = doLimit(groupByLimit, 1), log = consoleFunc("log"), mapValues = doLimit(mapValuesLimit, 1 / 0), mapValuesSeries = doLimit(mapValuesLimit, 1);
    _defer$1 = hasNextTick ? process.nextTick : hasSetImmediate ? setImmediate : fallback;
    var nextTick = wrap(_defer$1), queue$1 = function(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue(function(items, cb) {
            _worker(items[0], cb);
        }, concurrency, 1);
    }, priorityQueue = function(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        return q.push = function(data, priority, callback) {
            if (null == callback && (callback = noop), "function" != typeof callback) throw new Error("task callback must be a function");
            if (q.started = !0, isArray(data) || (data = [ data ]), 0 === data.length) return setImmediate$1(function() {
                q.drain();
            });
            priority = priority || 0;
            for (var nextNode = q._tasks.head; nextNode && priority >= nextNode.priority; ) nextNode = nextNode.next;
            for (var i = 0, l = data.length; i < l; i++) {
                var item = {
                    data: data[i],
                    priority: priority,
                    callback: callback
                };
                nextNode ? q._tasks.insertBefore(nextNode, item) : q._tasks.push(item);
            }
            setImmediate$1(q.process);
        }, delete q.unshift, q;
    }, reject = doParallel(reject$1), rejectLimit = doParallelLimit(reject$1), rejectSeries = doLimit(rejectLimit, 1), retryable = function(opts, task) {
        task || (task = opts, opts = null);
        var _task = wrapAsync(task);
        return initialParams(function(args, callback) {
            function taskFn(cb) {
                _task.apply(null, args.concat(cb));
            }
            opts ? retry(opts, taskFn, callback) : retry(taskFn, callback);
        });
    }, some = doParallel(_createTester(Boolean, identity)), someLimit = doParallelLimit(_createTester(Boolean, identity)), someSeries = doLimit(someLimit, 1), nativeCeil = Math.ceil, nativeMax = Math.max, times = doLimit(timeLimit, 1 / 0), timesSeries = doLimit(timeLimit, 1), waterfall = function(tasks, callback) {
        function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            args.push(onlyOnce(next)), task.apply(null, args);
        }
        function next(err) {
            return err || taskIndex === tasks.length ? callback.apply(null, arguments) : void nextTask(slice(arguments, 1));
        }
        if (callback = once(callback || noop), !isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length) return callback();
        var taskIndex = 0;
        nextTask([]);
    }, index = {
        applyEach: applyEach,
        applyEachSeries: applyEachSeries,
        apply: apply,
        asyncify: asyncify,
        auto: auto,
        autoInject: autoInject,
        cargo: cargo,
        compose: compose,
        concat: concat,
        concatLimit: concatLimit,
        concatSeries: concatSeries,
        constant: constant,
        detect: detect,
        detectLimit: detectLimit,
        detectSeries: detectSeries,
        dir: dir,
        doDuring: doDuring,
        doUntil: doUntil,
        doWhilst: doWhilst,
        during: during,
        each: eachLimit,
        eachLimit: eachLimit$1,
        eachOf: eachOf,
        eachOfLimit: eachOfLimit,
        eachOfSeries: eachOfSeries,
        eachSeries: eachSeries,
        ensureAsync: ensureAsync,
        every: every,
        everyLimit: everyLimit,
        everySeries: everySeries,
        filter: filter,
        filterLimit: filterLimit,
        filterSeries: filterSeries,
        forever: forever,
        groupBy: groupBy,
        groupByLimit: groupByLimit,
        groupBySeries: groupBySeries,
        log: log,
        map: map,
        mapLimit: mapLimit,
        mapSeries: mapSeries,
        mapValues: mapValues,
        mapValuesLimit: mapValuesLimit,
        mapValuesSeries: mapValuesSeries,
        memoize: memoize,
        nextTick: nextTick,
        parallel: parallelLimit,
        parallelLimit: parallelLimit$1,
        priorityQueue: priorityQueue,
        queue: queue$1,
        race: race,
        reduce: reduce,
        reduceRight: reduceRight,
        reflect: reflect,
        reflectAll: reflectAll,
        reject: reject,
        rejectLimit: rejectLimit,
        rejectSeries: rejectSeries,
        retry: retry,
        retryable: retryable,
        seq: seq,
        series: series,
        setImmediate: setImmediate$1,
        some: some,
        someLimit: someLimit,
        someSeries: someSeries,
        sortBy: sortBy,
        timeout: timeout,
        times: times,
        timesLimit: timeLimit,
        timesSeries: timesSeries,
        transform: transform,
        tryEach: tryEach,
        unmemoize: unmemoize,
        until: until,
        waterfall: waterfall,
        whilst: whilst,
        all: every,
        any: some,
        forEach: eachLimit,
        forEachSeries: eachSeries,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf,
        forEachOfSeries: eachOfSeries,
        forEachOfLimit: eachOfLimit,
        inject: reduce,
        foldl: reduce,
        foldr: reduceRight,
        select: filter,
        selectLimit: filterLimit,
        selectSeries: filterSeries,
        wrapSync: asyncify
    };
    exports.default = index, exports.applyEach = applyEach, exports.applyEachSeries = applyEachSeries, 
    exports.apply = apply, exports.asyncify = asyncify, exports.auto = auto, exports.autoInject = autoInject, 
    exports.cargo = cargo, exports.compose = compose, exports.concat = concat, exports.concatLimit = concatLimit, 
    exports.concatSeries = concatSeries, exports.constant = constant, exports.detect = detect, 
    exports.detectLimit = detectLimit, exports.detectSeries = detectSeries, exports.dir = dir, 
    exports.doDuring = doDuring, exports.doUntil = doUntil, exports.doWhilst = doWhilst, 
    exports.during = during, exports.each = eachLimit, exports.eachLimit = eachLimit$1, 
    exports.eachOf = eachOf, exports.eachOfLimit = eachOfLimit, exports.eachOfSeries = eachOfSeries, 
    exports.eachSeries = eachSeries, exports.ensureAsync = ensureAsync, exports.every = every, 
    exports.everyLimit = everyLimit, exports.everySeries = everySeries, exports.filter = filter, 
    exports.filterLimit = filterLimit, exports.filterSeries = filterSeries, exports.forever = forever, 
    exports.groupBy = groupBy, exports.groupByLimit = groupByLimit, exports.groupBySeries = groupBySeries, 
    exports.log = log, exports.map = map, exports.mapLimit = mapLimit, exports.mapSeries = mapSeries, 
    exports.mapValues = mapValues, exports.mapValuesLimit = mapValuesLimit, exports.mapValuesSeries = mapValuesSeries, 
    exports.memoize = memoize, exports.nextTick = nextTick, exports.parallel = parallelLimit, 
    exports.parallelLimit = parallelLimit$1, exports.priorityQueue = priorityQueue, 
    exports.queue = queue$1, exports.race = race, exports.reduce = reduce, exports.reduceRight = reduceRight, 
    exports.reflect = reflect, exports.reflectAll = reflectAll, exports.reject = reject, 
    exports.rejectLimit = rejectLimit, exports.rejectSeries = rejectSeries, exports.retry = retry, 
    exports.retryable = retryable, exports.seq = seq, exports.series = series, exports.setImmediate = setImmediate$1, 
    exports.some = some, exports.someLimit = someLimit, exports.someSeries = someSeries, 
    exports.sortBy = sortBy, exports.timeout = timeout, exports.times = times, exports.timesLimit = timeLimit, 
    exports.timesSeries = timesSeries, exports.transform = transform, exports.tryEach = tryEach, 
    exports.unmemoize = unmemoize, exports.until = until, exports.waterfall = waterfall, 
    exports.whilst = whilst, exports.all = every, exports.allLimit = everyLimit, exports.allSeries = everySeries, 
    exports.any = some, exports.anyLimit = someLimit, exports.anySeries = someSeries, 
    exports.find = detect, exports.findLimit = detectLimit, exports.findSeries = detectSeries, 
    exports.forEach = eachLimit, exports.forEachSeries = eachSeries, exports.forEachLimit = eachLimit$1, 
    exports.forEachOf = eachOf, exports.forEachOfSeries = eachOfSeries, exports.forEachOfLimit = eachOfLimit, 
    exports.inject = reduce, exports.foldl = reduce, exports.foldr = reduceRight, exports.select = filter, 
    exports.selectLimit = filterLimit, exports.selectSeries = filterSeries, exports.wrapSync = asyncify, 
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
}), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define("moment", factory) : global.moment = factory();
}(this, function() {
    "use strict";
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function isArray(input) {
        return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input);
    }
    function isObject(input) {
        return null != input && "[object Object]" === Object.prototype.toString.call(input);
    }
    function isObjectEmpty(obj) {
        var k;
        for (k in obj) return !1;
        return !0;
    }
    function isUndefined(input) {
        return void 0 === input;
    }
    function isNumber(input) {
        return "number" == typeof input || "[object Number]" === Object.prototype.toString.call(input);
    }
    function isDate(input) {
        return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input);
    }
    function map(arr, fn) {
        var i, res = [];
        for (i = 0; i < arr.length; ++i) res.push(fn(arr[i], i));
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) hasOwnProp(b, i) && (a[i] = b[i]);
        return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), 
        a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, !0).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: !1,
            weekdayMismatch: !1
        };
    }
    function getParsingFlags(m) {
        return null == m._pf && (m._pf = defaultParsingFlags()), m._pf;
    }
    function isValid(m) {
        if (null == m._isValid) {
            var flags = getParsingFlags(m), parsedParts = some$1.call(flags.parsedDateParts, function(i) {
                return null != i;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict && (isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour), 
            null != Object.isFrozen && Object.isFrozen(m)) return isNowValid;
            m._isValid = isNowValid;
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        return null != flags ? extend(getParsingFlags(m), flags) : getParsingFlags(m).userInvalidated = !0, 
        m;
    }
    function copyConfig(to, from) {
        var i, prop, val;
        if (isUndefined(from._isAMomentObject) || (to._isAMomentObject = from._isAMomentObject), 
        isUndefined(from._i) || (to._i = from._i), isUndefined(from._f) || (to._f = from._f), 
        isUndefined(from._l) || (to._l = from._l), isUndefined(from._strict) || (to._strict = from._strict), 
        isUndefined(from._tzm) || (to._tzm = from._tzm), isUndefined(from._isUTC) || (to._isUTC = from._isUTC), 
        isUndefined(from._offset) || (to._offset = from._offset), isUndefined(from._pf) || (to._pf = getParsingFlags(from)), 
        isUndefined(from._locale) || (to._locale = from._locale), momentProperties.length > 0) for (i = 0; i < momentProperties.length; i++) prop = momentProperties[i], 
        val = from[prop], isUndefined(val) || (to[prop] = val);
        return to;
    }
    function Moment(config) {
        copyConfig(this, config), this._d = new Date(null != config._d ? config._d.getTime() : NaN), 
        this.isValid() || (this._d = new Date(NaN)), !1 === updateInProgress && (updateInProgress = !0, 
        hooks.updateOffset(this), updateInProgress = !1);
    }
    function isMoment(obj) {
        return obj instanceof Moment || null != obj && null != obj._isAMomentObject;
    }
    function absFloor(number) {
        return number < 0 ? Math.ceil(number) || 0 : Math.floor(number);
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        return 0 !== coercedNumber && isFinite(coercedNumber) && (value = absFloor(coercedNumber)), 
        value;
    }
    function compareArrays(array1, array2, dontConvert) {
        var i, len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0;
        for (i = 0; i < len; i++) (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
        return diffs + lengthDiff;
    }
    function warn(msg) {
        !1 === hooks.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg);
    }
    function deprecate(msg, fn) {
        var firstTime = !0;
        return extend(function() {
            if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), firstTime) {
                for (var arg, args = [], i = 0; i < arguments.length; i++) {
                    if (arg = "", "object" == typeof arguments[i]) {
                        arg += "\n[" + i + "] ";
                        for (var key in arguments[0]) arg += key + ": " + arguments[0][key] + ", ";
                        arg = arg.slice(0, -2);
                    } else arg = arguments[i];
                    args.push(arg);
                }
                warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack), 
                firstTime = !1;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    function deprecateSimple(name, msg) {
        null != hooks.deprecationHandler && hooks.deprecationHandler(name, msg), deprecations[name] || (warn(msg), 
        deprecations[name] = !0);
    }
    function isFunction(input) {
        return input instanceof Function || "[object Function]" === Object.prototype.toString.call(input);
    }
    function set(config) {
        var prop, i;
        for (i in config) prop = config[i], isFunction(prop) ? this[i] = prop : this["_" + i] = prop;
        this._config = config, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
        var prop, res = extend({}, parentConfig);
        for (prop in childConfig) hasOwnProp(childConfig, prop) && (isObject(parentConfig[prop]) && isObject(childConfig[prop]) ? (res[prop] = {}, 
        extend(res[prop], parentConfig[prop]), extend(res[prop], childConfig[prop])) : null != childConfig[prop] ? res[prop] = childConfig[prop] : delete res[prop]);
        for (prop in parentConfig) hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop]) && (res[prop] = extend({}, res[prop]));
        return res;
    }
    function Locale(config) {
        null != config && this.set(config);
    }
    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar.sameElse;
        return isFunction(output) ? output.call(mom, now) : output;
    }
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        return format || !formatUpper ? format : (this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        }), this._longDateFormat[key]);
    }
    function invalidDate() {
        return this._invalidDate;
    }
    function ordinal(number) {
        return this._ordinal.replace("%d", number);
    }
    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return "string" == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedProp, prop, normalizedInput = {};
        for (prop in inputObject) hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop)) && (normalizedInput[normalizedProp] = inputObject[prop]);
        return normalizedInput;
    }
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) units.push({
            unit: u,
            priority: priorities[u]
        });
        return units.sort(function(a, b) {
            return a.priority - b.priority;
        }), units;
    }
    function makeGetSet(unit, keepTime) {
        return function(value) {
            return null != value ? (set$1(this, unit, value), hooks.updateOffset(this, keepTime), 
            this) : get(this, unit);
        };
    }
    function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
        mom.isValid() && mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
    function stringGet(units) {
        return units = normalizeUnits(units), isFunction(this[units]) ? this[units]() : this;
    }
    function stringSet(units, value) {
        if ("object" == typeof units) {
            units = normalizeObjectUnits(units);
            for (var prioritized = getPrioritizedUnits(units), i = 0; i < prioritized.length; i++) this[prioritized[i].unit](units[prioritized[i].unit]);
        } else if (units = normalizeUnits(units), isFunction(this[units])) return this[units](value);
        return this;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length;
        return (number >= 0 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        "string" == typeof callback && (func = function() {
            return this[callback]();
        }), token && (formatTokenFunctions[token] = func), padded && (formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        }), ordinal && (formatTokenFunctions[ordinal] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        });
    }
    function removeFormattingTokens(input) {
        return input.match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var i, length, array = format.match(formattingTokens);
        for (i = 0, length = array.length; i < length; i++) formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = removeFormattingTokens(array[i]);
        return function(mom) {
            var i, output = "";
            for (i = 0; i < length; i++) output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            return output;
        };
    }
    function formatMoment(m, format) {
        return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format), 
        formatFunctions[format](m)) : m.localeData().invalidDate();
    }
    function expandFormat(format, locale) {
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        var i = 5;
        for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format); ) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), 
        localFormattingTokens.lastIndex = 0, i -= 1;
        return format;
    }
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        return hasOwnProp(regexes, token) ? regexes[token](config._strict, config._locale) : new RegExp(unescapeFormat(token));
    }
    function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function addParseToken(token, callback) {
        var i, func = callback;
        for ("string" == typeof token && (token = [ token ]), isNumber(callback) && (func = function(input, array) {
            array[callback] = toInt(input);
        }), i = 0; i < token.length; i++) tokens[token[i]] = func;
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {}, callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        null != input && hasOwnProp(tokens, token) && tokens[token](input, config._a, config, token);
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function localeMonths(m, format) {
        return m ? isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()] : isArray(this._months) ? this._months : this._months.standalone;
    }
    function localeMonthsShort(m, format) {
        return m ? isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()] : isArray(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
    }
    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], 
        this._shortMonthsParse = [], i = 0; i < 12; ++i) mom = createUTC([ 2e3, i ]), this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase(), 
        this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        return strict ? "MMM" === format ? (ii = indexOf$1.call(this._shortMonthsParse, llc), 
        -1 !== ii ? ii : null) : (ii = indexOf$1.call(this._longMonthsParse, llc), -1 !== ii ? ii : null) : "MMM" === format ? (ii = indexOf$1.call(this._shortMonthsParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._longMonthsParse, llc), -1 !== ii ? ii : null)) : (ii = indexOf$1.call(this._longMonthsParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._shortMonthsParse, llc), -1 !== ii ? ii : null));
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) return handleStrictParse.call(this, monthName, format, strict);
        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), 
        i = 0; i < 12; i++) {
            if (mom = createUTC([ 2e3, i ]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), 
            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), 
            strict || this._monthsParse[i] || (regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), 
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i;
            if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i;
            if (!strict && this._monthsParse[i].test(monthName)) return i;
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) return mom;
        if ("string" == typeof value) if (/^\d+$/.test(value)) value = toInt(value); else if (value = mom.localeData().monthsParse(value), 
        !isNumber(value)) return mom;
        return dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)), mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth), 
        mom;
    }
    function getSetMonth(value) {
        return null != value ? (setMonth(this, value), hooks.updateOffset(this, !0), this) : get(this, "Month");
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
        return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
        isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), 
        this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }
    function monthsRegex(isStrict) {
        return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
        isStrict ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), 
        this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex);
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var i, mom, shortPieces = [], longPieces = [], mixedPieces = [];
        for (i = 0; i < 12; i++) mom = createUTC([ 2e3, i ]), shortPieces.push(this.monthsShort(mom, "")), 
        longPieces.push(this.months(mom, "")), mixedPieces.push(this.months(mom, "")), mixedPieces.push(this.monthsShort(mom, ""));
        for (shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), 
        i = 0; i < 12; i++) shortPieces[i] = regexEscape(shortPieces[i]), longPieces[i] = regexEscape(longPieces[i]);
        for (i = 0; i < 24; i++) mixedPieces[i] = regexEscape(mixedPieces[i]);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, 
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    }
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        return y < 100 && y >= 0 && isFinite(date.getFullYear()) && date.setFullYear(y), 
        date;
    }
    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        return y < 100 && y >= 0 && isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y), 
        date;
    }
    function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy;
        return -(7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7 + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var resYear, resDayOfYear, localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset;
        return dayOfYear <= 0 ? (resYear = year - 1, resDayOfYear = daysInYear(resYear) + dayOfYear) : dayOfYear > daysInYear(year) ? (resYear = year + 1, 
        resDayOfYear = dayOfYear - daysInYear(year)) : (resYear = year, resDayOfYear = dayOfYear), 
        {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    function weekOfYear(mom, dow, doy) {
        var resWeek, resYear, weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1;
        return week < 1 ? (resYear = mom.year() - 1, resWeek = week + weeksInYear(resYear, dow, doy)) : week > weeksInYear(mom.year(), dow, doy) ? (resWeek = week - weeksInYear(mom.year(), dow, doy), 
        resYear = mom.year() + 1) : (resYear = mom.year(), resWeek = week), {
            week: resWeek,
            year: resYear
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return null == input ? week : this.add(7 * (input - week), "d");
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return null == input ? week : this.add(7 * (input - week), "d");
    }
    function parseWeekday(input, locale) {
        return "string" != typeof input ? input : isNaN(input) ? (input = locale.weekdaysParse(input), 
        "number" == typeof input ? input : null) : parseInt(input, 10);
    }
    function parseIsoWeekday(input, locale) {
        return "string" == typeof input ? locale.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input;
    }
    function localeWeekdays(m, format) {
        return m ? isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? "format" : "standalone"][m.day()] : isArray(this._weekdays) ? this._weekdays : this._weekdays.standalone;
    }
    function localeWeekdaysShort(m) {
        return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
        return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], 
        this._minWeekdaysParse = [], i = 0; i < 7; ++i) mom = createUTC([ 2e3, 1 ]).day(i), 
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase(), 
        this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        return strict ? "dddd" === format ? (ii = indexOf$1.call(this._weekdaysParse, llc), 
        -1 !== ii ? ii : null) : "ddd" === format ? (ii = indexOf$1.call(this._shortWeekdaysParse, llc), 
        -1 !== ii ? ii : null) : (ii = indexOf$1.call(this._minWeekdaysParse, llc), -1 !== ii ? ii : null) : "dddd" === format ? (ii = indexOf$1.call(this._weekdaysParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._shortWeekdaysParse, llc), -1 !== ii ? ii : (ii = indexOf$1.call(this._minWeekdaysParse, llc), 
        -1 !== ii ? ii : null))) : "ddd" === format ? (ii = indexOf$1.call(this._shortWeekdaysParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._weekdaysParse, llc), -1 !== ii ? ii : (ii = indexOf$1.call(this._minWeekdaysParse, llc), 
        -1 !== ii ? ii : null))) : (ii = indexOf$1.call(this._minWeekdaysParse, llc), -1 !== ii ? ii : (ii = indexOf$1.call(this._weekdaysParse, llc), 
        -1 !== ii ? ii : (ii = indexOf$1.call(this._shortWeekdaysParse, llc), -1 !== ii ? ii : null)));
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) return handleStrictParse$1.call(this, weekdayName, format, strict);
        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], 
        this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
            if (mom = createUTC([ 2e3, 1 ]).day(i), strict && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", ".?") + "$", "i"), 
            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", ".?") + "$", "i"), 
            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", ".?") + "$", "i")), 
            this._weekdaysParse[i] || (regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), 
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "dddd" === format && this._fullWeekdaysParse[i].test(weekdayName)) return i;
            if (strict && "ddd" === format && this._shortWeekdaysParse[i].test(weekdayName)) return i;
            if (strict && "dd" === format && this._minWeekdaysParse[i].test(weekdayName)) return i;
            if (!strict && this._weekdaysParse[i].test(weekdayName)) return i;
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        return null != input ? (input = parseWeekday(input, this.localeData()), this.add(input - day, "d")) : day;
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return null == input ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        if (null != input) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        }
        return this.day() || 7;
    }
    function weekdaysRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), 
        this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }
    function weekdaysShortRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), 
        this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }
    function weekdaysMinRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), 
        this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var i, mom, minp, shortp, longp, minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [];
        for (i = 0; i < 7; i++) mom = createUTC([ 2e3, 1 ]).day(i), minp = this.weekdaysMin(mom, ""), 
        shortp = this.weekdaysShort(mom, ""), longp = this.weekdays(mom, ""), minPieces.push(minp), 
        shortPieces.push(shortp), longPieces.push(longp), mixedPieces.push(minp), mixedPieces.push(shortp), 
        mixedPieces.push(longp);
        for (minPieces.sort(cmpLenRev), shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), 
        mixedPieces.sort(cmpLenRev), i = 0; i < 7; i++) shortPieces[i] = regexEscape(shortPieces[i]), 
        longPieces[i] = regexEscape(longPieces[i]), mixedPieces[i] = regexEscape(mixedPieces[i]);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, 
        this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), 
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i"), 
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    function localeIsPM(input) {
        return "p" === (input + "").toLowerCase().charAt(0);
    }
    function localeMeridiem(hours, minutes, isLower) {
        return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM";
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        for (var j, next, locale, split, i = 0; i < names.length; ) {
            for (split = normalizeLocale(names[i]).split("-"), j = split.length, next = normalizeLocale(names[i + 1]), 
            next = next ? next.split("-") : null; j > 0; ) {
                if (locale = loadLocale(split.slice(0, j).join("-"))) return locale;
                if (next && next.length >= j && compareArrays(split, next, !0) >= j - 1) break;
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && "undefined" != typeof module && module && module.exports) try {
            oldLocale = globalLocale._abbr, require("./locale/" + name), getSetGlobalLocale(oldLocale);
        } catch (e) {}
        return locales[name];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        return key && (data = isUndefined(values) ? getLocale(key) : defineLocale(key, values)) && (globalLocale = data), 
        globalLocale._abbr;
    }
    function defineLocale(name, config) {
        if (null !== config) {
            var parentConfig = baseConfig;
            if (config.abbr = name, null != locales[name]) deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), 
            parentConfig = locales[name]._config; else if (null != config.parentLocale) {
                if (null == locales[config.parentLocale]) return localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []), 
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                }), null;
                parentConfig = locales[config.parentLocale]._config;
            }
            return locales[name] = new Locale(mergeConfigs(parentConfig, config)), localeFamilies[name] && localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
            }), getSetGlobalLocale(name), locales[name];
        }
        return delete locales[name], null;
    }
    function updateLocale(name, config) {
        if (null != config) {
            var locale, parentConfig = baseConfig;
            null != locales[name] && (parentConfig = locales[name]._config), config = mergeConfigs(parentConfig, config), 
            locale = new Locale(config), locale.parentLocale = locales[name], locales[name] = locale, 
            getSetGlobalLocale(name);
        } else null != locales[name] && (null != locales[name].parentLocale ? locales[name] = locales[name].parentLocale : null != locales[name] && delete locales[name]);
        return locales[name];
    }
    function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key) return globalLocale;
        if (!isArray(key)) {
            if (locale = loadLocale(key)) return locale;
            key = [ key ];
        }
        return chooseLocale(key);
    }
    function listLocales() {
        return keys$1(locales);
    }
    function checkOverflow(m) {
        var overflow, a = m._a;
        return a && -2 === getParsingFlags(m).overflow && (overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || 24 === a[HOUR] && (0 !== a[MINUTE] || 0 !== a[SECOND] || 0 !== a[MILLISECOND]) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1, 
        getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE) && (overflow = DATE), 
        getParsingFlags(m)._overflowWeeks && -1 === overflow && (overflow = WEEK), getParsingFlags(m)._overflowWeekday && -1 === overflow && (overflow = WEEKDAY), 
        getParsingFlags(m).overflow = overflow), m;
    }
    function configFromISO(config) {
        var i, l, allowTime, dateFormat, timeFormat, tzFormat, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string);
        if (match) {
            for (getParsingFlags(config).iso = !0, i = 0, l = isoDates.length; i < l; i++) if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0], allowTime = !1 !== isoDates[i][2];
                break;
            }
            if (null == dateFormat) return void (config._isValid = !1);
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) if (isoTimes[i][1].exec(match[3])) {
                    timeFormat = (match[2] || " ") + isoTimes[i][0];
                    break;
                }
                if (null == timeFormat) return void (config._isValid = !1);
            }
            if (!allowTime && null != timeFormat) return void (config._isValid = !1);
            if (match[4]) {
                if (!tzRegex.exec(match[4])) return void (config._isValid = !1);
                tzFormat = "Z";
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || ""), configFromStringAndFormat(config);
        } else config._isValid = !1;
    }
    function configFromRFC2822(config) {
        var string, match, dayFormat, dateFormat, timeFormat, tzFormat, timezone, timezoneIndex, timezones = {
            " GMT": " +0000",
            " EDT": " -0400",
            " EST": " -0500",
            " CDT": " -0500",
            " CST": " -0600",
            " MDT": " -0600",
            " MST": " -0700",
            " PDT": " -0700",
            " PST": " -0800"
        };
        if (string = config._i.replace(/\([^\)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s|\s$/g, ""), 
        match = basicRfcRegex.exec(string)) {
            if (dayFormat = match[1] ? "ddd" + (5 === match[1].length ? ", " : " ") : "", dateFormat = "D MMM " + (match[2].length > 10 ? "YYYY " : "YY "), 
            timeFormat = "HH:mm" + (match[4] ? ":ss" : ""), match[1]) {
                var momentDate = new Date(match[2]), momentDay = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ][momentDate.getDay()];
                if (match[1].substr(0, 3) !== momentDay) return getParsingFlags(config).weekdayMismatch = !0, 
                void (config._isValid = !1);
            }
            switch (match[5].length) {
              case 2:
                0 === timezoneIndex ? timezone = " +0000" : (timezoneIndex = "YXWVUTSRQPONZABCDEFGHIKLM".indexOf(match[5][1].toUpperCase()) - 12, 
                timezone = (timezoneIndex < 0 ? " -" : " +") + ("" + timezoneIndex).replace(/^-?/, "0").match(/..$/)[0] + "00");
                break;

              case 4:
                timezone = timezones[match[5]];
                break;

              default:
                timezone = timezones[" GMT"];
            }
            match[5] = timezone, config._i = match.splice(1).join(""), tzFormat = " ZZ", config._f = dayFormat + dateFormat + timeFormat + tzFormat, 
            configFromStringAndFormat(config), getParsingFlags(config).rfc2822 = !0;
        } else config._isValid = !1;
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        return null !== matched ? void (config._d = new Date(+matched[1])) : (configFromISO(config), 
        void (!1 === config._isValid && (delete config._isValid, configFromRFC2822(config), 
        !1 === config._isValid && (delete config._isValid, hooks.createFromInputFallback(config)))));
    }
    function defaults(a, b, c) {
        return null != a ? a : null != b ? b : c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        return config._useUTC ? [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ] : [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
    }
    function configFromArray(config) {
        var i, date, currentDate, yearToUse, input = [];
        if (!config._d) {
            for (currentDate = currentDateArray(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && dayOfYearFromWeekInfo(config), 
            null != config._dayOfYear && (yearToUse = defaults(config._a[YEAR], currentDate[YEAR]), 
            (config._dayOfYear > daysInYear(yearToUse) || 0 === config._dayOfYear) && (getParsingFlags(config)._overflowDayOfYear = !0), 
            date = createUTCDate(yearToUse, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), 
            config._a[DATE] = date.getUTCDate()), i = 0; i < 3 && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
            for (;i < 7; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
            24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, 
            config._a[HOUR] = 0), config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input), 
            null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), 
            config._nextDay && (config._a[HOUR] = 24);
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
        if (w = config._w, null != w.GG || null != w.W || null != w.E) dow = 1, doy = 4, 
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year), 
        week = defaults(w.W, 1), ((weekday = defaults(w.E, 1)) < 1 || weekday > 7) && (weekdayOverflow = !0); else {
            dow = config._locale._week.dow, doy = config._locale._week.doy;
            var curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year), week = defaults(w.w, curWeek.week), 
            null != w.d ? ((weekday = w.d) < 0 || weekday > 6) && (weekdayOverflow = !0) : null != w.e ? (weekday = w.e + dow, 
            (w.e < 0 || w.e > 6) && (weekdayOverflow = !0)) : weekday = dow;
        }
        week < 1 || week > weeksInYear(weekYear, dow, doy) ? getParsingFlags(config)._overflowWeeks = !0 : null != weekdayOverflow ? getParsingFlags(config)._overflowWeekday = !0 : (temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), 
        config._a[YEAR] = temp.year, config._dayOfYear = temp.dayOfYear);
    }
    function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) return void configFromISO(config);
        if (config._f === hooks.RFC_2822) return void configFromRFC2822(config);
        config._a = [], getParsingFlags(config).empty = !0;
        var i, parsedInput, tokens, token, skipped, string = "" + config._i, stringLength = string.length, totalParsedInputLength = 0;
        for (tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], 
        i = 0; i < tokens.length; i++) token = tokens[i], parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0], 
        parsedInput && (skipped = string.substr(0, string.indexOf(parsedInput)), skipped.length > 0 && getParsingFlags(config).unusedInput.push(skipped), 
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), 
        formatTokenFunctions[token] ? (parsedInput ? getParsingFlags(config).empty = !1 : getParsingFlags(config).unusedTokens.push(token), 
        addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && getParsingFlags(config).unusedTokens.push(token);
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength, string.length > 0 && getParsingFlags(config).unusedInput.push(string), 
        config._a[HOUR] <= 12 && !0 === getParsingFlags(config).bigHour && config._a[HOUR] > 0 && (getParsingFlags(config).bigHour = void 0), 
        getParsingFlags(config).parsedDateParts = config._a.slice(0), getParsingFlags(config).meridiem = config._meridiem, 
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem), 
        configFromArray(config), checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        return null == meridiem ? hour : null != locale.meridiemHour ? locale.meridiemHour(hour, meridiem) : null != locale.isPM ? (isPm = locale.isPM(meridiem), 
        isPm && hour < 12 && (hour += 12), isPm || 12 !== hour || (hour = 0), hour) : hour;
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (0 === config._f.length) return getParsingFlags(config).invalidFormat = !0, void (config._d = new Date(NaN));
        for (i = 0; i < config._f.length; i++) currentScore = 0, tempConfig = copyConfig({}, config), 
        null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._f = config._f[i], 
        configFromStringAndFormat(tempConfig), isValid(tempConfig) && (currentScore += getParsingFlags(tempConfig).charsLeftOver, 
        currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length, getParsingFlags(tempConfig).score = currentScore, 
        (null == scoreToBeat || currentScore < scoreToBeat) && (scoreToBeat = currentScore, 
        bestMoment = tempConfig));
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (!config._d) {
            var i = normalizeObjectUnits(config._i);
            config._a = map([ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ], function(obj) {
                return obj && parseInt(obj, 10);
            }), configFromArray(config);
        }
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        return res._nextDay && (res.add(1, "d"), res._nextDay = void 0), res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        return config._locale = config._locale || getLocale(config._l), null === input || void 0 === format && "" === input ? createInvalid({
            nullInput: !0
        }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), 
        isMoment(input) ? new Moment(checkOverflow(input)) : (isDate(input) ? config._d = input : isArray(format) ? configFromStringAndArray(config) : format ? configFromStringAndFormat(config) : configFromInput(config), 
        isValid(config) || (config._d = null), config));
    }
    function configFromInput(config) {
        var input = config._i;
        isUndefined(input) ? config._d = new Date(hooks.now()) : isDate(input) ? config._d = new Date(input.valueOf()) : "string" == typeof input ? configFromString(config) : isArray(input) ? (config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
        }), configFromArray(config)) : isObject(input) ? configFromObject(config) : isNumber(input) ? config._d = new Date(input) : hooks.createFromInputFallback(config);
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        return !0 !== locale && !1 !== locale || (strict = locale, locale = void 0), (isObject(input) && isObjectEmpty(input) || isArray(input) && 0 === input.length) && (input = void 0), 
        c._isAMomentObject = !0, c._useUTC = c._isUTC = isUTC, c._l = locale, c._i = input, 
        c._f = format, c._strict = strict, createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, !1);
    }
    function pickBy(fn, moments) {
        var res, i;
        if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length) return createLocal();
        for (res = moments[0], i = 1; i < moments.length; ++i) moments[i].isValid() && !moments[i][fn](res) || (res = moments[i]);
        return res;
    }
    function min() {
        return pickBy("isBefore", [].slice.call(arguments, 0));
    }
    function max() {
        return pickBy("isAfter", [].slice.call(arguments, 0));
    }
    function isDurationValid(m) {
        for (var key in m) if (-1 === ordering.indexOf(key) || null != m[key] && isNaN(m[key])) return !1;
        for (var unitHasDecimal = !1, i = 0; i < ordering.length; ++i) if (m[ordering[i]]) {
            if (unitHasDecimal) return !1;
            parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]]) && (unitHasDecimal = !0);
        }
        return !0;
    }
    function isValid$1() {
        return this._isValid;
    }
    function createInvalid$1() {
        return createDuration(NaN);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput), this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60, 
        this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, 
        this._data = {}, this._locale = getLocale(), this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        return number < 0 ? -1 * Math.round(-1 * number) : Math.round(number);
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset(), sign = "+";
            return offset < 0 && (offset = -offset, sign = "-"), sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher);
        if (null === matches) return null;
        var chunk = matches[matches.length - 1] || [], parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ], minutes = 60 * parts[1] + toInt(parts[2]);
        return 0 === minutes ? 0 : "+" === parts[0] ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        return model._isUTC ? (res = model.clone(), diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(), 
        res._d.setTime(res._d.valueOf() + diff), hooks.updateOffset(res, !1), res) : createLocal(input).local();
    }
    function getDateOffset(m) {
        return 15 * -Math.round(m._d.getTimezoneOffset() / 15);
    }
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var localAdjust, offset = this._offset || 0;
        if (!this.isValid()) return null != input ? this : NaN;
        if (null != input) {
            if ("string" == typeof input) {
                if (null === (input = offsetFromString(matchShortOffset, input))) return this;
            } else Math.abs(input) < 16 && !keepMinutes && (input *= 60);
            return !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)), this._offset = input, 
            this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addSubtract(this, createDuration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, 
            hooks.updateOffset(this, !0), this._changeInProgress = null)), this;
        }
        return this._isUTC ? offset : getDateOffset(this);
    }
    function getSetZone(input, keepLocalTime) {
        return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), 
        this) : -this.utcOffset();
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(getDateOffset(this), "m")), 
        this;
    }
    function setOffsetToParsedOffset() {
        if (null != this._tzm) this.utcOffset(this._tzm, !1, !0); else if ("string" == typeof this._i) {
            var tZone = offsetFromString(matchOffset, this._i);
            null != tZone ? this.utcOffset(tZone) : this.utcOffset(0, !0);
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        return !!this.isValid() && (input = input ? createLocal(input).utcOffset() : 0, 
        (this.utcOffset() - input) % 60 == 0);
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted;
        var c = {};
        if (copyConfig(c, this), c = prepareConfig(c), c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else this._isDSTShifted = !1;
        return this._isDSTShifted;
    }
    function isLocal() {
        return !!this.isValid() && !this._isUTC;
    }
    function isUtcOffset() {
        return !!this.isValid() && this._isUTC;
    }
    function isUtc() {
        return !!this.isValid() && this._isUTC && 0 === this._offset;
    }
    function createDuration(input, key) {
        var sign, ret, diffRes, duration = input, match = null;
        return isDuration(input) ? duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
        } : isNumber(input) ? (duration = {}, key ? duration[key] = input : duration.milliseconds = input) : (match = aspNetRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, 
        duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(absRound(1e3 * match[MILLISECOND])) * sign
        }) : (match = isoRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
        }) : null == duration ? duration = {} : "object" == typeof duration && ("from" in duration || "to" in duration) && (diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to)), 
        duration = {}, duration.ms = diffRes.milliseconds, duration.M = diffRes.months), 
        ret = new Duration(duration), isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), 
        ret;
    }
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), 
        base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), 
        res;
    }
    function momentsDifference(base, other) {
        var res;
        return base.isValid() && other.isValid() ? (other = cloneWithOffset(other, base), 
        base.isBefore(other) ? res = positiveMomentsDifference(base, other) : (res = positiveMomentsDifference(other, base), 
        res.milliseconds = -res.milliseconds, res.months = -res.months), res) : {
            milliseconds: 0,
            months: 0
        };
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), 
            tmp = val, val = period, period = tmp), val = "string" == typeof val ? +val : val, 
            dur = createDuration(val, period), addSubtract(this, dur, direction), this;
        };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
        mom.isValid() && (updateOffset = null == updateOffset || updateOffset, milliseconds && mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding), 
        days && set$1(mom, "Date", get(mom, "Date") + days * isAdding), months && setMonth(mom, get(mom, "Month") + months * isAdding), 
        updateOffset && hooks.updateOffset(mom, days || months));
    }
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, "days", !0);
        return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(isUndefined(units) ? "millisecond" : units), 
        "millisecond" === units ? this.valueOf() > localInput.valueOf() : localInput.valueOf() < this.clone().startOf(units).valueOf());
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(isUndefined(units) ? "millisecond" : units), 
        "millisecond" === units ? this.valueOf() < localInput.valueOf() : this.clone().endOf(units).valueOf() < localInput.valueOf());
    }
    function isBetween(from, to, units, inclusivity) {
        return inclusivity = inclusivity || "()", ("(" === inclusivity[0] ? this.isAfter(from, units) : !this.isBefore(from, units)) && (")" === inclusivity[1] ? this.isBefore(to, units) : !this.isAfter(to, units));
    }
    function isSame(input, units) {
        var inputMs, localInput = isMoment(input) ? input : createLocal(input);
        return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(units || "millisecond"), 
        "millisecond" === units ? this.valueOf() === localInput.valueOf() : (inputMs = localInput.valueOf(), 
        this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf()));
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
        var that, zoneDelta, delta, output;
        return this.isValid() ? (that = cloneWithOffset(input, this), that.isValid() ? (zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset()), 
        units = normalizeUnits(units), "year" === units || "month" === units || "quarter" === units ? (output = monthDiff(this, that), 
        "quarter" === units ? output /= 3 : "year" === units && (output /= 12)) : (delta = this - that, 
        output = "second" === units ? delta / 1e3 : "minute" === units ? delta / 6e4 : "hour" === units ? delta / 36e5 : "day" === units ? (delta - zoneDelta) / 864e5 : "week" === units ? (delta - zoneDelta) / 6048e5 : delta), 
        asFloat ? output : absFloor(output)) : NaN) : NaN;
    }
    function monthDiff(a, b) {
        var anchor2, adjust, wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months");
        return b - anchor < 0 ? (anchor2 = a.clone().add(wholeMonthDiff - 1, "months"), 
        adjust = (b - anchor) / (anchor - anchor2)) : (anchor2 = a.clone().add(wholeMonthDiff + 1, "months"), 
        adjust = (b - anchor) / (anchor2 - anchor)), -(wholeMonthDiff + adjust) || 0;
    }
    function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString() {
        if (!this.isValid()) return null;
        var m = this.clone().utc();
        return m.year() < 0 || m.year() > 9999 ? formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : isFunction(Date.prototype.toISOString) ? this.toDate().toISOString() : formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
    }
    function inspect() {
        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
        var func = "moment", zone = "";
        this.isLocal() || (func = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", 
        zone = "Z");
        var prefix = "[" + func + '("]', year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", suffix = zone + '[")]';
        return this.format(prefix + year + "-MM-DD[T]HH:mm:ss.SSS" + suffix);
    }
    function format(inputString) {
        inputString || (inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
            to: this,
            from: time
        }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }
    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
            from: this,
            to: time
        }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }
    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        return void 0 === key ? this._locale._abbr : (newLocaleData = getLocale(key), null != newLocaleData && (this._locale = newLocaleData), 
        this);
    }
    function localeData() {
        return this._locale;
    }
    function startOf(units) {
        switch (units = normalizeUnits(units)) {
          case "year":
            this.month(0);

          case "quarter":
          case "month":
            this.date(1);

          case "week":
          case "isoWeek":
          case "day":
          case "date":
            this.hours(0);

          case "hour":
            this.minutes(0);

          case "minute":
            this.seconds(0);

          case "second":
            this.milliseconds(0);
        }
        return "week" === units && this.weekday(0), "isoWeek" === units && this.isoWeekday(1), 
        "quarter" === units && this.month(3 * Math.floor(this.month() / 3)), this;
    }
    function endOf(units) {
        return units = normalizeUnits(units), void 0 === units || "millisecond" === units ? this : ("date" === units && (units = "day"), 
        this.startOf(units).add(1, "isoWeek" === units ? "week" : units).subtract(1, "ms"));
    }
    function valueOf() {
        return this._d.valueOf() - 6e4 * (this._offset || 0);
    }
    function unix() {
        return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
        return isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        return null == input ? weekOfYear(this, dow, doy).year : (weeksTarget = weeksInYear(input, dow, doy), 
        week > weeksTarget && (week = weeksTarget), setWeekAll.call(this, input, week, weekday, dow, doy));
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), 
        this;
    }
    function getSetQuarter(input) {
        return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3);
    }
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return null == input ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(1e3 * ("0." + input));
    }
    function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }
    function createUnix(input) {
        return createLocal(1e3 * input);
    }
    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    function get$1(format, index, field, setter) {
        var locale = getLocale(), utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format) && (index = format, format = void 0), format = format || "", 
        null != index) return get$1(format, index, field, "month");
        var i, out = [];
        for (i = 0; i < 12; i++) out[i] = get$1(format, i, field, "month");
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        "boolean" == typeof localeSorted ? (isNumber(format) && (index = format, format = void 0), 
        format = format || "") : (format = localeSorted, index = format, localeSorted = !1, 
        isNumber(format) && (index = format, format = void 0), format = format || "");
        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0;
        if (null != index) return get$1(format, (index + shift) % 7, field, "day");
        var i, out = [];
        for (i = 0; i < 7; i++) out[i] = get$1(format, (i + shift) % 7, field, "day");
        return out;
    }
    function listMonths(format, index) {
        return listMonthsImpl(format, index, "months");
    }
    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
    }
    function abs() {
        var data = this._data;
        return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), 
        this._months = mathAbs(this._months), data.milliseconds = mathAbs(data.milliseconds), 
        data.seconds = mathAbs(data.seconds), data.minutes = mathAbs(data.minutes), data.hours = mathAbs(data.hours), 
        data.months = mathAbs(data.months), data.years = mathAbs(data.years), this;
    }
    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        return duration._milliseconds += direction * other._milliseconds, duration._days += direction * other._days, 
        duration._months += direction * other._months, duration._bubble();
    }
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
        return number < 0 ? Math.floor(number) : Math.ceil(number);
    }
    function bubble() {
        var seconds, minutes, hours, years, monthsFromDays, milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data;
        return milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0 || (milliseconds += 864e5 * absCeil(monthsToDays(months) + days), 
        days = 0, months = 0), data.milliseconds = milliseconds % 1e3, seconds = absFloor(milliseconds / 1e3), 
        data.seconds = seconds % 60, minutes = absFloor(seconds / 60), data.minutes = minutes % 60, 
        hours = absFloor(minutes / 60), data.hours = hours % 24, days += absFloor(hours / 24), 
        monthsFromDays = absFloor(daysToMonths(days)), months += monthsFromDays, days -= absCeil(monthsToDays(monthsFromDays)), 
        years = absFloor(months / 12), months %= 12, data.days = days, data.months = months, 
        data.years = years, this;
    }
    function daysToMonths(days) {
        return 4800 * days / 146097;
    }
    function monthsToDays(months) {
        return 146097 * months / 4800;
    }
    function as(units) {
        if (!this.isValid()) return NaN;
        var days, months, milliseconds = this._milliseconds;
        if ("month" === (units = normalizeUnits(units)) || "year" === units) return days = this._days + milliseconds / 864e5, 
        months = this._months + daysToMonths(days), "month" === units ? months : months / 12;
        switch (days = this._days + Math.round(monthsToDays(this._months)), units) {
          case "week":
            return days / 7 + milliseconds / 6048e5;

          case "day":
            return days + milliseconds / 864e5;

          case "hour":
            return 24 * days + milliseconds / 36e5;

          case "minute":
            return 1440 * days + milliseconds / 6e4;

          case "second":
            return 86400 * days + milliseconds / 1e3;

          case "millisecond":
            return Math.floor(864e5 * days) + milliseconds;

          default:
            throw new Error("Unknown unit " + units);
        }
    }
    function valueOf$1() {
        return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12) : NaN;
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    function get$2(units) {
        return units = normalizeUnits(units), this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
        return function() {
            return this.isValid() ? this._data[name] : NaN;
        };
    }
    function weeks() {
        return absFloor(this.days() / 7);
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), a = seconds <= thresholds.ss && [ "s", seconds ] || seconds < thresholds.s && [ "ss", seconds ] || minutes <= 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours <= 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days <= 1 && [ "d" ] || days < thresholds.d && [ "dd", days ] || months <= 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years <= 1 && [ "y" ] || [ "yy", years ];
        return a[2] = withoutSuffix, a[3] = +posNegDuration > 0, a[4] = locale, substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
        return void 0 === roundingFunction ? round : "function" == typeof roundingFunction && (round = roundingFunction, 
        !0);
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
        return void 0 !== thresholds[threshold] && (void 0 === limit ? thresholds[threshold] : (thresholds[threshold] = limit, 
        "s" === threshold && (thresholds.ss = limit - 1), !0));
    }
    function humanize(withSuffix) {
        if (!this.isValid()) return this.localeData().invalidDate();
        var locale = this.localeData(), output = relativeTime$1(this, !withSuffix, locale);
        return withSuffix && (output = locale.pastFuture(+this, output)), locale.postformat(output);
    }
    function toISOString$1() {
        if (!this.isValid()) return this.localeData().invalidDate();
        var minutes, hours, years, seconds = abs$1(this._milliseconds) / 1e3, days = abs$1(this._days), months = abs$1(this._months);
        minutes = absFloor(seconds / 60), hours = absFloor(minutes / 60), seconds %= 60, 
        minutes %= 60, years = absFloor(months / 12), months %= 12;
        var Y = years, M = months, D = days, h = hours, m = minutes, s = seconds, total = this.asSeconds();
        return total ? (total < 0 ? "-" : "") + "P" + (Y ? Y + "Y" : "") + (M ? M + "M" : "") + (D ? D + "D" : "") + (h || m || s ? "T" : "") + (h ? h + "H" : "") + (m ? m + "M" : "") + (s ? s + "S" : "") : "P0D";
    }
    function plural(word, num) {
        var forms = word.split("_");
        return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            mm: withoutSuffix ? "__" : "__",
            hh: withoutSuffix ? "__" : "__",
            dd: "__",
            MM: "__",
            yy: "__"
        };
        return "m" === key ? withoutSuffix ? "" : "" : "h" === key ? withoutSuffix ? "" : "" : number + " " + plural(format[key], +number);
    }
    function relativeTimeWithMutation(number, withoutSuffix, key) {
        return number + " " + mutation({
            mm: "munutenn",
            MM: "miz",
            dd: "devezh"
        }[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
          case 1:
          case 3:
          case 4:
          case 5:
          case 9:
            return number + " bloaz";

          default:
            return number + " vloaz";
        }
    }
    function lastNumber(number) {
        return number > 9 ? lastNumber(number % 10) : number;
    }
    function mutation(text, number) {
        return 2 === number ? softMutation(text) : text;
    }
    function softMutation(text) {
        var mutationTable = {
            m: "v",
            b: "v",
            d: "z"
        };
        return void 0 === mutationTable[text.charAt(0)] ? text : mutationTable[text.charAt(0)] + text.substring(1);
    }
    function translate(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "m":
            return withoutSuffix ? "jedna minuta" : "jedne minute";

          case "mm":
            return result += 1 === number ? "minuta" : 2 === number || 3 === number || 4 === number ? "minute" : "minuta";

          case "h":
            return withoutSuffix ? "jedan sat" : "jednog sata";

          case "hh":
            return result += 1 === number ? "sat" : 2 === number || 3 === number || 4 === number ? "sata" : "sati";

          case "dd":
            return result += 1 === number ? "dan" : "dana";

          case "MM":
            return result += 1 === number ? "mjesec" : 2 === number || 3 === number || 4 === number ? "mjeseca" : "mjeseci";

          case "yy":
            return result += 1 === number ? "godina" : 2 === number || 3 === number || 4 === number ? "godine" : "godina";
        }
    }
    function plural$1(n) {
        return n > 1 && n < 5 && 1 != ~~(n / 10);
    }
    function translate$1(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "pr sekund" : "pr sekundami";

          case "m":
            return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";

          case "mm":
            return withoutSuffix || isFuture ? result + (plural$1(number) ? "minuty" : "minut") : result + "minutami";

          case "h":
            return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

          case "hh":
            return withoutSuffix || isFuture ? result + (plural$1(number) ? "hodiny" : "hodin") : result + "hodinami";

          case "d":
            return withoutSuffix || isFuture ? "den" : "dnem";

          case "dd":
            return withoutSuffix || isFuture ? result + (plural$1(number) ? "dny" : "dn") : result + "dny";

          case "M":
            return withoutSuffix || isFuture ? "msc" : "mscem";

          case "MM":
            return withoutSuffix || isFuture ? result + (plural$1(number) ? "msce" : "msc") : result + "msci";

          case "y":
            return withoutSuffix || isFuture ? "rok" : "rokem";

          case "yy":
            return withoutSuffix || isFuture ? result + (plural$1(number) ? "roky" : "let") : result + "lety";
        }
    }
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eine Minute", "einer Minute" ],
            h: [ "eine Stunde", "einer Stunde" ],
            d: [ "ein Tag", "einem Tag" ],
            dd: [ number + " Tage", number + " Tagen" ],
            M: [ "ein Monat", "einem Monat" ],
            MM: [ number + " Monate", number + " Monaten" ],
            y: [ "ein Jahr", "einem Jahr" ],
            yy: [ number + " Jahre", number + " Jahren" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eine Minute", "einer Minute" ],
            h: [ "eine Stunde", "einer Stunde" ],
            d: [ "ein Tag", "einem Tag" ],
            dd: [ number + " Tage", number + " Tagen" ],
            M: [ "ein Monat", "einem Monat" ],
            MM: [ number + " Monate", number + " Monaten" ],
            y: [ "ein Jahr", "einem Jahr" ],
            yy: [ number + " Jahre", number + " Jahren" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eine Minute", "einer Minute" ],
            h: [ "eine Stunde", "einer Stunde" ],
            d: [ "ein Tag", "einem Tag" ],
            dd: [ number + " Tage", number + " Tagen" ],
            M: [ "ein Monat", "einem Monat" ],
            MM: [ number + " Monate", number + " Monaten" ],
            y: [ "ein Jahr", "einem Jahr" ],
            yy: [ number + " Jahre", number + " Jahren" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ "mne sekundi", "mni sekund", "paar sekundit" ],
            m: [ "he minuti", "ks minut" ],
            mm: [ number + " minuti", number + " minutit" ],
            h: [ "he tunni", "tund aega", "ks tund" ],
            hh: [ number + " tunni", number + " tundi" ],
            d: [ "he peva", "ks pev" ],
            M: [ "kuu aja", "kuu aega", "ks kuu" ],
            MM: [ number + " kuu", number + " kuud" ],
            y: [ "he aasta", "aasta", "ks aasta" ],
            yy: [ number + " aasta", number + " aastat" ]
        };
        return withoutSuffix ? format[key][2] ? format[key][2] : format[key][1] : isFuture ? format[key][0] : format[key][1];
    }
    function translate$2(number, withoutSuffix, key, isFuture) {
        var result = "";
        switch (key) {
          case "s":
            return isFuture ? "muutaman sekunnin" : "muutama sekunti";

          case "m":
            return isFuture ? "minuutin" : "minuutti";

          case "mm":
            result = isFuture ? "minuutin" : "minuuttia";
            break;

          case "h":
            return isFuture ? "tunnin" : "tunti";

          case "hh":
            result = isFuture ? "tunnin" : "tuntia";
            break;

          case "d":
            return isFuture ? "pivn" : "piv";

          case "dd":
            result = isFuture ? "pivn" : "piv";
            break;

          case "M":
            return isFuture ? "kuukauden" : "kuukausi";

          case "MM":
            result = isFuture ? "kuukauden" : "kuukautta";
            break;

          case "y":
            return isFuture ? "vuoden" : "vuosi";

          case "yy":
            result = isFuture ? "vuoden" : "vuotta";
        }
        return result = verbalNumber(number, isFuture) + " " + result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
    }
    function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ "thodde secondanim", "thodde second" ],
            m: [ "eka mintan", "ek minute" ],
            mm: [ number + " mintanim", number + " mintam" ],
            h: [ "eka horan", "ek hor" ],
            hh: [ number + " horanim", number + " hor" ],
            d: [ "eka disan", "ek dis" ],
            dd: [ number + " disanim", number + " dis" ],
            M: [ "eka mhoinean", "ek mhoino" ],
            MM: [ number + " mhoineanim", number + " mhoine" ],
            y: [ "eka vorsan", "ek voros" ],
            yy: [ number + " vorsanim", number + " vorsam" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function translate$3(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "m":
            return withoutSuffix ? "jedna minuta" : "jedne minute";

          case "mm":
            return result += 1 === number ? "minuta" : 2 === number || 3 === number || 4 === number ? "minute" : "minuta";

          case "h":
            return withoutSuffix ? "jedan sat" : "jednog sata";

          case "hh":
            return result += 1 === number ? "sat" : 2 === number || 3 === number || 4 === number ? "sata" : "sati";

          case "dd":
            return result += 1 === number ? "dan" : "dana";

          case "MM":
            return result += 1 === number ? "mjesec" : 2 === number || 3 === number || 4 === number ? "mjeseca" : "mjeseci";

          case "yy":
            return result += 1 === number ? "godina" : 2 === number || 3 === number || 4 === number ? "godine" : "godina";
        }
    }
    function translate$4(number, withoutSuffix, key, isFuture) {
        var num = number;
        switch (key) {
          case "s":
            return isFuture || withoutSuffix ? "nhny msodperc" : "nhny msodperce";

          case "m":
            return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");

          case "mm":
            return num + (isFuture || withoutSuffix ? " perc" : " perce");

          case "h":
            return "egy" + (isFuture || withoutSuffix ? " ra" : " rja");

          case "hh":
            return num + (isFuture || withoutSuffix ? " ra" : " rja");

          case "d":
            return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");

          case "dd":
            return num + (isFuture || withoutSuffix ? " nap" : " napja");

          case "M":
            return "egy" + (isFuture || withoutSuffix ? " hnap" : " hnapja");

          case "MM":
            return num + (isFuture || withoutSuffix ? " hnap" : " hnapja");

          case "y":
            return "egy" + (isFuture || withoutSuffix ? " v" : " ve");

          case "yy":
            return num + (isFuture || withoutSuffix ? " v" : " ve");
        }
        return "";
    }
    function week(isFuture) {
        return (isFuture ? "" : "[mlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
    }
    function plural$2(n) {
        return n % 100 == 11 || n % 10 != 1;
    }
    function translate$5(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "nokkrar sekndur" : "nokkrum sekndum";

          case "m":
            return withoutSuffix ? "mnta" : "mntu";

          case "mm":
            return plural$2(number) ? result + (withoutSuffix || isFuture ? "mntur" : "mntum") : withoutSuffix ? result + "mnta" : result + "mntu";

          case "hh":
            return plural$2(number) ? result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum") : result + "klukkustund";

          case "d":
            return withoutSuffix ? "dagur" : isFuture ? "dag" : "degi";

          case "dd":
            return plural$2(number) ? withoutSuffix ? result + "dagar" : result + (isFuture ? "daga" : "dgum") : withoutSuffix ? result + "dagur" : result + (isFuture ? "dag" : "degi");

          case "M":
            return withoutSuffix ? "mnuur" : isFuture ? "mnu" : "mnui";

          case "MM":
            return plural$2(number) ? withoutSuffix ? result + "mnuir" : result + (isFuture ? "mnui" : "mnuum") : withoutSuffix ? result + "mnuur" : result + (isFuture ? "mnu" : "mnui");

          case "y":
            return withoutSuffix || isFuture ? "r" : "ri";

          case "yy":
            return plural$2(number) ? result + (withoutSuffix || isFuture ? "r" : "rum") : result + (withoutSuffix || isFuture ? "r" : "ri");
        }
    }
    function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
        var format = {
            m: [ "eng Minutt", "enger Minutt" ],
            h: [ "eng Stonn", "enger Stonn" ],
            d: [ "een Dag", "engem Dag" ],
            M: [ "ee Mount", "engem Mount" ],
            y: [ "ee Joer", "engem Joer" ]
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        return eifelerRegelAppliesToNumber(string.substr(0, string.indexOf(" "))) ? "a " + string : "an " + string;
    }
    function processPastTime(string) {
        return eifelerRegelAppliesToNumber(string.substr(0, string.indexOf(" "))) ? "viru " + string : "virun " + string;
    }
    function eifelerRegelAppliesToNumber(number) {
        if (number = parseInt(number, 10), isNaN(number)) return !1;
        if (number < 0) return !0;
        if (number < 10) return 4 <= number && number <= 7;
        if (number < 100) {
            var lastDigit = number % 10, firstDigit = number / 10;
            return eifelerRegelAppliesToNumber(0 === lastDigit ? firstDigit : lastDigit);
        }
        if (number < 1e4) {
            for (;number >= 10; ) number /= 10;
            return eifelerRegelAppliesToNumber(number);
        }
        return number /= 1e3, eifelerRegelAppliesToNumber(number);
    }
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? "kelios sekunds" : isFuture ? "keli sekundi" : "kelias sekundes";
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
    }
    function special(number) {
        return number % 10 == 0 || number > 10 && number < 20;
    }
    function forms(key) {
        return units[key].split("_");
    }
    function translate$6(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        return 1 === number ? result + translateSingular(number, withoutSuffix, key[0], isFuture) : withoutSuffix ? result + (special(number) ? forms(key)[1] : forms(key)[0]) : isFuture ? result + forms(key)[1] : result + (special(number) ? forms(key)[1] : forms(key)[2]);
    }
    function format$1(forms, number, withoutSuffix) {
        return withoutSuffix ? number % 10 == 1 && number % 100 != 11 ? forms[2] : forms[3] : number % 10 == 1 && number % 100 != 11 ? forms[0] : forms[1];
    }
    function relativeTimeWithPlural$1(number, withoutSuffix, key) {
        return number + " " + format$1(units$1[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format$1(units$1[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? "daas sekundes" : "dam sekundm";
    }
    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
        var output = "";
        if (withoutSuffix) switch (string) {
          case "s":
            output = " ";
            break;

          case "m":
            output = " ";
            break;

          case "mm":
            output = "%d ";
            break;

          case "h":
            output = " ";
            break;

          case "hh":
            output = "%d ";
            break;

          case "d":
            output = " ";
            break;

          case "dd":
            output = "%d ";
            break;

          case "M":
            output = " ";
            break;

          case "MM":
            output = "%d ";
            break;

          case "y":
            output = " ";
            break;

          case "yy":
            output = "%d ";
        } else switch (string) {
          case "s":
            output = " ";
            break;

          case "m":
            output = " ";
            break;

          case "mm":
            output = "%d ";
            break;

          case "h":
            output = " ";
            break;

          case "hh":
            output = "%d ";
            break;

          case "d":
            output = " ";
            break;

          case "dd":
            output = "%d ";
            break;

          case "M":
            output = " ";
            break;

          case "MM":
            output = "%d ";
            break;

          case "y":
            output = " ";
            break;

          case "yy":
            output = "%d ";
        }
        return output.replace(/%d/i, number);
    }
    function plural$3(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 != 1;
    }
    function translate$7(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
          case "m":
            return withoutSuffix ? "minuta" : "minut";

          case "mm":
            return result + (plural$3(number) ? "minuty" : "minut");

          case "h":
            return withoutSuffix ? "godzina" : "godzin";

          case "hh":
            return result + (plural$3(number) ? "godziny" : "godzin");

          case "MM":
            return result + (plural$3(number) ? "miesice" : "miesicy");

          case "yy":
            return result + (plural$3(number) ? "lata" : "lat");
        }
    }
    function relativeTimeWithPlural$2(number, withoutSuffix, key) {
        var format = {
            mm: "minute",
            hh: "ore",
            dd: "zile",
            MM: "luni",
            yy: "ani"
        }, separator = " ";
        return (number % 100 >= 20 || number >= 100 && number % 100 == 0) && (separator = " de "), 
        number + separator + format[key];
    }
    function plural$4(word, num) {
        var forms = word.split("_");
        return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural$3(number, withoutSuffix, key) {
        var format = {
            mm: withoutSuffix ? "__" : "__",
            hh: "__",
            dd: "__",
            MM: "__",
            yy: "__"
        };
        return "m" === key ? withoutSuffix ? "" : "" : number + " " + plural$4(format[key], +number);
    }
    function plural$5(n) {
        return n > 1 && n < 5;
    }
    function translate$8(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "pr seknd" : "pr sekundami";

          case "m":
            return withoutSuffix ? "minta" : isFuture ? "mintu" : "mintou";

          case "mm":
            return withoutSuffix || isFuture ? result + (plural$5(number) ? "minty" : "mint") : result + "mintami";

          case "h":
            return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

          case "hh":
            return withoutSuffix || isFuture ? result + (plural$5(number) ? "hodiny" : "hodn") : result + "hodinami";

          case "d":
            return withoutSuffix || isFuture ? "de" : "dom";

          case "dd":
            return withoutSuffix || isFuture ? result + (plural$5(number) ? "dni" : "dn") : result + "dami";

          case "M":
            return withoutSuffix || isFuture ? "mesiac" : "mesiacom";

          case "MM":
            return withoutSuffix || isFuture ? result + (plural$5(number) ? "mesiace" : "mesiacov") : result + "mesiacmi";

          case "y":
            return withoutSuffix || isFuture ? "rok" : "rokom";

          case "yy":
            return withoutSuffix || isFuture ? result + (plural$5(number) ? "roky" : "rokov") : result + "rokmi";
        }
    }
    function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
        var result = number + " ";
        switch (key) {
          case "s":
            return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";

          case "m":
            return withoutSuffix ? "ena minuta" : "eno minuto";

          case "mm":
            return result += 1 === number ? withoutSuffix ? "minuta" : "minuto" : 2 === number ? withoutSuffix || isFuture ? "minuti" : "minutama" : number < 5 ? withoutSuffix || isFuture ? "minute" : "minutami" : withoutSuffix || isFuture ? "minut" : "minutami";

          case "h":
            return withoutSuffix ? "ena ura" : "eno uro";

          case "hh":
            return result += 1 === number ? withoutSuffix ? "ura" : "uro" : 2 === number ? withoutSuffix || isFuture ? "uri" : "urama" : number < 5 ? withoutSuffix || isFuture ? "ure" : "urami" : withoutSuffix || isFuture ? "ur" : "urami";

          case "d":
            return withoutSuffix || isFuture ? "en dan" : "enim dnem";

          case "dd":
            return result += 1 === number ? withoutSuffix || isFuture ? "dan" : "dnem" : 2 === number ? withoutSuffix || isFuture ? "dni" : "dnevoma" : withoutSuffix || isFuture ? "dni" : "dnevi";

          case "M":
            return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";

          case "MM":
            return result += 1 === number ? withoutSuffix || isFuture ? "mesec" : "mesecem" : 2 === number ? withoutSuffix || isFuture ? "meseca" : "mesecema" : number < 5 ? withoutSuffix || isFuture ? "mesece" : "meseci" : withoutSuffix || isFuture ? "mesecev" : "meseci";

          case "y":
            return withoutSuffix || isFuture ? "eno leto" : "enim letom";

          case "yy":
            return result += 1 === number ? withoutSuffix || isFuture ? "leto" : "letom" : 2 === number ? withoutSuffix || isFuture ? "leti" : "letoma" : number < 5 ? withoutSuffix || isFuture ? "leta" : "leti" : withoutSuffix || isFuture ? "let" : "leti";
        }
    }
    function translateFuture(output) {
        var time = output;
        return time = -1 !== output.indexOf("jaj") ? time.slice(0, -3) + "leS" : -1 !== output.indexOf("jar") ? time.slice(0, -3) + "waQ" : -1 !== output.indexOf("DIS") ? time.slice(0, -3) + "nem" : time + " pIq";
    }
    function translatePast(output) {
        var time = output;
        return time = -1 !== output.indexOf("jaj") ? time.slice(0, -3) + "Hu" : -1 !== output.indexOf("jar") ? time.slice(0, -3) + "wen" : -1 !== output.indexOf("DIS") ? time.slice(0, -3) + "ben" : time + " ret";
    }
    function translate$9(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
          case "mm":
            return numberNoun + " tup";

          case "hh":
            return numberNoun + " rep";

          case "dd":
            return numberNoun + " jaj";

          case "MM":
            return numberNoun + " jar";

          case "yy":
            return numberNoun + " DIS";
        }
    }
    function numberAsNoun(number) {
        var hundred = Math.floor(number % 1e3 / 100), ten = Math.floor(number % 100 / 10), one = number % 10, word = "";
        return hundred > 0 && (word += numbersNouns[hundred] + "vatlh"), ten > 0 && (word += ("" !== word ? " " : "") + numbersNouns[ten] + "maH"), 
        one > 0 && (word += ("" !== word ? " " : "") + numbersNouns[one]), "" === word ? "pagh" : word;
    }
    function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
        var format = {
            s: [ "viensas secunds", "'iensas secunds" ],
            m: [ "'n mut", "'iens mut" ],
            mm: [ number + " muts", number + " muts" ],
            h: [ "'n ora", "'iensa ora" ],
            hh: [ number + " oras", number + " oras" ],
            d: [ "'n ziua", "'iensa ziua" ],
            dd: [ number + " ziuas", number + " ziuas" ],
            M: [ "'n mes", "'iens mes" ],
            MM: [ number + " mesen", number + " mesen" ],
            y: [ "'n ar", "'iens ar" ],
            yy: [ number + " ars", number + " ars" ]
        };
        return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
    }
    function plural$6(word, num) {
        var forms = word.split("_");
        return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural$4(number, withoutSuffix, key) {
        var format = {
            mm: withoutSuffix ? "__" : "__",
            hh: withoutSuffix ? "__" : "__",
            dd: "__",
            MM: "__",
            yy: "__"
        };
        return "m" === key ? withoutSuffix ? "" : "" : "h" === key ? withoutSuffix ? "" : "" : number + " " + plural$6(format[key], +number);
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            nominative: "______".split("_"),
            accusative: "______".split("_"),
            genitive: "______".split("_")
        };
        return m ? weekdays[/(\[[]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:|)? ?\] ?dddd/.test(format) ? "genitive" : "nominative"][m.day()] : weekdays.nominative;
    }
    function processHoursFunction(str) {
        return function() {
            return str + "" + (11 === this.hours() ? "" : "") + "] LT";
        };
    }
    var hookCallback, some;
    some = Array.prototype.some ? Array.prototype.some : function(fun) {
        for (var t = Object(this), len = t.length >>> 0, i = 0; i < len; i++) if (i in t && fun.call(this, t[i], i, t)) return !0;
        return !1;
    };
    var some$1 = some, momentProperties = hooks.momentProperties = [], updateInProgress = !1, deprecations = {};
    hooks.suppressDeprecationWarnings = !1, hooks.deprecationHandler = null;
    var keys;
    keys = Object.keys ? Object.keys : function(obj) {
        var i, res = [];
        for (i in obj) hasOwnProp(obj, i) && res.push(i);
        return res;
    };
    var indexOf, keys$1 = keys, defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    }, defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    }, defaultDayOfMonthOrdinalParse = /\d{1,2}/, defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    }, aliases = {}, priorities = {}, formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {}, match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, regexes = {}, tokens = {}, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    indexOf = Array.prototype.indexOf ? Array.prototype.indexOf : function(o) {
        var i;
        for (i = 0; i < this.length; ++i) if (this[i] === o) return i;
        return -1;
    };
    var indexOf$1 = indexOf;
    addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    }), addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    }), addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    }), addUnitAlias("month", "M"), addUnitPriority("month", 8), addRegexToken("M", match1to2), 
    addRegexToken("MM", match1to2, match2), addRegexToken("MMM", function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    }), addRegexToken("MMMM", function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
    }), addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    }), addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        null != month ? array[MONTH] = month : getParsingFlags(config).invalidMonth = input;
    });
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? "" + y : "+" + y;
    }), addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    }), addFormatToken(0, [ "YYYY", 4 ], 0, "year"), addFormatToken(0, [ "YYYYY", 5 ], 0, "year"), 
    addFormatToken(0, [ "YYYYYY", 6, !0 ], 0, "year"), addUnitAlias("year", "y"), addUnitPriority("year", 1), 
    addRegexToken("Y", matchSigned), addRegexToken("YY", match1to2, match2), addRegexToken("YYYY", match1to4, match4), 
    addRegexToken("YYYYY", match1to6, match6), addRegexToken("YYYYYY", match1to6, match6), 
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR), addParseToken("YYYY", function(input, array) {
        array[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input);
    }), addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    }), addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
    }), hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", !0);
    addFormatToken("w", [ "ww", 2 ], "wo", "week"), addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek"), 
    addUnitAlias("week", "w"), addUnitAlias("isoWeek", "W"), addUnitPriority("week", 5), 
    addUnitPriority("isoWeek", 5), addRegexToken("w", match1to2), addRegexToken("ww", match1to2, match2), 
    addRegexToken("W", match1to2), addRegexToken("WW", match1to2, match2), addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    addFormatToken("d", 0, "do", "day"), addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    }), addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    }), addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    }), addFormatToken("e", 0, 0, "weekday"), addFormatToken("E", 0, 0, "isoWeekday"), 
    addUnitAlias("day", "d"), addUnitAlias("weekday", "e"), addUnitAlias("isoWeekday", "E"), 
    addUnitPriority("day", 11), addUnitPriority("weekday", 11), addUnitPriority("isoWeekday", 11), 
    addRegexToken("d", match1to2), addRegexToken("e", match1to2), addRegexToken("E", match1to2), 
    addRegexToken("dd", function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    }), addRegexToken("ddd", function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    }), addRegexToken("dddd", function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    }), addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        null != weekday ? week.d = weekday : getParsingFlags(config).invalidWeekday = input;
    }), addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    addFormatToken("H", [ "HH", 2 ], 0, "hour"), addFormatToken("h", [ "hh", 2 ], 0, hFormat), 
    addFormatToken("k", [ "kk", 2 ], 0, kFormat), addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    }), addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    }), addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
    }), addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    }), meridiem("a", !0), meridiem("A", !1), addUnitAlias("hour", "h"), addUnitPriority("hour", 13), 
    addRegexToken("a", matchMeridiem), addRegexToken("A", matchMeridiem), addRegexToken("H", match1to2), 
    addRegexToken("h", match1to2), addRegexToken("k", match1to2), addRegexToken("HH", match1to2, match2), 
    addRegexToken("hh", match1to2, match2), addRegexToken("kk", match1to2, match2), 
    addRegexToken("hmm", match3to4), addRegexToken("hmmss", match5to6), addRegexToken("Hmm", match3to4), 
    addRegexToken("Hmmss", match5to6), addParseToken([ "H", "HH" ], HOUR), addParseToken([ "k", "kk" ], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = 24 === kInput ? 0 : kInput;
    }), addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input), config._meridiem = input;
    }), addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input), getParsingFlags(config).bigHour = !0;
    }), addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos)), 
        getParsingFlags(config).bigHour = !0;
    }), addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
        array[SECOND] = toInt(input.substr(pos2)), getParsingFlags(config).bigHour = !0;
    }), addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos));
    }), addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
        array[SECOND] = toInt(input.substr(pos2));
    });
    var globalLocale, defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", !0), baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: "Invalid date",
        ordinal: "%d",
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
    }, locales = {}, localeFamilies = {}, extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, !1 ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, !1 ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, !1 ], [ "YYYYDDD", /\d{7}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ], aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;
    hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    }), hooks.ISO_8601 = function() {}, hooks.RFC_2822 = function() {};
    var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        return this.isValid() && other.isValid() ? other < this ? this : other : createInvalid();
    }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        return this.isValid() && other.isValid() ? other > this ? this : other : createInvalid();
    }), now = function() {
        return Date.now ? Date.now() : +new Date();
    }, ordering = [ "year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond" ];
    offset("Z", ":"), offset("ZZ", ""), addRegexToken("Z", matchShortOffset), addRegexToken("ZZ", matchShortOffset), 
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = !0, config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    hooks.updateOffset = function() {};
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/, isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
    createDuration.fn = Duration.prototype, createDuration.invalid = createInvalid$1;
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        return void 0 === key ? this.localeData() : this.locale(key);
    });
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    }), addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    }), addWeekYearFormatToken("gggg", "weekYear"), addWeekYearFormatToken("ggggg", "weekYear"), 
    addWeekYearFormatToken("GGGG", "isoWeekYear"), addWeekYearFormatToken("GGGGG", "isoWeekYear"), 
    addUnitAlias("weekYear", "gg"), addUnitAlias("isoWeekYear", "GG"), addUnitPriority("weekYear", 1), 
    addUnitPriority("isoWeekYear", 1), addRegexToken("G", matchSigned), addRegexToken("g", matchSigned), 
    addRegexToken("GG", match1to2, match2), addRegexToken("gg", match1to2, match2), 
    addRegexToken("GGGG", match1to4, match4), addRegexToken("gggg", match1to4, match4), 
    addRegexToken("GGGGG", match1to6, match6), addRegexToken("ggggg", match1to6, match6), 
    addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    }), addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    }), addFormatToken("Q", 0, "Qo", "quarter"), addUnitAlias("quarter", "Q"), addUnitPriority("quarter", 7), 
    addRegexToken("Q", match1), addParseToken("Q", function(input, array) {
        array[MONTH] = 3 * (toInt(input) - 1);
    }), addFormatToken("D", [ "DD", 2 ], "Do", "date"), addUnitAlias("date", "D"), addUnitPriority("date", 9), 
    addRegexToken("D", match1to2), addRegexToken("DD", match1to2, match2), addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    }), addParseToken([ "D", "DD" ], DATE), addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet("Date", !0);
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear"), addUnitAlias("dayOfYear", "DDD"), 
    addUnitPriority("dayOfYear", 4), addRegexToken("DDD", match1to3), addRegexToken("DDDD", match3), 
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    }), addFormatToken("m", [ "mm", 2 ], 0, "minute"), addUnitAlias("minute", "m"), 
    addUnitPriority("minute", 14), addRegexToken("m", match1to2), addRegexToken("mm", match1to2, match2), 
    addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", !1);
    addFormatToken("s", [ "ss", 2 ], 0, "second"), addUnitAlias("second", "s"), addUnitPriority("second", 15), 
    addRegexToken("s", match1to2), addRegexToken("ss", match1to2, match2), addParseToken([ "s", "ss" ], SECOND);
    var getSetSecond = makeGetSet("Seconds", !1);
    addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    }), addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    }), addFormatToken(0, [ "SSS", 3 ], 0, "millisecond"), addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return 10 * this.millisecond();
    }), addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return 100 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return 1e3 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return 1e4 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return 1e5 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return 1e6 * this.millisecond();
    }), addUnitAlias("millisecond", "ms"), addUnitPriority("millisecond", 16), addRegexToken("S", match1to3, match1), 
    addRegexToken("SS", match1to3, match2), addRegexToken("SSS", match1to3, match3);
    var token;
    for (token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);
    for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);
    var getSetMillisecond = makeGetSet("Milliseconds", !1);
    addFormatToken("z", 0, 0, "zoneAbbr"), addFormatToken("zz", 0, 0, "zoneName");
    var proto = Moment.prototype;
    proto.add = add, proto.calendar = calendar$1, proto.clone = clone, proto.diff = diff, 
    proto.endOf = endOf, proto.format = format, proto.from = from, proto.fromNow = fromNow, 
    proto.to = to, proto.toNow = toNow, proto.get = stringGet, proto.invalidAt = invalidAt, 
    proto.isAfter = isAfter, proto.isBefore = isBefore, proto.isBetween = isBetween, 
    proto.isSame = isSame, proto.isSameOrAfter = isSameOrAfter, proto.isSameOrBefore = isSameOrBefore, 
    proto.isValid = isValid$2, proto.lang = lang, proto.locale = locale, proto.localeData = localeData, 
    proto.max = prototypeMax, proto.min = prototypeMin, proto.parsingFlags = parsingFlags, 
    proto.set = stringSet, proto.startOf = startOf, proto.subtract = subtract, proto.toArray = toArray, 
    proto.toObject = toObject, proto.toDate = toDate, proto.toISOString = toISOString, 
    proto.inspect = inspect, proto.toJSON = toJSON, proto.toString = toString, proto.unix = unix, 
    proto.valueOf = valueOf, proto.creationData = creationData, proto.year = getSetYear, 
    proto.isLeapYear = getIsLeapYear, proto.weekYear = getSetWeekYear, proto.isoWeekYear = getSetISOWeekYear, 
    proto.quarter = proto.quarters = getSetQuarter, proto.month = getSetMonth, proto.daysInMonth = getDaysInMonth, 
    proto.week = proto.weeks = getSetWeek, proto.isoWeek = proto.isoWeeks = getSetISOWeek, 
    proto.weeksInYear = getWeeksInYear, proto.isoWeeksInYear = getISOWeeksInYear, proto.date = getSetDayOfMonth, 
    proto.day = proto.days = getSetDayOfWeek, proto.weekday = getSetLocaleDayOfWeek, 
    proto.isoWeekday = getSetISODayOfWeek, proto.dayOfYear = getSetDayOfYear, proto.hour = proto.hours = getSetHour, 
    proto.minute = proto.minutes = getSetMinute, proto.second = proto.seconds = getSetSecond, 
    proto.millisecond = proto.milliseconds = getSetMillisecond, proto.utcOffset = getSetOffset, 
    proto.utc = setOffsetToUTC, proto.local = setOffsetToLocal, proto.parseZone = setOffsetToParsedOffset, 
    proto.hasAlignedHourOffset = hasAlignedHourOffset, proto.isDST = isDaylightSavingTime, 
    proto.isLocal = isLocal, proto.isUtcOffset = isUtcOffset, proto.isUtc = isUtc, proto.isUTC = isUtc, 
    proto.zoneAbbr = getZoneAbbr, proto.zoneName = getZoneName, proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth), 
    proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth), 
    proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear), 
    proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone), 
    proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar, proto$1.longDateFormat = longDateFormat, proto$1.invalidDate = invalidDate, 
    proto$1.ordinal = ordinal, proto$1.preparse = preParsePostFormat, proto$1.postformat = preParsePostFormat, 
    proto$1.relativeTime = relativeTime, proto$1.pastFuture = pastFuture, proto$1.set = set, 
    proto$1.months = localeMonths, proto$1.monthsShort = localeMonthsShort, proto$1.monthsParse = localeMonthsParse, 
    proto$1.monthsRegex = monthsRegex, proto$1.monthsShortRegex = monthsShortRegex, 
    proto$1.week = localeWeek, proto$1.firstDayOfYear = localeFirstDayOfYear, proto$1.firstDayOfWeek = localeFirstDayOfWeek, 
    proto$1.weekdays = localeWeekdays, proto$1.weekdaysMin = localeWeekdaysMin, proto$1.weekdaysShort = localeWeekdaysShort, 
    proto$1.weekdaysParse = localeWeekdaysParse, proto$1.weekdaysRegex = weekdaysRegex, 
    proto$1.weekdaysShortRegex = weekdaysShortRegex, proto$1.weekdaysMinRegex = weekdaysMinRegex, 
    proto$1.isPM = localeIsPM, proto$1.meridiem = localeMeridiem, getSetGlobalLocale("en", {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
        }
    }), hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale), 
    hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
    var mathAbs = Math.abs, asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asYears = makeAs("y"), milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years"), round = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, abs$1 = Math.abs, proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1, proto$2.abs = abs, proto$2.add = add$1, proto$2.subtract = subtract$1, 
    proto$2.as = as, proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, 
    proto$2.asMinutes = asMinutes, proto$2.asHours = asHours, proto$2.asDays = asDays, 
    proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, proto$2.asYears = asYears, 
    proto$2.valueOf = valueOf$1, proto$2._bubble = bubble, proto$2.get = get$2, proto$2.milliseconds = milliseconds, 
    proto$2.seconds = seconds, proto$2.minutes = minutes, proto$2.hours = hours, proto$2.days = days, 
    proto$2.weeks = weeks, proto$2.months = months, proto$2.years = years, proto$2.humanize = humanize, 
    proto$2.toISOString = toISOString$1, proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, 
    proto$2.locale = locale, proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), 
    proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), 
    addRegexToken("x", matchSigned), addRegexToken("X", matchTimestamp), addParseToken("X", function(input, array, config) {
        config._d = new Date(1e3 * parseFloat(input, 10));
    }), addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    }), hooks.version = "2.18.1", function(callback) {
        hookCallback = callback;
    }(createLocal), hooks.fn = proto, hooks.min = min, hooks.max = max, hooks.now = now, 
    hooks.utc = createUTC, hooks.unix = createUnix, hooks.months = listMonths, hooks.isDate = isDate, 
    hooks.locale = getSetGlobalLocale, hooks.invalid = createInvalid, hooks.duration = createDuration, 
    hooks.isMoment = isMoment, hooks.weekdays = listWeekdays, hooks.parseZone = createInZone, 
    hooks.localeData = getLocale, hooks.isDuration = isDuration, hooks.monthsShort = listMonthsShort, 
    hooks.weekdaysMin = listWeekdaysMin, hooks.defineLocale = defineLocale, hooks.updateLocale = updateLocale, 
    hooks.locales = listLocales, hooks.weekdaysShort = listWeekdaysShort, hooks.normalizeUnits = normalizeUnits, 
    hooks.relativeTimeRounding = getSetRelativeTimeRounding, hooks.relativeTimeThreshold = getSetRelativeTimeThreshold, 
    hooks.calendarFormat = getCalendarFormat, hooks.prototype = proto, hooks.defineLocale("af", {
        months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
        monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
        weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
        weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
        meridiemParse: /vm|nm/i,
        isPM: function(input) {
            return /^nm$/i.test(input);
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 12 ? isLower ? "vm" : "VM" : isLower ? "nm" : "NM";
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Vandag om] LT",
            nextDay: "[Mre om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[Gister om] LT",
            lastWeek: "[Laas] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "oor %s",
            past: "%s gelede",
            s: "'n paar sekondes",
            m: "'n minuut",
            mm: "%d minute",
            h: "'n uur",
            hh: "%d ure",
            d: "'n dag",
            dd: "%d dae",
            M: "'n maand",
            MM: "%d maande",
            y: "'n jaar",
            yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("ar-dz", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 0,
            doy: 4
        }
    }), hooks.defineLocale("ar-kw", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 0,
            doy: 12
        }
    });
    var symbolMap = {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        0: "0"
    }, pluralForm = function(n) {
        return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        m: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        h: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        d: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        M: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        y: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ]
    }, pluralize = function(u) {
        return function(number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number), str = plurals[u][pluralForm(number)];
            return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number);
        };
    }, months$1 = [ "", "", "", "", "", "", "", "", "", "", "", "" ];
    hooks.defineLocale("ar-ly", {
        months: months$1,
        monthsShort: months$1,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "D/M/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: pluralize("s"),
            m: pluralize("m"),
            mm: pluralize("m"),
            h: pluralize("h"),
            hh: pluralize("h"),
            d: pluralize("d"),
            dd: pluralize("d"),
            M: pluralize("M"),
            MM: pluralize("M"),
            y: pluralize("y"),
            yy: pluralize("y")
        },
        preparse: function(string) {
            return string.replace(/\u200f/g, "").replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap[match];
            }).replace(/,/g, "");
        },
        week: {
            dow: 6,
            doy: 12
        }
    }), hooks.defineLocale("ar-ma", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    var symbolMap$1 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("ar-sa", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap[match];
            }).replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$1[match];
            }).replace(/,/g, "");
        },
        week: {
            dow: 0,
            doy: 6
        }
    }), hooks.defineLocale("ar-tn", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$2 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$1 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    }, pluralForm$1 = function(n) {
        return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals$1 = {
        s: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        m: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        h: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        d: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        M: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
        y: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ]
    }, pluralize$1 = function(u) {
        return function(number, withoutSuffix, string, isFuture) {
            var f = pluralForm$1(number), str = plurals$1[u][pluralForm$1(number)];
            return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number);
        };
    }, months$2 = [ "  ", " ", " ", " ", " ", " ", " ", " ", " ", "  ", "  ", "  " ];
    hooks.defineLocale("ar", {
        months: months$2,
        monthsShort: months$2,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "D/M/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[  ] LT",
            nextDay: "[  ] LT",
            nextWeek: "dddd [ ] LT",
            lastDay: "[  ] LT",
            lastWeek: "dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: pluralize$1("s"),
            m: pluralize$1("m"),
            mm: pluralize$1("m"),
            h: pluralize$1("h"),
            hh: pluralize$1("h"),
            d: pluralize$1("d"),
            dd: pluralize$1("d"),
            M: pluralize$1("M"),
            MM: pluralize$1("M"),
            y: pluralize$1("y"),
            yy: pluralize$1("y")
        },
        preparse: function(string) {
            return string.replace(/\u200f/g, "").replace(/[]/g, function(match) {
                return numberMap$1[match];
            }).replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$2[match];
            }).replace(/,/g, "");
        },
        week: {
            dow: 6,
            doy: 12
        }
    });
    var suffixes = {
        1: "-inci",
        5: "-inci",
        8: "-inci",
        70: "-inci",
        80: "-inci",
        2: "-nci",
        7: "-nci",
        20: "-nci",
        50: "-nci",
        3: "-nc",
        4: "-nc",
        100: "-nc",
        6: "-nc",
        9: "-uncu",
        10: "-uncu",
        30: "-uncu",
        60: "-nc",
        90: "-nc"
    };
    hooks.defineLocale("az", {
        months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
        monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
        weekdays: "Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb".split("_"),
        weekdaysShort: "Baz_BzE_Ax_r_CAx_Cm_n".split("_"),
        weekdaysMin: "Bz_BE_A__CA_C_".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[bugn saat] LT",
            nextDay: "[sabah saat] LT",
            nextWeek: "[gln hft] dddd [saat] LT",
            lastDay: "[dnn] LT",
            lastWeek: "[ken hft] dddd [saat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s sonra",
            past: "%s vvl",
            s: "birne saniyy",
            m: "bir dqiq",
            mm: "%d dqiq",
            h: "bir saat",
            hh: "%d saat",
            d: "bir gn",
            dd: "%d gn",
            M: "bir ay",
            MM: "%d ay",
            y: "bir il",
            yy: "%d il"
        },
        meridiemParse: /gec|shr|gndz|axam/,
        isPM: function(input) {
            return /^(gndz|axam)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "gec" : hour < 12 ? "shr" : hour < 17 ? "gndz" : "axam";
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
        ordinal: function(number) {
            if (0 === number) return number + "-nc";
            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("be", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: "___________".split("_"),
        weekdays: {
            format: "______".split("_"),
            standalone: "______".split("_"),
            isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
        },
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY .",
            LLL: "D MMMM YYYY ., HH:mm",
            LLLL: "dddd, D MMMM YYYY ., HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            lastDay: "[ ] LT",
            nextWeek: function() {
                return "[] dddd [] LT";
            },
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 5:
                  case 6:
                    return "[ ] dddd [] LT";

                  case 1:
                  case 2:
                  case 4:
                    return "[ ] dddd [] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: relativeTimeWithPlural,
            hh: relativeTimeWithPlural,
            d: "",
            dd: relativeTimeWithPlural,
            M: "",
            MM: relativeTimeWithPlural,
            y: "",
            yy: relativeTimeWithPlural
        },
        meridiemParse: /|||/,
        isPM: function(input) {
            return /^(|)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 12 ? "" : hour < 17 ? "" : "";
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return number % 10 != 2 && number % 10 != 3 || number % 100 == 12 || number % 100 == 13 ? number + "-" : number + "-";

              case "D":
                return number + "-";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("bg", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "D.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 6:
                    return "[ ] dddd [] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[ ] dddd [] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: " ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal: function(number) {
            var lastDigit = number % 10, last2Digits = number % 100;
            return 0 === number ? number + "-" : 0 === last2Digits ? number + "-" : last2Digits > 10 && last2Digits < 20 ? number + "-" : 1 === lastDigit ? number + "-" : 2 === lastDigit ? number + "-" : 7 === lastDigit || 8 === lastDigit ? number + "-" : number + "-";
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var symbolMap$3 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$2 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("bn", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$2[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$3[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem && hour >= 4 || "" === meridiem && hour < 5 || "" === meridiem ? hour + 12 : hour;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 10 ? "" : hour < 17 ? "" : hour < 20 ? "" : "";
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var symbolMap$4 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$3 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("bo", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm",
            LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[], LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: "",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$3[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$4[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem && hour >= 4 || "" === meridiem && hour < 5 || "" === meridiem ? hour + 12 : hour;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 10 ? "" : hour < 17 ? "" : hour < 20 ? "" : "";
        },
        week: {
            dow: 0,
            doy: 6
        }
    }), hooks.defineLocale("br", {
        months: "Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
        monthsShort: "Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
        weekdays: "Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split("_"),
        weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
        weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "h[e]mm A",
            LTS: "h[e]mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D [a viz] MMMM YYYY",
            LLL: "D [a viz] MMMM YYYY h[e]mm A",
            LLLL: "dddd, D [a viz] MMMM YYYY h[e]mm A"
        },
        calendar: {
            sameDay: "[Hiziv da] LT",
            nextDay: "[Warc'hoazh da] LT",
            nextWeek: "dddd [da] LT",
            lastDay: "[Dec'h da] LT",
            lastWeek: "dddd [paset da] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "a-benn %s",
            past: "%s 'zo",
            s: "un nebeud segondenno",
            m: "ur vunutenn",
            mm: relativeTimeWithMutation,
            h: "un eur",
            hh: "%d eur",
            d: "un devezh",
            dd: relativeTimeWithMutation,
            M: "ur miz",
            MM: relativeTimeWithMutation,
            y: "ur bloaz",
            yy: specialMutationForYears
        },
        dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
        ordinal: function(number) {
            return number + (1 === number ? "a" : "vet");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("bs", {
        months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
        monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
        monthsParseExact: !0,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[juer u] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                    return "[prolu] dddd [u] LT";

                  case 6:
                    return "[prole] [subote] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[proli] dddd [u] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "par sekundi",
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: "dan",
            dd: translate,
            M: "mjesec",
            MM: translate,
            y: "godinu",
            yy: translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("ca", {
        months: {
            standalone: "gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
            format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),
            isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort: "gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),
        monthsParseExact: !0,
        weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
        weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
        weekdaysMin: "Dg_Dl_Dt_Dc_Dj_Dv_Ds".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "[el] D MMMM [de] YYYY",
            ll: "D MMM YYYY",
            LLL: "[el] D MMMM [de] YYYY [a les] H:mm",
            lll: "D MMM YYYY, H:mm",
            LLLL: "[el] dddd D MMMM [de] YYYY [a les] H:mm",
            llll: "ddd D MMM YYYY, H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[avui a " + (1 !== this.hours() ? "les" : "la") + "] LT";
            },
            nextDay: function() {
                return "[dem a " + (1 !== this.hours() ? "les" : "la") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a " + (1 !== this.hours() ? "les" : "la") + "] LT";
            },
            lastDay: function() {
                return "[ahir a " + (1 !== this.hours() ? "les" : "la") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [passat a " + (1 !== this.hours() ? "les" : "la") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "d'aqu %s",
            past: "fa %s",
            s: "uns segons",
            m: "un minut",
            mm: "%d minuts",
            h: "una hora",
            hh: "%d hores",
            d: "un dia",
            dd: "%d dies",
            M: "un mes",
            MM: "%d mesos",
            y: "un any",
            yy: "%d anys"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal: function(number, period) {
            var output = 1 === number ? "r" : 2 === number ? "n" : 3 === number ? "r" : 4 === number ? "t" : "";
            return "w" !== period && "W" !== period || (output = "a"), number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var months$3 = "leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec".split("_"), monthsShort = "led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro".split("_");
    hooks.defineLocale("cs", {
        months: months$3,
        monthsShort: monthsShort,
        monthsParse: function(months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) _monthsParse[i] = new RegExp("^" + months[i] + "$|^" + monthsShort[i] + "$", "i");
            return _monthsParse;
        }(months$3, monthsShort),
        shortMonthsParse: function(monthsShort) {
            var i, _shortMonthsParse = [];
            for (i = 0; i < 12; i++) _shortMonthsParse[i] = new RegExp("^" + monthsShort[i] + "$", "i");
            return _shortMonthsParse;
        }(monthsShort),
        longMonthsParse: function(months) {
            var i, _longMonthsParse = [];
            for (i = 0; i < 12; i++) _longMonthsParse[i] = new RegExp("^" + months[i] + "$", "i");
            return _longMonthsParse;
        }(months$3),
        weekdays: "nedle_pondl_ter_steda_tvrtek_ptek_sobota".split("_"),
        weekdaysShort: "ne_po_t_st_t_p_so".split("_"),
        weekdaysMin: "ne_po_t_st_t_p_so".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd D. MMMM YYYY H:mm",
            l: "D. M. YYYY"
        },
        calendar: {
            sameDay: "[dnes v] LT",
            nextDay: "[ztra v] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v nedli v] LT";

                  case 1:
                  case 2:
                    return "[v] dddd [v] LT";

                  case 3:
                    return "[ve stedu v] LT";

                  case 4:
                    return "[ve tvrtek v] LT";

                  case 5:
                    return "[v ptek v] LT";

                  case 6:
                    return "[v sobotu v] LT";
                }
            },
            lastDay: "[vera v] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[minulou nedli v] LT";

                  case 1:
                  case 2:
                    return "[minul] dddd [v] LT";

                  case 3:
                    return "[minulou stedu v] LT";

                  case 4:
                  case 5:
                    return "[minul] dddd [v] LT";

                  case 6:
                    return "[minulou sobotu v] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "ped %s",
            s: translate$1,
            m: translate$1,
            mm: translate$1,
            h: translate$1,
            hh: translate$1,
            d: translate$1,
            dd: translate$1,
            M: translate$1,
            MM: translate$1,
            y: translate$1,
            yy: translate$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("cv", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "YYYY [] MMMM [] D[-]",
            LLL: "YYYY [] MMMM [] D[-], HH:mm",
            LLLL: "dddd, YYYY [] MMMM [] D[-], HH:mm"
        },
        calendar: {
            sameDay: "[] LT []",
            nextDay: "[] LT []",
            lastDay: "[] LT []",
            nextWeek: "[] dddd LT []",
            lastWeek: "[] dddd LT []",
            sameElse: "L"
        },
        relativeTime: {
            future: function(output) {
                return output + (/$/i.exec(output) ? "" : /$/i.exec(output) ? "" : "");
            },
            past: "%s ",
            s: "- ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-/,
        ordinal: "%d-",
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("cy", {
        months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
        monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
        weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
        weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
        weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Heddiw am] LT",
            nextDay: "[Yfory am] LT",
            nextWeek: "dddd [am] LT",
            lastDay: "[Ddoe am] LT",
            lastWeek: "dddd [diwethaf am] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "mewn %s",
            past: "%s yn l",
            s: "ychydig eiliadau",
            m: "munud",
            mm: "%d munud",
            h: "awr",
            hh: "%d awr",
            d: "diwrnod",
            dd: "%d diwrnod",
            M: "mis",
            MM: "%d mis",
            y: "blwyddyn",
            yy: "%d flynedd"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        ordinal: function(number) {
            var b = number, output = "", lookup = [ "", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed" ];
            return b > 20 ? output = 40 === b || 50 === b || 60 === b || 80 === b || 100 === b ? "fed" : "ain" : b > 0 && (output = lookup[b]), 
            number + output;
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("da", {
        months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
        weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
        weekdaysShort: "sn_man_tir_ons_tor_fre_lr".split("_"),
        weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
            sameDay: "[i dag kl.] LT",
            nextDay: "[i morgen kl.] LT",
            nextWeek: "p dddd [kl.] LT",
            lastDay: "[i gr kl.] LT",
            lastWeek: "[i] dddd[s kl.] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "%s siden",
            s: "f sekunder",
            m: "et minut",
            mm: "%d minutter",
            h: "en time",
            hh: "%d timer",
            d: "en dag",
            dd: "%d dage",
            M: "en mned",
            MM: "%d mneder",
            y: "et r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("de-at", {
        months: "Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        monthsParseExact: !0,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            m: processRelativeTime,
            mm: "%d Minuten",
            h: processRelativeTime,
            hh: "%d Stunden",
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("de-ch", {
        months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Febr._Mrz_April_Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.".split("_"),
        monthsParseExact: !0,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH.mm",
            LLLL: "dddd, D. MMMM YYYY HH.mm"
        },
        calendar: {
            sameDay: "[heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            m: processRelativeTime$1,
            mm: "%d Minuten",
            h: processRelativeTime$1,
            hh: "%d Stunden",
            d: processRelativeTime$1,
            dd: processRelativeTime$1,
            M: processRelativeTime$1,
            MM: processRelativeTime$1,
            y: processRelativeTime$1,
            yy: processRelativeTime$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("de", {
        months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        monthsParseExact: !0,
        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY HH:mm",
            LLLL: "dddd, D. MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[heute um] LT [Uhr]",
            sameElse: "L",
            nextDay: "[morgen um] LT [Uhr]",
            nextWeek: "dddd [um] LT [Uhr]",
            lastDay: "[gestern um] LT [Uhr]",
            lastWeek: "[letzten] dddd [um] LT [Uhr]"
        },
        relativeTime: {
            future: "in %s",
            past: "vor %s",
            s: "ein paar Sekunden",
            m: processRelativeTime$2,
            mm: "%d Minuten",
            h: processRelativeTime$2,
            hh: "%d Stunden",
            d: processRelativeTime$2,
            dd: processRelativeTime$2,
            M: processRelativeTime$2,
            MM: processRelativeTime$2,
            y: processRelativeTime$2,
            yy: processRelativeTime$2
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var months$4 = [ "", "", "", "", "", "", "", "", "", "", "", "" ], weekdays = [ "", "", "", "", "", "", "" ];
    hooks.defineLocale("dv", {
        months: months$4,
        monthsShort: months$4,
        weekdays: weekdays,
        weekdaysShort: weekdays,
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "D/M/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: "",
            m: "",
            mm: " %d",
            h: "",
            hh: " %d",
            d: "",
            dd: " %d",
            M: "",
            MM: " %d",
            y: "",
            yy: " %d"
        },
        preparse: function(string) {
            return string.replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/,/g, "");
        },
        week: {
            dow: 7,
            doy: 12
        }
    }), hooks.defineLocale("el", {
        monthsNominativeEl: "___________".split("_"),
        monthsGenitiveEl: "___________".split("_"),
        months: function(momentToFormat, format) {
            return momentToFormat ? /D/.test(format.substring(0, format.indexOf("MMMM"))) ? this._monthsGenitiveEl[momentToFormat.month()] : this._monthsNominativeEl[momentToFormat.month()] : this._monthsNominativeEl;
        },
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        meridiem: function(hours, minutes, isLower) {
            return hours > 11 ? isLower ? "" : "" : isLower ? "" : "";
        },
        isPM: function(input) {
            return "" === (input + "").toLowerCase()[0];
        },
        meridiemParse: /[]\.??\.?/i,
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendarEl: {
            sameDay: "[ {}] LT",
            nextDay: "[ {}] LT",
            nextWeek: "dddd [{}] LT",
            lastDay: "[ {}] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 6:
                    return "[ ] dddd [{}] LT";

                  default:
                    return "[ ] dddd [{}] LT";
                }
            },
            sameElse: "L"
        },
        calendar: function(key, mom) {
            var output = this._calendarEl[key], hours = mom && mom.hours();
            return isFunction(output) && (output = output.apply(mom)), output.replace("{}", hours % 12 == 1 ? "" : "");
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("en-au", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("en-ca", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "YYYY-MM-DD",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY h:mm A",
            LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
        }
    }), hooks.defineLocale("en-gb", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("en-ie", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("en-nz", {
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("eo", {
        months: "januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro".split("_"),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec".split("_"),
        weekdays: "dimano_lundo_mardo_merkredo_ado_vendredo_sabato".split("_"),
        weekdaysShort: "dim_lun_mard_merk_a_ven_sab".split("_"),
        weekdaysMin: "di_lu_ma_me_a_ve_sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "D[-a de] MMMM, YYYY",
            LLL: "D[-a de] MMMM, YYYY HH:mm",
            LLLL: "dddd, [la] D[-a de] MMMM, YYYY HH:mm"
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function(input) {
            return "p" === input.charAt(0).toLowerCase();
        },
        meridiem: function(hours, minutes, isLower) {
            return hours > 11 ? isLower ? "p.t.m." : "P.T.M." : isLower ? "a.t.m." : "A.T.M.";
        },
        calendar: {
            sameDay: "[Hodia je] LT",
            nextDay: "[Morga je] LT",
            nextWeek: "dddd [je] LT",
            lastDay: "[Hiera je] LT",
            lastWeek: "[pasinta] dddd [je] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "post %s",
            past: "anta %s",
            s: "sekundoj",
            m: "minuto",
            mm: "%d minutoj",
            h: "horo",
            hh: "%d horoj",
            d: "tago",
            dd: "%d tagoj",
            M: "monato",
            MM: "%d monatoj",
            y: "jaro",
            yy: "%d jaroj"
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal: "%da",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort$1 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_");
    hooks.defineLocale("es-do", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
        monthsShort: function(m, format) {
            return m ? /-MMM-/.test(format) ? monthsShort$1[m.month()] : monthsShortDot[m.month()] : monthsShortDot;
        },
        monthsParseExact: !0,
        weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY h:mm A",
            LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
        },
        calendar: {
            sameDay: function() {
                return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            lastDay: function() {
                return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "hace %s",
            s: "unos segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "una hora",
            hh: "%d horas",
            d: "un da",
            dd: "%d das",
            M: "un mes",
            MM: "%d meses",
            y: "un ao",
            yy: "%d aos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var monthsShortDot$1 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort$2 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_");
    hooks.defineLocale("es", {
        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
        monthsShort: function(m, format) {
            return m ? /-MMM-/.test(format) ? monthsShort$2[m.month()] : monthsShortDot$1[m.month()] : monthsShortDot$1;
        },
        monthsParseExact: !0,
        weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
        weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY H:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            lastDay: function() {
                return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            lastWeek: function() {
                return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "en %s",
            past: "hace %s",
            s: "unos segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "una hora",
            hh: "%d horas",
            d: "un da",
            dd: "%d das",
            M: "un mes",
            MM: "%d meses",
            y: "un ao",
            yy: "%d aos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("et", {
        months: "jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
        monthsShort: "jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
        weekdays: "phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev".split("_"),
        weekdaysShort: "P_E_T_K_N_R_L".split("_"),
        weekdaysMin: "P_E_T_K_N_R_L".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[Tna,] LT",
            nextDay: "[Homme,] LT",
            nextWeek: "[Jrgmine] dddd LT",
            lastDay: "[Eile,] LT",
            lastWeek: "[Eelmine] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s prast",
            past: "%s tagasi",
            s: processRelativeTime$3,
            m: processRelativeTime$3,
            mm: processRelativeTime$3,
            h: processRelativeTime$3,
            hh: processRelativeTime$3,
            d: processRelativeTime$3,
            dd: "%d peva",
            M: processRelativeTime$3,
            MM: processRelativeTime$3,
            y: processRelativeTime$3,
            yy: processRelativeTime$3
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("eu", {
        months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
        monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
        monthsParseExact: !0,
        weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
        weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
        weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "YYYY[ko] MMMM[ren] D[a]",
            LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
            LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
            l: "YYYY-M-D",
            ll: "YYYY[ko] MMM D[a]",
            lll: "YYYY[ko] MMM D[a] HH:mm",
            llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
        },
        calendar: {
            sameDay: "[gaur] LT[etan]",
            nextDay: "[bihar] LT[etan]",
            nextWeek: "dddd LT[etan]",
            lastDay: "[atzo] LT[etan]",
            lastWeek: "[aurreko] dddd LT[etan]",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s barru",
            past: "duela %s",
            s: "segundo batzuk",
            m: "minutu bat",
            mm: "%d minutu",
            h: "ordu bat",
            hh: "%d ordu",
            d: "egun bat",
            dd: "%d egun",
            M: "hilabete bat",
            MM: "%d hilabete",
            y: "urte bat",
            yy: "%d urte"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var symbolMap$5 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$4 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("fa", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        meridiemParse: /  |  /,
        isPM: function(input) {
            return /  /.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "  " : "  ";
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "dddd [] [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[-]/g, function(match) {
                return numberMap$4[match];
            }).replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$5[match];
            }).replace(/,/g, "");
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 6,
            doy: 12
        }
    });
    var numbersPast = "nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn".split(" "), numbersFuture = [ "nolla", "yhden", "kahden", "kolmen", "neljn", "viiden", "kuuden", numbersPast[7], numbersPast[8], numbersPast[9] ];
    hooks.defineLocale("fi", {
        months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
        monthsShort: "tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu".split("_"),
        weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
        weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
        weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD.MM.YYYY",
            LL: "Do MMMM[ta] YYYY",
            LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
            LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
            l: "D.M.YYYY",
            ll: "Do MMM YYYY",
            lll: "Do MMM YYYY, [klo] HH.mm",
            llll: "ddd, Do MMM YYYY, [klo] HH.mm"
        },
        calendar: {
            sameDay: "[tnn] [klo] LT",
            nextDay: "[huomenna] [klo] LT",
            nextWeek: "dddd [klo] LT",
            lastDay: "[eilen] [klo] LT",
            lastWeek: "[viime] dddd[na] [klo] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s pst",
            past: "%s sitten",
            s: translate$2,
            m: translate$2,
            mm: translate$2,
            h: translate$2,
            hh: translate$2,
            d: translate$2,
            dd: translate$2,
            M: translate$2,
            MM: translate$2,
            y: translate$2,
            yy: translate$2
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("fo", {
        months: "januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
        weekdays: "sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur".split("_"),
        weekdaysShort: "sun_mn_ts_mik_hs_fr_ley".split("_"),
        weekdaysMin: "su_m_t_mi_h_fr_le".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D. MMMM, YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ dag kl.] LT",
            nextDay: "[ morgin kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[ gjr kl.] LT",
            lastWeek: "[sstu] dddd [kl] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "um %s",
            past: "%s sani",
            s: "f sekund",
            m: "ein minutt",
            mm: "%d minuttir",
            h: "ein tmi",
            hh: "%d tmar",
            d: "ein dagur",
            dd: "%d dagar",
            M: "ein mnai",
            MM: "%d mnair",
            y: "eitt r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("fr-ca", {
        months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        monthsParseExact: !0,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Aujourdhui ] LT",
            nextDay: "[Demain ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[Hier ] LT",
            lastWeek: "dddd [dernier ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dans %s",
            past: "il y a %s",
            s: "quelques secondes",
            m: "une minute",
            mm: "%d minutes",
            h: "une heure",
            hh: "%d heures",
            d: "un jour",
            dd: "%d jours",
            M: "un mois",
            MM: "%d mois",
            y: "un an",
            yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function(number, period) {
            switch (period) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return number + (1 === number ? "er" : "e");

              case "w":
              case "W":
                return number + (1 === number ? "re" : "e");
            }
        }
    }), hooks.defineLocale("fr-ch", {
        months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        monthsParseExact: !0,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Aujourdhui ] LT",
            nextDay: "[Demain ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[Hier ] LT",
            lastWeek: "dddd [dernier ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dans %s",
            past: "il y a %s",
            s: "quelques secondes",
            m: "une minute",
            mm: "%d minutes",
            h: "une heure",
            hh: "%d heures",
            d: "un jour",
            dd: "%d jours",
            M: "un mois",
            MM: "%d mois",
            y: "un an",
            yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function(number, period) {
            switch (period) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return number + (1 === number ? "er" : "e");

              case "w":
              case "W":
                return number + (1 === number ? "re" : "e");
            }
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("fr", {
        months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
        monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
        monthsParseExact: !0,
        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Aujourdhui ] LT",
            nextDay: "[Demain ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[Hier ] LT",
            lastWeek: "dddd [dernier ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dans %s",
            past: "il y a %s",
            s: "quelques secondes",
            m: "une minute",
            mm: "%d minutes",
            h: "une heure",
            hh: "%d heures",
            d: "un jour",
            dd: "%d jours",
            M: "un mois",
            MM: "%d mois",
            y: "un an",
            yy: "%d ans"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function(number, period) {
            switch (period) {
              case "D":
                return number + (1 === number ? "er" : "");

              default:
              case "M":
              case "Q":
              case "DDD":
              case "d":
                return number + (1 === number ? "er" : "e");

              case "w":
              case "W":
                return number + (1 === number ? "re" : "e");
            }
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
    hooks.defineLocale("fy", {
        months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
        monthsShort: function(m, format) {
            return m ? /-MMM-/.test(format) ? monthsShortWithoutDots[m.month()] : monthsShortWithDots[m.month()] : monthsShortWithDots;
        },
        monthsParseExact: !0,
        weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
        weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
        weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[hjoed om] LT",
            nextDay: "[moarn om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[juster om] LT",
            lastWeek: "[frne] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "oer %s",
            past: "%s lyn",
            s: "in pear sekonden",
            m: "ien mint",
            mm: "%d minuten",
            h: "ien oere",
            hh: "%d oeren",
            d: "ien dei",
            dd: "%d dagen",
            M: "ien moanne",
            MM: "%d moannen",
            y: "ien jier",
            yy: "%d jierren"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var months$5 = [ "Am Faoilleach", "An Gearran", "Am Mrt", "An Giblean", "An Citean", "An t-gmhios", "An t-Iuchar", "An Lnastal", "An t-Sultain", "An Dmhair", "An t-Samhain", "An Dbhlachd" ], monthsShort$3 = [ "Faoi", "Gear", "Mrt", "Gibl", "Cit", "gmh", "Iuch", "Ln", "Sult", "Dmh", "Samh", "Dbh" ], weekdays$1 = [ "Didmhnaich", "Diluain", "Dimirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne" ], weekdaysShort = [ "Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis" ], weekdaysMin = [ "D", "Lu", "M", "Ci", "Ar", "Ha", "Sa" ];
    hooks.defineLocale("gd", {
        months: months$5,
        monthsShort: monthsShort$3,
        monthsParseExact: !0,
        weekdays: weekdays$1,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[An-diugh aig] LT",
            nextDay: "[A-mireach aig] LT",
            nextWeek: "dddd [aig] LT",
            lastDay: "[An-d aig] LT",
            lastWeek: "dddd [seo chaidh] [aig] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "ann an %s",
            past: "bho chionn %s",
            s: "beagan diogan",
            m: "mionaid",
            mm: "%d mionaidean",
            h: "uair",
            hh: "%d uairean",
            d: "latha",
            dd: "%d latha",
            M: "mos",
            MM: "%d mosan",
            y: "bliadhna",
            yy: "%d bliadhna"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function(number) {
            return number + (1 === number ? "d" : number % 10 == 2 ? "na" : "mh");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("gl", {
        months: "xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),
        monthsShort: "xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.".split("_"),
        monthsParseExact: !0,
        weekdays: "domingo_luns_martes_mrcores_xoves_venres_sbado".split("_"),
        weekdaysShort: "dom._lun._mar._mr._xov._ven._sb.".split("_"),
        weekdaysMin: "do_lu_ma_m_xo_ve_s".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY H:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
        },
        calendar: {
            sameDay: function() {
                return "[hoxe " + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            nextDay: function() {
                return "[ma " + (1 !== this.hours() ? "s" : "") + "] LT";
            },
            nextWeek: function() {
                return "dddd [" + (1 !== this.hours() ? "s" : "a") + "] LT";
            },
            lastDay: function() {
                return "[onte " + (1 !== this.hours() ? "" : "a") + "] LT";
            },
            lastWeek: function() {
                return "[o] dddd [pasado " + (1 !== this.hours() ? "s" : "a") + "] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: function(str) {
                return 0 === str.indexOf("un") ? "n" + str : "en " + str;
            },
            past: "hai %s",
            s: "uns segundos",
            m: "un minuto",
            mm: "%d minutos",
            h: "unha hora",
            hh: "%d horas",
            d: "un da",
            dd: "%d das",
            M: "un mes",
            MM: "%d meses",
            y: "un ano",
            yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("gom-latn", {
        months: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),
        monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
        monthsParseExact: !0,
        weekdays: "Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son'var".split("_"),
        weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
        weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "A h:mm [vazta]",
            LTS: "A h:mm:ss [vazta]",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY A h:mm [vazta]",
            LLLL: "dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]",
            llll: "ddd, D MMM YYYY, A h:mm [vazta]"
        },
        calendar: {
            sameDay: "[Aiz] LT",
            nextDay: "[Faleam] LT",
            nextWeek: "[Ieta to] dddd[,] LT",
            lastDay: "[Kal] LT",
            lastWeek: "[Fatlo] dddd[,] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s adim",
            s: processRelativeTime$4,
            m: processRelativeTime$4,
            mm: processRelativeTime$4,
            h: processRelativeTime$4,
            hh: processRelativeTime$4,
            d: processRelativeTime$4,
            dd: processRelativeTime$4,
            M: processRelativeTime$4,
            MM: processRelativeTime$4,
            y: processRelativeTime$4,
            yy: processRelativeTime$4
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
        ordinal: function(number, period) {
            switch (period) {
              case "D":
                return number + "er";

              default:
              case "M":
              case "Q":
              case "DDD":
              case "d":
              case "w":
              case "W":
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 4
        },
        meridiemParse: /rati|sokalli|donparam|sanje/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "rati" === meridiem ? hour < 4 ? hour : hour + 12 : "sokalli" === meridiem ? hour : "donparam" === meridiem ? hour > 12 ? hour : hour + 12 : "sanje" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "rati" : hour < 12 ? "sokalli" : hour < 16 ? "donparam" : hour < 20 ? "sanje" : "rati";
        }
    }), hooks.defineLocale("he", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D []MMMM YYYY",
            LLL: "D []MMMM YYYY HH:mm",
            LLLL: "dddd, D []MMMM YYYY HH:mm",
            l: "D/M/YYYY",
            ll: "D MMM YYYY",
            lll: "D MMM YYYY HH:mm",
            llll: "ddd, D MMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ]LT",
            nextDay: "[ ]LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ]LT",
            lastWeek: "[] dddd [ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: " ",
            m: "",
            mm: "%d ",
            h: "",
            hh: function(number) {
                return 2 === number ? "" : number + " ";
            },
            d: "",
            dd: function(number) {
                return 2 === number ? "" : number + " ";
            },
            M: "",
            MM: function(number) {
                return 2 === number ? "" : number + " ";
            },
            y: "",
            yy: function(number) {
                return 2 === number ? "" : number % 10 == 0 && 10 !== number ? number + " " : number + " ";
            }
        },
        meridiemParse: /"|"| | | ||/i,
        isPM: function(input) {
            return /^("| |)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 5 ? " " : hour < 10 ? "" : hour < 12 ? isLower ? '"' : " " : hour < 18 ? isLower ? '"' : " " : "";
        }
    });
    var symbolMap$6 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$5 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("hi", {
        months: "___________".split("_"),
        monthsShort: "._.__.___._._._._._.".split("_"),
        monthsParseExact: !0,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: "  ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$5[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$6[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem ? hour < 4 ? hour : hour + 12 : "" === meridiem ? hour : "" === meridiem ? hour >= 10 ? hour : hour + 12 : "" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 10 ? "" : hour < 17 ? "" : hour < 20 ? "" : "";
        },
        week: {
            dow: 0,
            doy: 6
        }
    }), hooks.defineLocale("hr", {
        months: {
            format: "sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),
            standalone: "sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")
        },
        monthsShort: "sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
        monthsParseExact: !0,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[juer u] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                    return "[prolu] dddd [u] LT";

                  case 6:
                    return "[prole] [subote] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[proli] dddd [u] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "par sekundi",
            m: translate$3,
            mm: translate$3,
            h: translate$3,
            hh: translate$3,
            d: "dan",
            dd: translate$3,
            M: "mjesec",
            MM: translate$3,
            y: "godinu",
            yy: translate$3
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var weekEndings = "vasrnap htfn kedden szerdn cstrtkn pnteken szombaton".split(" ");
    hooks.defineLocale("hu", {
        months: "janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december".split("_"),
        monthsShort: "jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec".split("_"),
        weekdays: "vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat".split("_"),
        weekdaysShort: "vas_ht_kedd_sze_cst_pn_szo".split("_"),
        weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "YYYY.MM.DD.",
            LL: "YYYY. MMMM D.",
            LLL: "YYYY. MMMM D. H:mm",
            LLLL: "YYYY. MMMM D., dddd H:mm"
        },
        meridiemParse: /de|du/i,
        isPM: function(input) {
            return "u" === input.charAt(1).toLowerCase();
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 12 ? !0 === isLower ? "de" : "DE" : !0 === isLower ? "du" : "DU";
        },
        calendar: {
            sameDay: "[ma] LT[-kor]",
            nextDay: "[holnap] LT[-kor]",
            nextWeek: function() {
                return week.call(this, !0);
            },
            lastDay: "[tegnap] LT[-kor]",
            lastWeek: function() {
                return week.call(this, !1);
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "%s mlva",
            past: "%s",
            s: translate$4,
            m: translate$4,
            mm: translate$4,
            h: translate$4,
            hh: translate$4,
            d: translate$4,
            dd: translate$4,
            M: translate$4,
            MM: translate$4,
            y: translate$4,
            yy: translate$4
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("hy-am", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY .",
            LLL: "D MMMM YYYY ., HH:mm",
            LLLL: "dddd, D MMMM YYYY ., HH:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            lastDay: "[] LT",
            nextWeek: function() {
                return "dddd [ ] LT";
            },
            lastWeek: function() {
                return "[] dddd [ ] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: "  ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        meridiemParse: /|||/,
        isPM: function(input) {
            return /^(|)$/.test(input);
        },
        meridiem: function(hour) {
            return hour < 4 ? "" : hour < 12 ? "" : hour < 17 ? "" : "";
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
        ordinal: function(number, period) {
            switch (period) {
              case "DDD":
              case "w":
              case "W":
              case "DDDo":
                return 1 === number ? number + "-" : number + "-";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("id", {
        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
        weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "siang" === meridiem ? hour >= 11 ? hour : hour + 12 : "sore" === meridiem || "malam" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 11 ? "pagi" : hours < 15 ? "siang" : hours < 19 ? "sore" : "malam";
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Besok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kemarin pukul] LT",
            lastWeek: "dddd [lalu pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lalu",
            s: "beberapa detik",
            m: "semenit",
            mm: "%d menit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("is", {
        months: "janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des".split("_"),
        weekdays: "sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur".split("_"),
        weekdaysShort: "sun_mn_ri_mi_fim_fs_lau".split("_"),
        weekdaysMin: "Su_M_r_Mi_Fi_F_La".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY [kl.] H:mm",
            LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
        },
        calendar: {
            sameDay: "[ dag kl.] LT",
            nextDay: "[ morgun kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[ gr kl.] LT",
            lastWeek: "[sasta] dddd [kl.] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "eftir %s",
            past: "fyrir %s san",
            s: translate$5,
            m: translate$5,
            mm: translate$5,
            h: "klukkustund",
            hh: translate$5,
            d: translate$5,
            dd: translate$5,
            M: translate$5,
            MM: translate$5,
            y: translate$5,
            yy: translate$5
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("it", {
        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
        weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"),
        weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
        weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Oggi alle] LT",
            nextDay: "[Domani alle] LT",
            nextWeek: "dddd [alle] LT",
            lastDay: "[Ieri alle] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[la scorsa] dddd [alle] LT";

                  default:
                    return "[lo scorso] dddd [alle] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: function(s) {
                return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
            },
            past: "%s fa",
            s: "alcuni secondi",
            m: "un minuto",
            mm: "%d minuti",
            h: "un'ora",
            hh: "%d ore",
            d: "un giorno",
            dd: "%d giorni",
            M: "un mese",
            MM: "%d mesi",
            y: "un anno",
            yy: "%d anni"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("ja", {
        months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYYMD",
            LLL: "YYYYMD HH:mm",
            LLLL: "YYYYMD HH:mm dddd",
            l: "YYYY/MM/DD",
            ll: "YYYYMD",
            lll: "YYYYMD HH:mm",
            llll: "YYYYMD HH:mm dddd"
        },
        meridiemParse: /|/i,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[]dddd LT",
            lastDay: "[] LT",
            lastWeek: "[]dddd LT",
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            m: "1",
            mm: "%d",
            h: "1",
            hh: "%d",
            d: "1",
            dd: "%d",
            M: "1",
            MM: "%d",
            y: "1",
            yy: "%d"
        }
    }), hooks.defineLocale("jv", {
        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),
        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
        weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
        weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "enjing" === meridiem ? hour : "siyang" === meridiem ? hour >= 11 ? hour : hour + 12 : "sonten" === meridiem || "ndalu" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 11 ? "enjing" : hours < 15 ? "siyang" : hours < 19 ? "sonten" : "ndalu";
        },
        calendar: {
            sameDay: "[Dinten puniko pukul] LT",
            nextDay: "[Mbenjang pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kala wingi pukul] LT",
            lastWeek: "dddd [kepengker pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "wonten ing %s",
            past: "%s ingkang kepengker",
            s: "sawetawis detik",
            m: "setunggal menit",
            mm: "%d menit",
            h: "setunggal jam",
            hh: "%d jam",
            d: "sedinten",
            dd: "%d dinten",
            M: "sewulan",
            MM: "%d wulan",
            y: "setaun",
            yy: "%d taun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("ka", {
        months: {
            standalone: "___________".split("_"),
            format: "___________".split("_")
        },
        monthsShort: "___________".split("_"),
        weekdays: {
            standalone: "______".split("_"),
            format: "______".split("_"),
            isFormat: /(|)/
        },
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[] LT[-]",
            nextDay: "[] LT[-]",
            lastDay: "[] LT[-]",
            nextWeek: "[] dddd LT[-]",
            lastWeek: "[] dddd LT-",
            sameElse: "L"
        },
        relativeTime: {
            future: function(s) {
                return /(|||)/.test(s) ? s.replace(/$/, "") : s + "";
            },
            past: function(s) {
                return /(||||)/.test(s) ? s.replace(/(|)$/, " ") : //.test(s) ? s.replace(/$/, " ") : void 0;
            },
            s: " ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
        ordinal: function(number) {
            return 0 === number ? number : 1 === number ? number + "-" : number < 20 || number <= 100 && number % 20 == 0 || number % 100 == 0 ? "-" + number : number + "-";
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var suffixes$1 = {
        0: "-",
        1: "-",
        2: "-",
        3: "-",
        4: "-",
        5: "-",
        6: "-",
        7: "-",
        8: "-",
        9: "-",
        10: "-",
        20: "-",
        30: "-",
        40: "-",
        50: "-",
        60: "-",
        70: "-",
        80: "-",
        90: "-",
        100: "-"
    };
    hooks.defineLocale("kk", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "[ ] dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function(number) {
            var a = number % 10, b = number >= 100 ? 100 : null;
            return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("km", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "dddd [] [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$7 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$6 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("kn", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        monthsParseExact: !0,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm",
            LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$6[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$7[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem ? hour < 4 ? hour : hour + 12 : "" === meridiem ? hour : "" === meridiem ? hour >= 10 ? hour : hour + 12 : "" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 10 ? "" : hour < 17 ? "" : hour < 20 ? "" : "";
        },
        dayOfMonthOrdinalParse: /\d{1,2}()/,
        ordinal: function(number) {
            return number + "";
        },
        week: {
            dow: 0,
            doy: 6
        }
    }), hooks.defineLocale("ko", {
        months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "YYYY.MM.DD",
            LL: "YYYY MMMM D",
            LLL: "YYYY MMMM D A h:mm",
            LLLL: "YYYY MMMM D dddd A h:mm",
            l: "YYYY.MM.DD",
            ll: "YYYY MMMM D",
            lll: "YYYY MMMM D A h:mm",
            llll: "YYYY MMMM D dddd A h:mm"
        },
        calendar: {
            sameDay: " LT",
            nextDay: " LT",
            nextWeek: "dddd LT",
            lastDay: " LT",
            lastWeek: " dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            ss: "%d",
            m: "1",
            mm: "%d",
            h: " ",
            hh: "%d",
            d: "",
            dd: "%d",
            M: " ",
            MM: "%d",
            y: " ",
            yy: "%d"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        meridiemParse: /|/,
        isPM: function(token) {
            return "" === token;
        },
        meridiem: function(hour, minute, isUpper) {
            return hour < 12 ? "" : "";
        }
    });
    var suffixes$2 = {
        0: "-",
        1: "-",
        2: "-",
        3: "-",
        4: "-",
        5: "-",
        6: "-",
        7: "-",
        8: "-",
        9: "-",
        10: "-",
        20: "-",
        30: "-",
        40: "-",
        50: "-",
        60: "-",
        70: "-",
        80: "-",
        90: "-",
        100: "-"
    };
    hooks.defineLocale("ky", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "[ ] dddd [] [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
        ordinal: function(number) {
            var a = number % 10, b = number >= 100 ? 100 : null;
            return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("lb", {
        months: "Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        monthsParseExact: !0,
        weekdays: "Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
        weekdaysShort: "So._M._D._M._Do._Fr._Sa.".split("_"),
        weekdaysMin: "So_M_D_M_Do_Fr_Sa".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm [Auer]",
            LTS: "H:mm:ss [Auer]",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm [Auer]",
            LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
        },
        calendar: {
            sameDay: "[Haut um] LT",
            sameElse: "L",
            nextDay: "[Muer um] LT",
            nextWeek: "dddd [um] LT",
            lastDay: "[Gschter um] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 2:
                  case 4:
                    return "[Leschten] dddd [um] LT";

                  default:
                    return "[Leschte] dddd [um] LT";
                }
            }
        },
        relativeTime: {
            future: processFutureTime,
            past: processPastTime,
            s: "e puer Sekonnen",
            m: processRelativeTime$5,
            mm: "%d Minutten",
            h: processRelativeTime$5,
            hh: "%d Stonnen",
            d: processRelativeTime$5,
            dd: "%d Deeg",
            M: processRelativeTime$5,
            MM: "%d Mint",
            y: processRelativeTime$5,
            yy: "%d Joer"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("lo", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[]dddd[] LT",
            lastDay: "[] LT",
            lastWeek: "[]dddd[] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s",
            s: "",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /()\d{1,2}/,
        ordinal: function(number) {
            return "" + number;
        }
    });
    var units = {
        m: "minut_minuts_minut",
        mm: "minuts_minui_minutes",
        h: "valanda_valandos_valand",
        hh: "valandos_valand_valandas",
        d: "diena_dienos_dien",
        dd: "dienos_dien_dienas",
        M: "mnuo_mnesio_mnes",
        MM: "mnesiai_mnesi_mnesius",
        y: "metai_met_metus",
        yy: "metai_met_metus"
    };
    hooks.defineLocale("lt", {
        months: {
            format: "sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio".split("_"),
            standalone: "sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis".split("_"),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
        },
        monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
        weekdays: {
            format: "sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien".split("_"),
            standalone: "sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis".split("_"),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_e".split("_"),
        weekdaysMin: "S_P_A_T_K_Pn_".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "YYYY [m.] MMMM D [d.]",
            LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
            LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
            l: "YYYY-MM-DD",
            ll: "YYYY [m.] MMMM D [d.]",
            lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
            llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
        },
        calendar: {
            sameDay: "[iandien] LT",
            nextDay: "[Rytoj] LT",
            nextWeek: "dddd LT",
            lastDay: "[Vakar] LT",
            lastWeek: "[Prajus] dddd LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "po %s",
            past: "prie %s",
            s: translateSeconds,
            m: translateSingular,
            mm: translate$6,
            h: translateSingular,
            hh: translate$6,
            d: translateSingular,
            dd: translate$6,
            M: translateSingular,
            MM: translate$6,
            y: translateSingular,
            yy: translate$6
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal: function(number) {
            return number + "-oji";
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var units$1 = {
        m: "mintes_mintm_minte_mintes".split("_"),
        mm: "mintes_mintm_minte_mintes".split("_"),
        h: "stundas_stundm_stunda_stundas".split("_"),
        hh: "stundas_stundm_stunda_stundas".split("_"),
        d: "dienas_dienm_diena_dienas".split("_"),
        dd: "dienas_dienm_diena_dienas".split("_"),
        M: "mnea_mneiem_mnesis_mnei".split("_"),
        MM: "mnea_mneiem_mnesis_mnei".split("_"),
        y: "gada_gadiem_gads_gadi".split("_"),
        yy: "gada_gadiem_gads_gadi".split("_")
    };
    hooks.defineLocale("lv", {
        months: "janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec".split("_"),
        weekdays: "svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena".split("_"),
        weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
        weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY.",
            LL: "YYYY. [gada] D. MMMM",
            LLL: "YYYY. [gada] D. MMMM, HH:mm",
            LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
        },
        calendar: {
            sameDay: "[odien pulksten] LT",
            nextDay: "[Rt pulksten] LT",
            nextWeek: "dddd [pulksten] LT",
            lastDay: "[Vakar pulksten] LT",
            lastWeek: "[Pagju] dddd [pulksten] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "pc %s",
            past: "pirms %s",
            s: relativeSeconds,
            m: relativeTimeWithSingular,
            mm: relativeTimeWithPlural$1,
            h: relativeTimeWithSingular,
            hh: relativeTimeWithPlural$1,
            d: relativeTimeWithSingular,
            dd: relativeTimeWithPlural$1,
            M: relativeTimeWithSingular,
            MM: relativeTimeWithPlural$1,
            y: relativeTimeWithSingular,
            yy: relativeTimeWithPlural$1
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var translator = {
        words: {
            m: [ "jedan minut", "jednog minuta" ],
            mm: [ "minut", "minuta", "minuta" ],
            h: [ "jedan sat", "jednog sata" ],
            hh: [ "sat", "sata", "sati" ],
            dd: [ "dan", "dana", "dana" ],
            MM: [ "mjesec", "mjeseca", "mjeseci" ],
            yy: [ "godina", "godine", "godina" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            return 1 === key.length ? withoutSuffix ? wordKey[0] : wordKey[1] : number + " " + translator.correctGrammaticalCase(number, wordKey);
        }
    };
    hooks.defineLocale("me", {
        months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
        monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
        monthsParseExact: !0,
        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sjutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedjelju] [u] LT";

                  case 3:
                    return "[u] [srijedu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[jue u] LT",
            lastWeek: function() {
                return [ "[prole] [nedjelje] [u] LT", "[prolog] [ponedjeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srijede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT" ][this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "prije %s",
            s: "nekoliko sekundi",
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: "dan",
            dd: translator.translate,
            M: "mjesec",
            MM: translator.translate,
            y: "godinu",
            yy: translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("mi", {
        months: "Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea".split("_"),
        monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: "Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei".split("_"),
        weekdaysShort: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
        weekdaysMin: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [i] HH:mm",
            LLLL: "dddd, D MMMM YYYY [i] HH:mm"
        },
        calendar: {
            sameDay: "[i teie mahana, i] LT",
            nextDay: "[apopo i] LT",
            nextWeek: "dddd [i] LT",
            lastDay: "[inanahi i] LT",
            lastWeek: "dddd [whakamutunga i] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "i roto i %s",
            past: "%s i mua",
            s: "te hkona ruarua",
            m: "he meneti",
            mm: "%d meneti",
            h: "te haora",
            hh: "%d haora",
            d: "he ra",
            dd: "%d ra",
            M: "he marama",
            MM: "%d marama",
            y: "he tau",
            yy: "%d tau"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("mk", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "e_o_____a".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "D.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "[] dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 6:
                    return "[] dddd [] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[] dddd [] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: " ",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal: function(number) {
            var lastDigit = number % 10, last2Digits = number % 100;
            return 0 === number ? number + "-" : 0 === last2Digits ? number + "-" : last2Digits > 10 && last2Digits < 20 ? number + "-" : 1 === lastDigit ? number + "-" : 2 === lastDigit ? number + "-" : 7 === lastDigit || 8 === lastDigit ? number + "-" : number + "-";
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("ml", {
        months: "___________".split("_"),
        monthsShort: "._._._.___._._._._._.".split("_"),
        monthsParseExact: !0,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm -",
            LTS: "A h:mm:ss -",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm -",
            LLLL: "dddd, D MMMM YYYY, A h:mm -"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        meridiemParse: /|| ||/i,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem && hour >= 4 || " " === meridiem || "" === meridiem ? hour + 12 : hour;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 12 ? "" : hour < 17 ? " " : hour < 20 ? "" : "";
        }
    });
    var symbolMap$8 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$7 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("mr", {
        months: "___________".split("_"),
        monthsShort: "._._._._._._._._._._._.".split("_"),
        monthsParseExact: !0,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$7[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$8[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem ? hour < 4 ? hour : hour + 12 : "" === meridiem ? hour : "" === meridiem ? hour >= 10 ? hour : hour + 12 : "" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 10 ? "" : hour < 17 ? "" : hour < 20 ? "" : "";
        },
        week: {
            dow: 0,
            doy: 6
        }
    }), hooks.defineLocale("ms-my", {
        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "tengahari" === meridiem ? hour >= 11 ? hour : hour + 12 : "petang" === meridiem || "malam" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 11 ? "pagi" : hours < 15 ? "tengahari" : hours < 19 ? "petang" : "malam";
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Esok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kelmarin pukul] LT",
            lastWeek: "dddd [lepas pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lepas",
            s: "beberapa saat",
            m: "seminit",
            mm: "%d minit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("ms", {
        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [pukul] HH.mm",
            LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "tengahari" === meridiem ? hour >= 11 ? hour : hour + 12 : "petang" === meridiem || "malam" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 11 ? "pagi" : hours < 15 ? "tengahari" : hours < 19 ? "petang" : "malam";
        },
        calendar: {
            sameDay: "[Hari ini pukul] LT",
            nextDay: "[Esok pukul] LT",
            nextWeek: "dddd [pukul] LT",
            lastDay: "[Kelmarin pukul] LT",
            lastWeek: "dddd [lepas pukul] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dalam %s",
            past: "%s yang lepas",
            s: "beberapa saat",
            m: "seminit",
            mm: "%d minit",
            h: "sejam",
            hh: "%d jam",
            d: "sehari",
            dd: "%d hari",
            M: "sebulan",
            MM: "%d bulan",
            y: "setahun",
            yy: "%d tahun"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var symbolMap$9 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$8 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("my", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[.] LT []",
            nextDay: "[] LT []",
            nextWeek: "dddd LT []",
            lastDay: "[.] LT []",
            lastWeek: "[] dddd LT []",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s ",
            past: " %s ",
            s: ".",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d ",
            M: "",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$8[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$9[match];
            });
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("nb", {
        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
        monthsParseExact: !0,
        weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
        weekdaysShort: "s._ma._ti._on._to._fr._l.".split("_"),
        weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY [kl.] HH:mm",
            LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
            sameDay: "[i dag kl.] LT",
            nextDay: "[i morgen kl.] LT",
            nextWeek: "dddd [kl.] LT",
            lastDay: "[i gr kl.] LT",
            lastWeek: "[forrige] dddd [kl.] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "%s siden",
            s: "noen sekunder",
            m: "ett minutt",
            mm: "%d minutter",
            h: "en time",
            hh: "%d timer",
            d: "en dag",
            dd: "%d dager",
            M: "en mned",
            MM: "%d mneder",
            y: "ett r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$10 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$9 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("ne", {
        months: "___________".split("_"),
        monthsShort: "._.__.___._._._._._.".split("_"),
        monthsParseExact: !0,
        weekdays: "______".split("_"),
        weekdaysShort: "._._._._._._.".split("_"),
        weekdaysMin: "._._._._._._.".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$9[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$10[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem ? hour < 4 ? hour : hour + 12 : "" === meridiem ? hour : "" === meridiem ? hour >= 10 ? hour : hour + 12 : "" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 3 ? "" : hour < 12 ? "" : hour < 16 ? "" : hour < 20 ? "" : "";
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "[] dddd[,] LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd[,] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var monthsShortWithDots$1 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots$1 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse = [ /^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i ], monthsRegex$1 = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    hooks.defineLocale("nl-be", {
        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
        monthsShort: function(m, format) {
            return m ? /-MMM-/.test(format) ? monthsShortWithoutDots$1[m.month()] : monthsShortWithDots$1[m.month()] : monthsShortWithDots$1;
        },
        monthsRegex: monthsRegex$1,
        monthsShortRegex: monthsRegex$1,
        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
        weekdaysMin: "Zo_Ma_Di_Wo_Do_Vr_Za".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[vandaag om] LT",
            nextDay: "[morgen om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[gisteren om] LT",
            lastWeek: "[afgelopen] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "over %s",
            past: "%s geleden",
            s: "een paar seconden",
            m: "n minuut",
            mm: "%d minuten",
            h: "n uur",
            hh: "%d uur",
            d: "n dag",
            dd: "%d dagen",
            M: "n maand",
            MM: "%d maanden",
            y: "n jaar",
            yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var monthsShortWithDots$2 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots$2 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse$1 = [ /^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i ], monthsRegex$2 = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    hooks.defineLocale("nl", {
        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
        monthsShort: function(m, format) {
            return m ? /-MMM-/.test(format) ? monthsShortWithoutDots$2[m.month()] : monthsShortWithDots$2[m.month()] : monthsShortWithDots$2;
        },
        monthsRegex: monthsRegex$2,
        monthsShortRegex: monthsRegex$2,
        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
        monthsParse: monthsParse$1,
        longMonthsParse: monthsParse$1,
        shortMonthsParse: monthsParse$1,
        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
        weekdaysMin: "Zo_Ma_Di_Wo_Do_Vr_Za".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD-MM-YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[vandaag om] LT",
            nextDay: "[morgen om] LT",
            nextWeek: "dddd [om] LT",
            lastDay: "[gisteren om] LT",
            lastWeek: "[afgelopen] dddd [om] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "over %s",
            past: "%s geleden",
            s: "een paar seconden",
            m: "n minuut",
            mm: "%d minuten",
            h: "n uur",
            hh: "%d uur",
            d: "n dag",
            dd: "%d dagen",
            M: "n maand",
            MM: "%d maanden",
            y: "n jaar",
            yy: "%d jaar"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function(number) {
            return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("nn", {
        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
        monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
        weekdays: "sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
        weekdaysShort: "sun_mn_tys_ons_tor_fre_lau".split("_"),
        weekdaysMin: "su_m_ty_on_to_fr_l".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY [kl.] H:mm",
            LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
        },
        calendar: {
            sameDay: "[I dag klokka] LT",
            nextDay: "[I morgon klokka] LT",
            nextWeek: "dddd [klokka] LT",
            lastDay: "[I gr klokka] LT",
            lastWeek: "[Fregande] dddd [klokka] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "%s sidan",
            s: "nokre sekund",
            m: "eit minutt",
            mm: "%d minutt",
            h: "ein time",
            hh: "%d timar",
            d: "ein dag",
            dd: "%d dagar",
            M: "ein mnad",
            MM: "%d mnader",
            y: "eit r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var symbolMap$11 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$10 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("pa-in", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm ",
            LTS: "A h:mm:ss ",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm ",
            LLLL: "dddd, D MMMM YYYY, A h:mm "
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$10[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$11[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem ? hour < 4 ? hour : hour + 12 : "" === meridiem ? hour : "" === meridiem ? hour >= 10 ? hour : hour + 12 : "" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 10 ? "" : hour < 17 ? "" : hour < 20 ? "" : "";
        },
        week: {
            dow: 0,
            doy: 6
        }
    });
    var monthsNominative = "stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie".split("_"), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia".split("_");
    hooks.defineLocale("pl", {
        months: function(momentToFormat, format) {
            return momentToFormat ? "" === format ? "(" + monthsSubjective[momentToFormat.month()] + "|" + monthsNominative[momentToFormat.month()] + ")" : /D MMMM/.test(format) ? monthsSubjective[momentToFormat.month()] : monthsNominative[momentToFormat.month()] : monthsNominative;
        },
        monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"),
        weekdays: "niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota".split("_"),
        weekdaysShort: "ndz_pon_wt_r_czw_pt_sob".split("_"),
        weekdaysMin: "Nd_Pn_Wt_r_Cz_Pt_So".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Dzi o] LT",
            nextDay: "[Jutro o] LT",
            nextWeek: "[W] dddd [o] LT",
            lastDay: "[Wczoraj o] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[W zesz niedziel o] LT";

                  case 3:
                    return "[W zesz rod o] LT";

                  case 6:
                    return "[W zesz sobot o] LT";

                  default:
                    return "[W zeszy] dddd [o] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "%s temu",
            s: "kilka sekund",
            m: translate$7,
            mm: translate$7,
            h: translate$7,
            hh: translate$7,
            d: "1 dzie",
            dd: "%d dni",
            M: "miesic",
            MM: translate$7,
            y: "rok",
            yy: translate$7
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("pt-br", {
        months: "Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),
        monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
        weekdays: "Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado".split("_"),
        weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sb".split("_"),
        weekdaysMin: "Do_2_3_4_5_6_S".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY [s] HH:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm"
        },
        calendar: {
            sameDay: "[Hoje s] LT",
            nextDay: "[Amanh s] LT",
            nextWeek: "dddd [s] LT",
            lastDay: "[Ontem s] LT",
            lastWeek: function() {
                return 0 === this.day() || 6 === this.day() ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "em %s",
            past: "%s atrs",
            s: "poucos segundos",
            m: "um minuto",
            mm: "%d minutos",
            h: "uma hora",
            hh: "%d horas",
            d: "um dia",
            dd: "%d dias",
            M: "um ms",
            MM: "%d meses",
            y: "um ano",
            yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d"
    }), hooks.defineLocale("pt", {
        months: "Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),
        monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
        weekdays: "Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado".split("_"),
        weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sb".split("_"),
        weekdaysMin: "Do_2_3_4_5_6_S".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D [de] MMMM [de] YYYY",
            LLL: "D [de] MMMM [de] YYYY HH:mm",
            LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Hoje s] LT",
            nextDay: "[Amanh s] LT",
            nextWeek: "dddd [s] LT",
            lastDay: "[Ontem s] LT",
            lastWeek: function() {
                return 0 === this.day() || 6 === this.day() ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "em %s",
            past: "h %s",
            s: "segundos",
            m: "um minuto",
            mm: "%d minutos",
            h: "uma hora",
            hh: "%d horas",
            d: "um dia",
            dd: "%d dias",
            M: "um ms",
            MM: "%d meses",
            y: "um ano",
            yy: "%d anos"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("ro", {
        months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
        monthsShort: "ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
        monthsParseExact: !0,
        weekdays: "duminic_luni_mari_miercuri_joi_vineri_smbt".split("_"),
        weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sm".split("_"),
        weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_S".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY H:mm",
            LLLL: "dddd, D MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[azi la] LT",
            nextDay: "[mine la] LT",
            nextWeek: "dddd [la] LT",
            lastDay: "[ieri la] LT",
            lastWeek: "[fosta] dddd [la] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "peste %s",
            past: "%s n urm",
            s: "cteva secunde",
            m: "un minut",
            mm: relativeTimeWithPlural$2,
            h: "o or",
            hh: relativeTimeWithPlural$2,
            d: "o zi",
            dd: relativeTimeWithPlural$2,
            M: "o lun",
            MM: relativeTimeWithPlural$2,
            y: "un an",
            yy: relativeTimeWithPlural$2
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var monthsParse$2 = [ /^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i ];
    hooks.defineLocale("ru", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: {
            format: "._._._.____._._._._.".split("_"),
            standalone: "._.__.____._._._._.".split("_")
        },
        weekdays: {
            standalone: "______".split("_"),
            format: "______".split("_"),
            isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
        },
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        monthsParse: monthsParse$2,
        longMonthsParse: monthsParse$2,
        shortMonthsParse: monthsParse$2,
        monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
        monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
        monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY .",
            LLL: "D MMMM YYYY ., HH:mm",
            LLLL: "dddd, D MMMM YYYY ., HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            lastDay: "[ ] LT",
            nextWeek: function(now) {
                if (now.week() === this.week()) return 2 === this.day() ? "[] dddd [] LT" : "[] dddd [] LT";
                switch (this.day()) {
                  case 0:
                    return "[ ] dddd [] LT";

                  case 1:
                  case 2:
                  case 4:
                    return "[ ] dddd [] LT";

                  case 3:
                  case 5:
                  case 6:
                    return "[ ] dddd [] LT";
                }
            },
            lastWeek: function(now) {
                if (now.week() === this.week()) return 2 === this.day() ? "[] dddd [] LT" : "[] dddd [] LT";
                switch (this.day()) {
                  case 0:
                    return "[ ] dddd [] LT";

                  case 1:
                  case 2:
                  case 4:
                    return "[ ] dddd [] LT";

                  case 3:
                  case 5:
                  case 6:
                    return "[ ] dddd [] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            m: relativeTimeWithPlural$3,
            mm: relativeTimeWithPlural$3,
            h: "",
            hh: relativeTimeWithPlural$3,
            d: "",
            dd: relativeTimeWithPlural$3,
            M: "",
            MM: relativeTimeWithPlural$3,
            y: "",
            yy: relativeTimeWithPlural$3
        },
        meridiemParse: /|||/i,
        isPM: function(input) {
            return /^(|)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 12 ? "" : hour < 17 ? "" : "";
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
                return number + "-";

              case "D":
                return number + "-";

              case "w":
              case "W":
                return number + "-";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var months$6 = [ "", "", "", "", "", "", "", "", "", "", "", "" ], days$1 = [ "", "", "", "", "", "", "" ];
    hooks.defineLocale("sd", {
        months: months$6,
        monthsShort: months$6,
        weekdays: days$1,
        weekdaysShort: days$1,
        weekdaysMin: days$1,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd [  ] LT",
            lastDay: "[] LT",
            lastWeek: "[ ] dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/,/g, "");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("se", {
        months: "oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu".split("_"),
        monthsShort: "oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov".split("_"),
        weekdays: "sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat".split("_"),
        weekdaysShort: "sotn_vuos_ma_gask_duor_bear_lv".split("_"),
        weekdaysMin: "s_v_m_g_d_b_L".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "MMMM D. [b.] YYYY",
            LLL: "MMMM D. [b.] YYYY [ti.] HH:mm",
            LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm"
        },
        calendar: {
            sameDay: "[otne ti] LT",
            nextDay: "[ihttin ti] LT",
            nextWeek: "dddd [ti] LT",
            lastDay: "[ikte ti] LT",
            lastWeek: "[ovddit] dddd [ti] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s geaes",
            past: "mait %s",
            s: "moadde sekunddat",
            m: "okta minuhta",
            mm: "%d minuhtat",
            h: "okta diimmu",
            hh: "%d diimmut",
            d: "okta beaivi",
            dd: "%d beaivvit",
            M: "okta mnnu",
            MM: "%d mnut",
            y: "okta jahki",
            yy: "%d jagit"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("si", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "a h:mm",
            LTS: "a h:mm:ss",
            L: "YYYY/MM/DD",
            LL: "YYYY MMMM D",
            LLL: "YYYY MMMM D, a h:mm",
            LLLL: "YYYY MMMM D [] dddd, a h:mm:ss"
        },
        calendar: {
            sameDay: "[] LT[]",
            nextDay: "[] LT[]",
            nextWeek: "dddd LT[]",
            lastDay: "[] LT[]",
            lastWeek: "[] dddd LT[]",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s",
            past: "%s ",
            s: " ",
            m: "",
            mm: " %d",
            h: "",
            hh: " %d",
            d: "",
            dd: " %d",
            M: "",
            MM: " %d",
            y: "",
            yy: " %d"
        },
        dayOfMonthOrdinalParse: /\d{1,2} /,
        ordinal: function(number) {
            return number + " ";
        },
        meridiemParse: / | |.|../,
        isPM: function(input) {
            return ".." === input || " " === input;
        },
        meridiem: function(hours, minutes, isLower) {
            return hours > 11 ? isLower ? ".." : " " : isLower ? ".." : " ";
        }
    });
    var months$7 = "janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december".split("_"), monthsShort$4 = "jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec".split("_");
    hooks.defineLocale("sk", {
        months: months$7,
        monthsShort: monthsShort$4,
        weekdays: "nedea_pondelok_utorok_streda_tvrtok_piatok_sobota".split("_"),
        weekdaysShort: "ne_po_ut_st_t_pi_so".split("_"),
        weekdaysMin: "ne_po_ut_st_t_pi_so".split("_"),
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[dnes o] LT",
            nextDay: "[zajtra o] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v nedeu o] LT";

                  case 1:
                  case 2:
                    return "[v] dddd [o] LT";

                  case 3:
                    return "[v stredu o] LT";

                  case 4:
                    return "[vo tvrtok o] LT";

                  case 5:
                    return "[v piatok o] LT";

                  case 6:
                    return "[v sobotu o] LT";
                }
            },
            lastDay: "[vera o] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[minul nedeu o] LT";

                  case 1:
                  case 2:
                    return "[minul] dddd [o] LT";

                  case 3:
                    return "[minul stredu o] LT";

                  case 4:
                  case 5:
                    return "[minul] dddd [o] LT";

                  case 6:
                    return "[minul sobotu o] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "pred %s",
            s: translate$8,
            m: translate$8,
            mm: translate$8,
            h: translate$8,
            hh: translate$8,
            d: translate$8,
            dd: translate$8,
            M: translate$8,
            MM: translate$8,
            y: translate$8,
            yy: translate$8
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("sl", {
        months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
        monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
        monthsParseExact: !0,
        weekdays: "nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota".split("_"),
        weekdaysShort: "ned._pon._tor._sre._et._pet._sob.".split("_"),
        weekdaysMin: "ne_po_to_sr_e_pe_so".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danes ob] LT",
            nextDay: "[jutri ob] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[v] [nedeljo] [ob] LT";

                  case 3:
                    return "[v] [sredo] [ob] LT";

                  case 6:
                    return "[v] [soboto] [ob] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[v] dddd [ob] LT";
                }
            },
            lastDay: "[veraj ob] LT",
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[prejnjo] [nedeljo] [ob] LT";

                  case 3:
                    return "[prejnjo] [sredo] [ob] LT";

                  case 6:
                    return "[prejnjo] [soboto] [ob] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[prejnji] dddd [ob] LT";
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "ez %s",
            past: "pred %s",
            s: processRelativeTime$6,
            m: processRelativeTime$6,
            mm: processRelativeTime$6,
            h: processRelativeTime$6,
            hh: processRelativeTime$6,
            d: processRelativeTime$6,
            dd: processRelativeTime$6,
            M: processRelativeTime$6,
            MM: processRelativeTime$6,
            y: processRelativeTime$6,
            yy: processRelativeTime$6
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("sq", {
        months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor".split("_"),
        monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj".split("_"),
        weekdays: "E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun".split("_"),
        weekdaysShort: "Die_Hn_Mar_Mr_Enj_Pre_Sht".split("_"),
        weekdaysMin: "D_H_Ma_M_E_P_Sh".split("_"),
        weekdaysParseExact: !0,
        meridiemParse: /PD|MD/,
        isPM: function(input) {
            return "M" === input.charAt(0);
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 12 ? "PD" : "MD";
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Sot n] LT",
            nextDay: "[Nesr n] LT",
            nextWeek: "dddd [n] LT",
            lastDay: "[Dje n] LT",
            lastWeek: "dddd [e kaluar n] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "n %s",
            past: "%s m par",
            s: "disa sekonda",
            m: "nj minut",
            mm: "%d minuta",
            h: "nj or",
            hh: "%d or",
            d: "nj dit",
            dd: "%d dit",
            M: "nj muaj",
            MM: "%d muaj",
            y: "nj vit",
            yy: "%d vite"
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var translator$1 = {
        words: {
            m: [ " ", " " ],
            mm: [ "", "", "" ],
            h: [ " ", " " ],
            hh: [ "", "", "" ],
            dd: [ "", "", "" ],
            MM: [ "", "", "" ],
            yy: [ "", "", "" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = translator$1.words[key];
            return 1 === key.length ? withoutSuffix ? wordKey[0] : wordKey[1] : number + " " + translator$1.correctGrammaticalCase(number, wordKey);
        }
    };
    hooks.defineLocale("sr-cyrl", {
        months: "___________".split("_"),
        monthsShort: "._._._.____._._._._.".split("_"),
        monthsParseExact: !0,
        weekdays: "______".split("_"),
        weekdaysShort: "._._._._._._.".split("_"),
        weekdaysMin: "______".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[] [] [] LT";

                  case 3:
                    return "[] [] [] LT";

                  case 6:
                    return "[] [] [] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[] dddd [] LT";
                }
            },
            lastDay: "[ ] LT",
            lastWeek: function() {
                return [ "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT" ][this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: " %s",
            s: " ",
            m: translator$1.translate,
            mm: translator$1.translate,
            h: translator$1.translate,
            hh: translator$1.translate,
            d: "",
            dd: translator$1.translate,
            M: "",
            MM: translator$1.translate,
            y: "",
            yy: translator$1.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    });
    var translator$2 = {
        words: {
            m: [ "jedan minut", "jedne minute" ],
            mm: [ "minut", "minute", "minuta" ],
            h: [ "jedan sat", "jednog sata" ],
            hh: [ "sat", "sata", "sati" ],
            dd: [ "dan", "dana", "dana" ],
            MM: [ "mesec", "meseca", "meseci" ],
            yy: [ "godina", "godine", "godina" ]
        },
        correctGrammaticalCase: function(number, wordKey) {
            return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
        },
        translate: function(number, withoutSuffix, key) {
            var wordKey = translator$2.words[key];
            return 1 === key.length ? withoutSuffix ? wordKey[0] : wordKey[1] : number + " " + translator$2.correctGrammaticalCase(number, wordKey);
        }
    };
    hooks.defineLocale("sr", {
        months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
        monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
        monthsParseExact: !0,
        weekdays: "nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota".split("_"),
        weekdaysShort: "ned._pon._uto._sre._et._pet._sub.".split("_"),
        weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM YYYY",
            LLL: "D. MMMM YYYY H:mm",
            LLLL: "dddd, D. MMMM YYYY H:mm"
        },
        calendar: {
            sameDay: "[danas u] LT",
            nextDay: "[sutra u] LT",
            nextWeek: function() {
                switch (this.day()) {
                  case 0:
                    return "[u] [nedelju] [u] LT";

                  case 3:
                    return "[u] [sredu] [u] LT";

                  case 6:
                    return "[u] [subotu] [u] LT";

                  case 1:
                  case 2:
                  case 4:
                  case 5:
                    return "[u] dddd [u] LT";
                }
            },
            lastDay: "[jue u] LT",
            lastWeek: function() {
                return [ "[prole] [nedelje] [u] LT", "[prolog] [ponedeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT" ][this.day()];
            },
            sameElse: "L"
        },
        relativeTime: {
            future: "za %s",
            past: "pre %s",
            s: "nekoliko sekundi",
            m: translator$2.translate,
            mm: translator$2.translate,
            h: translator$2.translate,
            hh: translator$2.translate,
            d: "dan",
            dd: translator$2.translate,
            M: "mesec",
            MM: translator$2.translate,
            y: "godinu",
            yy: translator$2.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("ss", {
        months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),
        monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
        weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),
        weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
        weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Namuhla nga] LT",
            nextDay: "[Kusasa nga] LT",
            nextWeek: "dddd [nga] LT",
            lastDay: "[Itolo nga] LT",
            lastWeek: "dddd [leliphelile] [nga] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "nga %s",
            past: "wenteka nga %s",
            s: "emizuzwana lomcane",
            m: "umzuzu",
            mm: "%d emizuzu",
            h: "lihora",
            hh: "%d emahora",
            d: "lilanga",
            dd: "%d emalanga",
            M: "inyanga",
            MM: "%d tinyanga",
            y: "umnyaka",
            yy: "%d iminyaka"
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem: function(hours, minutes, isLower) {
            return hours < 11 ? "ekuseni" : hours < 15 ? "emini" : hours < 19 ? "entsambama" : "ebusuku";
        },
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "ekuseni" === meridiem ? hour : "emini" === meridiem ? hour >= 11 ? hour : hour + 12 : "entsambama" === meridiem || "ebusuku" === meridiem ? 0 === hour ? 0 : hour + 12 : void 0;
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("sv", {
        months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
        weekdays: "sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag".split("_"),
        weekdaysShort: "sn_mn_tis_ons_tor_fre_lr".split("_"),
        weekdaysMin: "s_m_ti_on_to_fr_l".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYY-MM-DD",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY [kl.] HH:mm",
            LLLL: "dddd D MMMM YYYY [kl.] HH:mm",
            lll: "D MMM YYYY HH:mm",
            llll: "ddd D MMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Idag] LT",
            nextDay: "[Imorgon] LT",
            lastDay: "[Igr] LT",
            nextWeek: "[P] dddd LT",
            lastWeek: "[I] dddd[s] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "om %s",
            past: "fr %s sedan",
            s: "ngra sekunder",
            m: "en minut",
            mm: "%d minuter",
            h: "en timme",
            hh: "%d timmar",
            d: "en dag",
            dd: "%d dagar",
            M: "en mnad",
            MM: "%d mnader",
            y: "ett r",
            yy: "%d r"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 == ~~(number % 100 / 10) ? "e" : 1 === b ? "a" : 2 === b ? "a" : "e");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("sw", {
        months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),
        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
        weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),
        weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
        weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[leo saa] LT",
            nextDay: "[kesho saa] LT",
            nextWeek: "[wiki ijayo] dddd [saat] LT",
            lastDay: "[jana] LT",
            lastWeek: "[wiki iliyopita] dddd [saat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s baadaye",
            past: "tokea %s",
            s: "hivi punde",
            m: "dakika moja",
            mm: "dakika %d",
            h: "saa limoja",
            hh: "masaa %d",
            d: "siku moja",
            dd: "masiku %d",
            M: "mwezi mmoja",
            MM: "miezi %d",
            y: "mwaka mmoja",
            yy: "miaka %d"
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var symbolMap$12 = {
        1: "",
        2: "",
        3: "",
        4: "",
        5: "",
        6: "",
        7: "",
        8: "",
        9: "",
        0: ""
    }, numberMap$11 = {
        "": "1",
        "": "2",
        "": "3",
        "": "4",
        "": "5",
        "": "6",
        "": "7",
        "": "8",
        "": "9",
        "": "0"
    };
    hooks.defineLocale("ta", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, HH:mm",
            LLLL: "dddd, D MMMM YYYY, HH:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[ ] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: "  ",
            m: " ",
            mm: "%d ",
            h: "  ",
            hh: "%d  ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number + "";
        },
        preparse: function(string) {
            return string.replace(/[]/g, function(match) {
                return numberMap$11[match];
            });
        },
        postformat: function(string) {
            return string.replace(/\d/g, function(match) {
                return symbolMap$12[match];
            });
        },
        meridiemParse: /|||||/,
        meridiem: function(hour, minute, isLower) {
            return hour < 2 ? " " : hour < 6 ? " " : hour < 10 ? " " : hour < 14 ? " " : hour < 18 ? " " : hour < 22 ? " " : " ";
        },
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem ? hour < 2 ? hour : hour + 12 : "" === meridiem || "" === meridiem ? hour : "" === meridiem && hour >= 10 ? hour : hour + 12;
        },
        week: {
            dow: 0,
            doy: 6
        }
    }), hooks.defineLocale("te", {
        months: "___________".split("_"),
        monthsShort: "._.__.____._._._._.".split("_"),
        monthsParseExact: !0,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "A h:mm",
            LTS: "A h:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY, A h:mm",
            LLLL: "dddd, D MMMM YYYY, A h:mm"
        },
        calendar: {
            sameDay: "[] LT",
            nextDay: "[] LT",
            nextWeek: "dddd, LT",
            lastDay: "[] LT",
            lastWeek: "[] dddd, LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: "%d",
        meridiemParse: /|||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem ? hour < 4 ? hour : hour + 12 : "" === meridiem ? hour : "" === meridiem ? hour >= 10 ? hour : hour + 12 : "" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 10 ? "" : hour < 17 ? "" : hour < 20 ? "" : "";
        },
        week: {
            dow: 0,
            doy: 6
        }
    }), hooks.defineLocale("tet", {
        months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru".split("_"),
        monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez".split("_"),
        weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu".split("_"),
        weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sext_Sab".split("_"),
        weekdaysMin: "Do_Seg_Te_Ku_Ki_Sex_Sa".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Ohin iha] LT",
            nextDay: "[Aban iha] LT",
            nextWeek: "dddd [iha] LT",
            lastDay: "[Horiseik iha] LT",
            lastWeek: "dddd [semana kotuk] [iha] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "iha %s",
            past: "%s liuba",
            s: "minutu balun",
            m: "minutu ida",
            mm: "minutus %d",
            h: "horas ida",
            hh: "horas %d",
            d: "loron ida",
            dd: "loron %d",
            M: "fulan ida",
            MM: "fulan %d",
            y: "tinan ida",
            yy: "tinan %d"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("th", {
        months: "___________".split("_"),
        monthsShort: ".._.._.._.._.._.._.._.._.._.._.._..".split("_"),
        monthsParseExact: !0,
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "._._._._._._.".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "H:mm",
            LTS: "H:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY  H:mm",
            LLLL: "dddd D MMMM YYYY  H:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd[ ] LT",
            lastDay: "[ ] LT",
            lastWeek: "[]dddd[ ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s",
            s: "",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        }
    }), hooks.defineLocale("tl-ph", {
        months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
        monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
        weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
        weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
        weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "MM/D/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY HH:mm",
            LLLL: "dddd, MMMM DD, YYYY HH:mm"
        },
        calendar: {
            sameDay: "LT [ngayong araw]",
            nextDay: "[Bukas ng] LT",
            nextWeek: "LT [sa susunod na] dddd",
            lastDay: "LT [kahapon]",
            lastWeek: "LT [noong nakaraang] dddd",
            sameElse: "L"
        },
        relativeTime: {
            future: "sa loob ng %s",
            past: "%s ang nakalipas",
            s: "ilang segundo",
            m: "isang minuto",
            mm: "%d minuto",
            h: "isang oras",
            hh: "%d oras",
            d: "isang araw",
            dd: "%d araw",
            M: "isang buwan",
            MM: "%d buwan",
            y: "isang taon",
            yy: "%d taon"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number;
        },
        week: {
            dow: 1,
            doy: 4
        }
    });
    var numbersNouns = "pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
    hooks.defineLocale("tlh", {
        months: "tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha".split("_"),
        monthsShort: "jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha".split("_"),
        monthsParseExact: !0,
        weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
        weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
        weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[DaHjaj] LT",
            nextDay: "[waleS] LT",
            nextWeek: "LLL",
            lastDay: "[waHu] LT",
            lastWeek: "LLL",
            sameElse: "L"
        },
        relativeTime: {
            future: translateFuture,
            past: translatePast,
            s: "puS lup",
            m: "wa tup",
            mm: translate$9,
            h: "wa rep",
            hh: translate$9,
            d: "wa jaj",
            dd: translate$9,
            M: "wa jar",
            MM: translate$9,
            y: "wa DIS",
            yy: translate$9
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    });
    var suffixes$3 = {
        1: "'inci",
        5: "'inci",
        8: "'inci",
        70: "'inci",
        80: "'inci",
        2: "'nci",
        7: "'nci",
        20: "'nci",
        50: "'nci",
        3: "'nc",
        4: "'nc",
        100: "'nc",
        6: "'nc",
        9: "'uncu",
        10: "'uncu",
        30: "'uncu",
        60: "'nc",
        90: "'nc"
    };
    hooks.defineLocale("tr", {
        months: "Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk".split("_"),
        monthsShort: "Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara".split("_"),
        weekdays: "Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi".split("_"),
        weekdaysShort: "Paz_Pts_Sal_ar_Per_Cum_Cts".split("_"),
        weekdaysMin: "Pz_Pt_Sa_a_Pe_Cu_Ct".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[bugn saat] LT",
            nextDay: "[yarn saat] LT",
            nextWeek: "[haftaya] dddd [saat] LT",
            lastDay: "[dn] LT",
            lastWeek: "[geen hafta] dddd [saat] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s sonra",
            past: "%s nce",
            s: "birka saniye",
            m: "bir dakika",
            mm: "%d dakika",
            h: "bir saat",
            hh: "%d saat",
            d: "bir gn",
            dd: "%d gn",
            M: "bir ay",
            MM: "%d ay",
            y: "bir yl",
            yy: "%d yl"
        },
        dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
        ordinal: function(number) {
            if (0 === number) return number + "'nc";
            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
            return number + (suffixes$3[a] || suffixes$3[b] || suffixes$3[c]);
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("tzl", {
        months: "Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar".split("_"),
        monthsShort: "Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
        weekdays: "Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi".split("_"),
        weekdaysShort: "Sl_Ln_Mai_Mr_Xh_Vi_St".split("_"),
        weekdaysMin: "S_L_Ma_M_Xh_Vi_S".split("_"),
        longDateFormat: {
            LT: "HH.mm",
            LTS: "HH.mm.ss",
            L: "DD.MM.YYYY",
            LL: "D. MMMM [dallas] YYYY",
            LLL: "D. MMMM [dallas] YYYY HH.mm",
            LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm"
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM: function(input) {
            return "d'o" === input.toLowerCase();
        },
        meridiem: function(hours, minutes, isLower) {
            return hours > 11 ? isLower ? "d'o" : "D'O" : isLower ? "d'a" : "D'A";
        },
        calendar: {
            sameDay: "[oxhi ] LT",
            nextDay: "[dem ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ieiri ] LT",
            lastWeek: "[sr el] dddd [lasteu ] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "osprei %s",
            past: "ja%s",
            s: processRelativeTime$7,
            m: processRelativeTime$7,
            mm: processRelativeTime$7,
            h: processRelativeTime$7,
            hh: processRelativeTime$7,
            d: processRelativeTime$7,
            dd: processRelativeTime$7,
            M: processRelativeTime$7,
            MM: processRelativeTime$7,
            y: processRelativeTime$7,
            yy: processRelativeTime$7
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: "%d.",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("tzm-latn", {
        months: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"),
        monthsShort: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"),
        weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
        weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
        weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[asdkh g] LT",
            nextDay: "[aska g] LT",
            nextWeek: "dddd [g] LT",
            lastDay: "[assant g] LT",
            lastWeek: "dddd [g] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "dadkh s yan %s",
            past: "yan %s",
            s: "imik",
            m: "minu",
            mm: "%d minu",
            h: "saa",
            hh: "%d tassain",
            d: "ass",
            dd: "%d ossan",
            M: "ayowr",
            MM: "%d iyyirn",
            y: "asgas",
            yy: "%d isgasn"
        },
        week: {
            dow: 6,
            doy: 12
        }
    }), hooks.defineLocale("tzm", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[ ] LT",
            lastWeek: "dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "   %s",
            past: " %s",
            s: "",
            m: "",
            mm: "%d ",
            h: "",
            hh: "%d ",
            d: "",
            dd: "%d o",
            M: "o",
            MM: "%d ",
            y: "",
            yy: "%d "
        },
        week: {
            dow: 6,
            doy: 12
        }
    }), hooks.defineLocale("uk", {
        months: {
            format: "___________".split("_"),
            standalone: "___________".split("_")
        },
        monthsShort: "___________".split("_"),
        weekdays: weekdaysCaseReplace,
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD.MM.YYYY",
            LL: "D MMMM YYYY .",
            LLL: "D MMMM YYYY ., HH:mm",
            LLLL: "dddd, D MMMM YYYY ., HH:mm"
        },
        calendar: {
            sameDay: processHoursFunction("[ "),
            nextDay: processHoursFunction("[ "),
            lastDay: processHoursFunction("[ "),
            nextWeek: processHoursFunction("[] dddd ["),
            lastWeek: function() {
                switch (this.day()) {
                  case 0:
                  case 3:
                  case 5:
                  case 6:
                    return processHoursFunction("[] dddd [").call(this);

                  case 1:
                  case 2:
                  case 4:
                    return processHoursFunction("[] dddd [").call(this);
                }
            },
            sameElse: "L"
        },
        relativeTime: {
            future: " %s",
            past: "%s ",
            s: " ",
            m: relativeTimeWithPlural$4,
            mm: relativeTimeWithPlural$4,
            h: "",
            hh: relativeTimeWithPlural$4,
            d: "",
            dd: relativeTimeWithPlural$4,
            M: "",
            MM: relativeTimeWithPlural$4,
            y: "",
            yy: relativeTimeWithPlural$4
        },
        meridiemParse: /|||/,
        isPM: function(input) {
            return /^(|)$/.test(input);
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 4 ? "" : hour < 12 ? "" : hour < 17 ? "" : "";
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function(number, period) {
            switch (period) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return number + "-";

              case "D":
                return number + "-";

              default:
                return number;
            }
        },
        week: {
            dow: 1,
            doy: 7
        }
    });
    var months$8 = [ "", "", "", "", "", "", "", "", "", "", "", "" ], days$2 = [ "", "", "", "", "", "", "" ];
    return hooks.defineLocale("ur", {
        months: months$8,
        monthsShort: months$8,
        weekdays: days$2,
        weekdaysShort: days$2,
        weekdaysMin: days$2,
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd D MMMM YYYY HH:mm"
        },
        meridiemParse: /|/,
        isPM: function(input) {
            return "" === input;
        },
        meridiem: function(hour, minute, isLower) {
            return hour < 12 ? "" : "";
        },
        calendar: {
            sameDay: "[ ] LT",
            nextDay: "[ ] LT",
            nextWeek: "dddd [] LT",
            lastDay: "[  ] LT",
            lastWeek: "[] dddd [] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ",
            past: "%s ",
            s: " ",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        preparse: function(string) {
            return string.replace(//g, ",");
        },
        postformat: function(string) {
            return string.replace(/,/g, "");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("uz-latn", {
        months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),
        monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
        weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),
        weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
        weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "D MMMM YYYY, dddd HH:mm"
        },
        calendar: {
            sameDay: "[Bugun soat] LT [da]",
            nextDay: "[Ertaga] LT [da]",
            nextWeek: "dddd [kuni soat] LT [da]",
            lastDay: "[Kecha soat] LT [da]",
            lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
            sameElse: "L"
        },
        relativeTime: {
            future: "Yaqin %s ichida",
            past: "Bir necha %s oldin",
            s: "soniya",
            m: "bir daqiqa",
            mm: "%d daqiqa",
            h: "bir soat",
            hh: "%d soat",
            d: "bir kun",
            dd: "%d kun",
            M: "bir oy",
            MM: "%d oy",
            y: "bir yil",
            yy: "%d yil"
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("uz", {
        months: "___________".split("_"),
        monthsShort: "___________".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "D MMMM YYYY, dddd HH:mm"
        },
        calendar: {
            sameDay: "[ ] LT []",
            nextDay: "[] LT []",
            nextWeek: "dddd [ ] LT []",
            lastDay: "[ ] LT []",
            lastWeek: "[] dddd [ ] LT []",
            sameElse: "L"
        },
        relativeTime: {
            future: " %s ",
            past: "  %s ",
            s: "",
            m: " ",
            mm: "%d ",
            h: " ",
            hh: "%d ",
            d: " ",
            dd: "%d ",
            M: " ",
            MM: "%d ",
            y: " ",
            yy: "%d "
        },
        week: {
            dow: 1,
            doy: 7
        }
    }), hooks.defineLocale("vi", {
        months: "thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12".split("_"),
        monthsShort: "Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"),
        monthsParseExact: !0,
        weekdays: "ch nht_th hai_th ba_th t_th nm_th su_th by".split("_"),
        weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
        weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
        weekdaysParseExact: !0,
        meridiemParse: /sa|ch/i,
        isPM: function(input) {
            return /^ch$/i.test(input);
        },
        meridiem: function(hours, minutes, isLower) {
            return hours < 12 ? isLower ? "sa" : "SA" : isLower ? "ch" : "CH";
        },
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "DD/MM/YYYY",
            LL: "D MMMM [nm] YYYY",
            LLL: "D MMMM [nm] YYYY HH:mm",
            LLLL: "dddd, D MMMM [nm] YYYY HH:mm",
            l: "DD/M/YYYY",
            ll: "D MMM YYYY",
            lll: "D MMM YYYY HH:mm",
            llll: "ddd, D MMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[Hm nay lc] LT",
            nextDay: "[Ngy mai lc] LT",
            nextWeek: "dddd [tun ti lc] LT",
            lastDay: "[Hm qua lc] LT",
            lastWeek: "dddd [tun ri lc] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "%s ti",
            past: "%s trc",
            s: "vi giy",
            m: "mt pht",
            mm: "%d pht",
            h: "mt gi",
            hh: "%d gi",
            d: "mt ngy",
            dd: "%d ngy",
            M: "mt thng",
            MM: "%d thng",
            y: "mt nm",
            yy: "%d nm"
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function(number) {
            return number;
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("x-pseudo", {
        months: "J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr".split("_"),
        monthsShort: "J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc".split("_"),
        monthsParseExact: !0,
        weekdays: "S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d".split("_"),
        weekdaysShort: "S~_~M_~T_~Wd_~Th_~Fr_~St".split("_"),
        weekdaysMin: "S~_M~_T_~W_T~h_Fr~_S".split("_"),
        weekdaysParseExact: !0,
        longDateFormat: {
            LT: "HH:mm",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY HH:mm",
            LLLL: "dddd, D MMMM YYYY HH:mm"
        },
        calendar: {
            sameDay: "[T~d~ t] LT",
            nextDay: "[T~m~rr~w t] LT",
            nextWeek: "dddd [t] LT",
            lastDay: "[~st~rd~ t] LT",
            lastWeek: "[L~st] dddd [t] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "~ %s",
            past: "%s ~g",
            s: " ~fw ~sc~ds",
            m: " ~m~t",
            mm: "%d m~~ts",
            h: "~ h~r",
            hh: "%d h~rs",
            d: " ~d",
            dd: "%d d~s",
            M: " ~m~th",
            MM: "%d m~t~hs",
            y: " ~r",
            yy: "%d ~rs"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10;
            return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("yo", {
        months: "Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p".split("_"),
        monthsShort: "Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p".split("_"),
        weekdays: "Aiku_Aje_Isgun_jru_jb_ti_Abamta".split("_"),
        weekdaysShort: "Aik_Aje_Is_jr_jb_ti_Aba".split("_"),
        weekdaysMin: "Ai_Aj_Is_r_b_t_Ab".split("_"),
        longDateFormat: {
            LT: "h:mm A",
            LTS: "h:mm:ss A",
            L: "DD/MM/YYYY",
            LL: "D MMMM YYYY",
            LLL: "D MMMM YYYY h:mm A",
            LLLL: "dddd, D MMMM YYYY h:mm A"
        },
        calendar: {
            sameDay: "[Oni ni] LT",
            nextDay: "[la ni] LT",
            nextWeek: "dddd [s ton'b] [ni] LT",
            lastDay: "[Ana ni] LT",
            lastWeek: "dddd [s tol] [ni] LT",
            sameElse: "L"
        },
        relativeTime: {
            future: "ni %s",
            past: "%s kja",
            s: "isju aaya die",
            m: "isju kan",
            mm: "isju %d",
            h: "wakati kan",
            hh: "wakati %d",
            d: "j kan",
            dd: "j %d",
            M: "osu kan",
            MM: "osu %d",
            y: "dun kan",
            yy: "dun %d"
        },
        dayOfMonthOrdinalParse: /j\s\d{1,2}/,
        ordinal: "j %d",
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("zh-cn", {
        months: "___________".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYYMMMD",
            LL: "YYYYMMMD",
            LLL: "YYYYMMMDAhmm",
            LLLL: "YYYYMMMDddddAhmm",
            l: "YYYYMMMD",
            ll: "YYYYMMMD",
            lll: "YYYYMMMD HH:mm",
            llll: "YYYYMMMDdddd HH:mm"
        },
        meridiemParse: /|||||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem || "" === meridiem || "" === meridiem ? hour : "" === meridiem || "" === meridiem ? hour + 12 : hour >= 11 ? hour : hour + 12;
        },
        meridiem: function(hour, minute, isLower) {
            var hm = 100 * hour + minute;
            return hm < 600 ? "" : hm < 900 ? "" : hm < 1130 ? "" : hm < 1230 ? "" : hm < 1800 ? "" : "";
        },
        calendar: {
            sameDay: "[]LT",
            nextDay: "[]LT",
            nextWeek: "[]ddddLT",
            lastDay: "[]LT",
            lastWeek: "[]ddddLT",
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              case "M":
                return number + "";

              case "w":
              case "W":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        },
        week: {
            dow: 1,
            doy: 4
        }
    }), hooks.defineLocale("zh-hk", {
        months: "___________".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYYMMMD",
            LL: "YYYYMMMD",
            LLL: "YYYYMMMD HH:mm",
            LLLL: "YYYYMMMDdddd HH:mm",
            l: "YYYYMMMD",
            ll: "YYYYMMMD",
            lll: "YYYYMMMD HH:mm",
            llll: "YYYYMMMDdddd HH:mm"
        },
        meridiemParse: /|||||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem || "" === meridiem || "" === meridiem ? hour : "" === meridiem ? hour >= 11 ? hour : hour + 12 : "" === meridiem || "" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            var hm = 100 * hour + minute;
            return hm < 600 ? "" : hm < 900 ? "" : hm < 1130 ? "" : hm < 1230 ? "" : hm < 1800 ? "" : "";
        },
        calendar: {
            sameDay: "[]LT",
            nextDay: "[]LT",
            nextWeek: "[]ddddLT",
            lastDay: "[]LT",
            lastWeek: "[]ddddLT",
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              case "M":
                return number + "";

              case "w":
              case "W":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        }
    }), hooks.defineLocale("zh-tw", {
        months: "___________".split("_"),
        monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
        weekdays: "______".split("_"),
        weekdaysShort: "______".split("_"),
        weekdaysMin: "______".split("_"),
        longDateFormat: {
            LT: "HH:mm",
            LTS: "HH:mm:ss",
            L: "YYYYMMMD",
            LL: "YYYYMMMD",
            LLL: "YYYYMMMD HH:mm",
            LLLL: "YYYYMMMDdddd HH:mm",
            l: "YYYYMMMD",
            ll: "YYYYMMMD",
            lll: "YYYYMMMD HH:mm",
            llll: "YYYYMMMDdddd HH:mm"
        },
        meridiemParse: /|||||/,
        meridiemHour: function(hour, meridiem) {
            return 12 === hour && (hour = 0), "" === meridiem || "" === meridiem || "" === meridiem ? hour : "" === meridiem ? hour >= 11 ? hour : hour + 12 : "" === meridiem || "" === meridiem ? hour + 12 : void 0;
        },
        meridiem: function(hour, minute, isLower) {
            var hm = 100 * hour + minute;
            return hm < 600 ? "" : hm < 900 ? "" : hm < 1130 ? "" : hm < 1230 ? "" : hm < 1800 ? "" : "";
        },
        calendar: {
            sameDay: "[]LT",
            nextDay: "[]LT",
            nextWeek: "[]ddddLT",
            lastDay: "[]LT",
            lastWeek: "[]ddddLT",
            sameElse: "L"
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal: function(number, period) {
            switch (period) {
              case "d":
              case "D":
              case "DDD":
                return number + "";

              case "M":
                return number + "";

              case "w":
              case "W":
                return number + "";

              default:
                return number;
            }
        },
        relativeTime: {
            future: "%s",
            past: "%s",
            s: "",
            m: "1 ",
            mm: "%d ",
            h: "1 ",
            hh: "%d ",
            d: "1 ",
            dd: "%d ",
            M: "1 ",
            MM: "%d ",
            y: "1 ",
            yy: "%d "
        }
    }), hooks.locale("en"), hooks;
}), function() {
    "use strict";
    function isUndefinedOrNull(val) {
        return angular.isUndefined(val) || null === val;
    }
    function requireMoment() {
        try {
            return require("moment");
        } catch (e) {
            throw new Error("Please install moment via npm. Please reference to: https://github.com/urish/angular-moment");
        }
    }
    function angularMoment(a, moment) {
        if (void 0 === moment) {
            if ("function" != typeof require) throw new Error("Moment cannot be found by angular-moment! Please reference to: https://github.com/urish/angular-moment");
            moment = requireMoment();
        }
        return angular.module("angularMoment", []).constant("angularMomentConfig", {
            preprocess: null,
            timezone: null,
            format: null,
            statefulFilters: !0
        }).constant("moment", moment).constant("amTimeAgoConfig", {
            withoutSuffix: !1,
            serverTime: null,
            titleFormat: null,
            fullDateThreshold: null,
            fullDateFormat: null,
            fullDateThresholdUnit: "day"
        }).directive("amTimeAgo", [ "$window", "moment", "amMoment", "amTimeAgoConfig", function($window, moment, amMoment, amTimeAgoConfig) {
            return function(scope, element, attr) {
                function getNow() {
                    var now;
                    if (currentFrom) now = currentFrom; else if (amTimeAgoConfig.serverTime) {
                        var localNow = new Date().getTime(), nowMillis = localNow - localDate + amTimeAgoConfig.serverTime;
                        now = moment(nowMillis);
                    } else now = moment();
                    return now;
                }
                function cancelTimer() {
                    activeTimeout && ($window.clearTimeout(activeTimeout), activeTimeout = null);
                }
                function updateTime(momentInstance) {
                    var timeAgo = getNow().diff(momentInstance, fullDateThresholdUnit), showFullDate = fullDateThreshold && timeAgo >= fullDateThreshold;
                    if (showFullDate ? element.text(momentInstance.format(fullDateFormat)) : element.text(momentInstance.from(getNow(), withoutSuffix)), 
                    titleFormat && setTitleTime && element.attr("title", momentInstance.format(titleFormat)), 
                    !showFullDate) {
                        var howOld = Math.abs(getNow().diff(momentInstance, "minute")), secondsUntilUpdate = 3600;
                        howOld < 1 ? secondsUntilUpdate = 1 : howOld < 60 ? secondsUntilUpdate = 30 : howOld < 180 && (secondsUntilUpdate = 300), 
                        activeTimeout = $window.setTimeout(function() {
                            updateTime(momentInstance);
                        }, 1e3 * secondsUntilUpdate);
                    }
                }
                function updateDateTimeAttr(value) {
                    isTimeElement && element.attr("datetime", value);
                }
                function updateMoment() {
                    if (cancelTimer(), currentValue) {
                        var momentValue = amMoment.preprocessDate(currentValue);
                        updateTime(momentValue), updateDateTimeAttr(momentValue.toISOString());
                    }
                }
                var currentValue, currentFrom, activeTimeout = null, withoutSuffix = amTimeAgoConfig.withoutSuffix, titleFormat = amTimeAgoConfig.titleFormat, fullDateThreshold = amTimeAgoConfig.fullDateThreshold, fullDateFormat = amTimeAgoConfig.fullDateFormat, fullDateThresholdUnit = amTimeAgoConfig.fullDateThresholdUnit, localDate = new Date().getTime(), modelName = attr.amTimeAgo, isTimeElement = "TIME" === element[0].nodeName.toUpperCase(), setTitleTime = !element.attr("title");
                scope.$watch(modelName, function(value) {
                    return isUndefinedOrNull(value) || "" === value ? (cancelTimer(), void (currentValue && (element.text(""), 
                    updateDateTimeAttr(""), currentValue = null))) : (currentValue = value, void updateMoment());
                }), angular.isDefined(attr.amFrom) && scope.$watch(attr.amFrom, function(value) {
                    currentFrom = isUndefinedOrNull(value) || "" === value ? null : moment(value), updateMoment();
                }), angular.isDefined(attr.amWithoutSuffix) && scope.$watch(attr.amWithoutSuffix, function(value) {
                    "boolean" == typeof value ? (withoutSuffix = value, updateMoment()) : withoutSuffix = amTimeAgoConfig.withoutSuffix;
                }), attr.$observe("amFullDateThreshold", function(newValue) {
                    fullDateThreshold = newValue, updateMoment();
                }), attr.$observe("amFullDateFormat", function(newValue) {
                    fullDateFormat = newValue, updateMoment();
                }), attr.$observe("amFullDateThresholdUnit", function(newValue) {
                    fullDateThresholdUnit = newValue, updateMoment();
                }), scope.$on("$destroy", function() {
                    cancelTimer();
                }), scope.$on("amMoment:localeChanged", function() {
                    updateMoment();
                });
            };
        } ]).service("amMoment", [ "moment", "$rootScope", "$log", "angularMomentConfig", function(moment, $rootScope, $log, angularMomentConfig) {
            var defaultTimezone = null;
            this.changeLocale = function(locale, customization) {
                var result = moment.locale(locale, customization);
                return angular.isDefined(locale) && $rootScope.$broadcast("amMoment:localeChanged"), 
                result;
            }, this.changeTimezone = function(timezone) {
                moment.tz && moment.tz.setDefault ? (moment.tz.setDefault(timezone), $rootScope.$broadcast("amMoment:timezoneChanged")) : $log.warn("angular-moment: changeTimezone() works only with moment-timezone.js v0.3.0 or greater."), 
                angularMomentConfig.timezone = timezone, defaultTimezone = timezone;
            }, this.preprocessDate = function(value) {
                return defaultTimezone !== angularMomentConfig.timezone && this.changeTimezone(angularMomentConfig.timezone), 
                angularMomentConfig.preprocess ? angularMomentConfig.preprocess(value) : moment(!isNaN(parseFloat(value)) && isFinite(value) ? parseInt(value, 10) : value);
            };
        } ]).filter("amParse", [ "moment", function(moment) {
            return function(value, format) {
                return moment(value, format);
            };
        } ]).filter("amFromUnix", [ "moment", function(moment) {
            return function(value) {
                return moment.unix(value);
            };
        } ]).filter("amUtc", [ "moment", function(moment) {
            return function(value) {
                return moment.utc(value);
            };
        } ]).filter("amUtcOffset", [ "amMoment", function(amMoment) {
            function amUtcOffset(value, offset) {
                return amMoment.preprocessDate(value).utcOffset(offset);
            }
            return amUtcOffset;
        } ]).filter("amLocal", [ "moment", function(moment) {
            return function(value) {
                return moment.isMoment(value) ? value.local() : null;
            };
        } ]).filter("amTimezone", [ "amMoment", "angularMomentConfig", "$log", function(amMoment, angularMomentConfig, $log) {
            function amTimezone(value, timezone) {
                var aMoment = amMoment.preprocessDate(value);
                return timezone ? aMoment.tz ? aMoment.tz(timezone) : ($log.warn("angular-moment: named timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js ?"), 
                aMoment) : aMoment;
            }
            return amTimezone;
        } ]).filter("amCalendar", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amCalendarFilter(value, referenceTime, formats) {
                if (isUndefinedOrNull(value)) return "";
                var date = amMoment.preprocessDate(value);
                return date.isValid() ? date.calendar(referenceTime, formats) : "";
            }
            return amCalendarFilter.$stateful = angularMomentConfig.statefulFilters, amCalendarFilter;
        } ]).filter("amDifference", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDifferenceFilter(value, otherValue, unit, usePrecision) {
                if (isUndefinedOrNull(value)) return "";
                var date = amMoment.preprocessDate(value), date2 = isUndefinedOrNull(otherValue) ? moment() : amMoment.preprocessDate(otherValue);
                return date.isValid() && date2.isValid() ? date.diff(date2, unit, usePrecision) : "";
            }
            return amDifferenceFilter.$stateful = angularMomentConfig.statefulFilters, amDifferenceFilter;
        } ]).filter("amDateFormat", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amDateFormatFilter(value, format) {
                if (isUndefinedOrNull(value)) return "";
                var date = amMoment.preprocessDate(value);
                return date.isValid() ? date.format(format) : "";
            }
            return amDateFormatFilter.$stateful = angularMomentConfig.statefulFilters, amDateFormatFilter;
        } ]).filter("amDurationFormat", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amDurationFormatFilter(value, format, suffix) {
                return isUndefinedOrNull(value) ? "" : moment.duration(value, format).humanize(suffix);
            }
            return amDurationFormatFilter.$stateful = angularMomentConfig.statefulFilters, amDurationFormatFilter;
        } ]).filter("amTimeAgo", [ "moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
            function amTimeAgoFilter(value, suffix, from) {
                var date, dateFrom;
                return isUndefinedOrNull(value) ? "" : (value = amMoment.preprocessDate(value), 
                date = moment(value), date.isValid() ? (dateFrom = moment(from), !isUndefinedOrNull(from) && dateFrom.isValid() ? date.from(dateFrom, suffix) : date.fromNow(suffix)) : "");
            }
            return amTimeAgoFilter.$stateful = angularMomentConfig.statefulFilters, amTimeAgoFilter;
        } ]).filter("amSubtract", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amSubtractFilter(value, amount, type) {
                return isUndefinedOrNull(value) ? "" : moment(value).subtract(parseInt(amount, 10), type);
            }
            return amSubtractFilter.$stateful = angularMomentConfig.statefulFilters, amSubtractFilter;
        } ]).filter("amAdd", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amAddFilter(value, amount, type) {
                return isUndefinedOrNull(value) ? "" : moment(value).add(parseInt(amount, 10), type);
            }
            return amAddFilter.$stateful = angularMomentConfig.statefulFilters, amAddFilter;
        } ]).filter("amStartOf", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amStartOfFilter(value, type) {
                return isUndefinedOrNull(value) ? "" : moment(value).startOf(type);
            }
            return amStartOfFilter.$stateful = angularMomentConfig.statefulFilters, amStartOfFilter;
        } ]).filter("amEndOf", [ "moment", "angularMomentConfig", function(moment, angularMomentConfig) {
            function amEndOfFilter(value, type) {
                return isUndefinedOrNull(value) ? "" : moment(value).endOf(type);
            }
            return amEndOfFilter.$stateful = angularMomentConfig.statefulFilters, amEndOfFilter;
        } ]), "angularMoment";
    }
    var isElectron = window && window.process && window.process.type;
    "function" == typeof define && define.amd ? define("angular-moment", [ "angular", "moment" ], angularMoment) : "undefined" != typeof module && module && module.exports && "function" == typeof require && !isElectron ? module.exports = angularMoment(require("angular"), require("moment")) : angularMoment(angular, ("undefined" != typeof global ? global : window).moment);
}(), function(window, angular) {
    "use strict";
    function $SanitizeProvider() {
        function toMap(str, lowercaseKeys) {
            var i, obj = {}, items = str.split(",");
            for (i = 0; i < items.length; i++) obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = !0;
            return obj;
        }
        function htmlParserImpl(html, handler) {
            null === html || void 0 === html ? html = "" : "string" != typeof html && (html = "" + html);
            var inertBodyElement = getInertBodyElement(html);
            if (!inertBodyElement) return "";
            var mXSSAttempts = 5;
            do {
                if (0 === mXSSAttempts) throw $sanitizeMinErr("uinput", "Failed to sanitize html because the input is unstable");
                mXSSAttempts--, html = inertBodyElement.innerHTML, inertBodyElement = getInertBodyElement(html);
            } while (html !== inertBodyElement.innerHTML);
            for (var node = inertBodyElement.firstChild; node; ) {
                switch (node.nodeType) {
                  case 1:
                    handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                    break;

                  case 3:
                    handler.chars(node.textContent);
                }
                var nextNode;
                if (!((nextNode = node.firstChild) || (1 === node.nodeType && handler.end(node.nodeName.toLowerCase()), 
                nextNode = getNonDescendant("nextSibling", node)))) for (;null == nextNode && (node = getNonDescendant("parentNode", node)) !== inertBodyElement; ) nextNode = getNonDescendant("nextSibling", node), 
                1 === node.nodeType && handler.end(node.nodeName.toLowerCase());
                node = nextNode;
            }
            for (;node = inertBodyElement.firstChild; ) inertBodyElement.removeChild(node);
        }
        function attrToMap(attrs) {
            for (var map = {}, i = 0, ii = attrs.length; i < ii; i++) {
                var attr = attrs[i];
                map[attr.name] = attr.value;
            }
            return map;
        }
        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
                return "&#" + (1024 * (value.charCodeAt(0) - 55296) + (value.charCodeAt(1) - 56320) + 65536) + ";";
            }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
                return "&#" + value.charCodeAt(0) + ";";
            }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        function htmlSanitizeWriterImpl(buf, uriValidator) {
            var ignoreCurrentElement = !1, out = bind(buf, buf.push);
            return {
                start: function(tag, attrs) {
                    tag = lowercase(tag), !ignoreCurrentElement && blockedElements[tag] && (ignoreCurrentElement = tag), 
                    ignoreCurrentElement || !0 !== validElements[tag] || (out("<"), out(tag), forEach(attrs, function(value, key) {
                        var lkey = lowercase(key), isImage = "img" === tag && "src" === lkey || "background" === lkey;
                        !0 !== validAttrs[lkey] || !0 === uriAttrs[lkey] && !uriValidator(value, isImage) || (out(" "), 
                        out(key), out('="'), out(encodeEntities(value)), out('"'));
                    }), out(">"));
                },
                end: function(tag) {
                    tag = lowercase(tag), ignoreCurrentElement || !0 !== validElements[tag] || !0 === voidElements[tag] || (out("</"), 
                    out(tag), out(">")), tag == ignoreCurrentElement && (ignoreCurrentElement = !1);
                },
                chars: function(chars) {
                    ignoreCurrentElement || out(encodeEntities(chars));
                }
            };
        }
        function stripCustomNsAttrs(node) {
            for (;node; ) {
                if (node.nodeType === window.Node.ELEMENT_NODE) for (var attrs = node.attributes, i = 0, l = attrs.length; i < l; i++) {
                    var attrNode = attrs[i], attrName = attrNode.name.toLowerCase();
                    "xmlns:ns1" !== attrName && 0 !== attrName.lastIndexOf("ns1:", 0) || (node.removeAttributeNode(attrNode), 
                    i--, l--);
                }
                var nextNode = node.firstChild;
                nextNode && stripCustomNsAttrs(nextNode), node = getNonDescendant("nextSibling", node);
            }
        }
        function getNonDescendant(propName, node) {
            var nextNode = node[propName];
            if (nextNode && nodeContains.call(node, nextNode)) throw $sanitizeMinErr("elclob", "Failed to sanitize html because the element is clobbered: {0}", node.outerHTML || node.outerText);
            return nextNode;
        }
        var svgEnabled = !1;
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return svgEnabled && extend(validElements, svgElements), function(html) {
                var buf = [];
                return htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
                })), buf.join("");
            };
        } ], this.enableSvg = function(enableSvg) {
            return isDefined(enableSvg) ? (svgEnabled = enableSvg, this) : svgEnabled;
        }, bind = angular.bind, extend = angular.extend, forEach = angular.forEach, isDefined = angular.isDefined, 
        lowercase = angular.lowercase, noop = angular.noop, htmlParser = htmlParserImpl, 
        htmlSanitizeWriter = htmlSanitizeWriterImpl, nodeContains = window.Node.prototype.contains || function(arg) {
            return !!(16 & this.compareDocumentPosition(arg));
        };
        var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g, voidElements = toMap("area,br,col,hr,img,wbr"), optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = toMap("rp,rt"), optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements), blockElements = extend({}, optionalEndTagBlockElements, toMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul")), inlineElements = extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan"), blockedElements = toMap("script,style"), validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements), uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href"), htmlAttrs = toMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width"), svgAttrs = toMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan", !0), validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs), getInertBodyElement = function(window, document) {
            function getInertBodyElement_XHR(html) {
                html = "<remove></remove>" + html;
                try {
                    html = encodeURI(html);
                } catch (e) {
                    return;
                }
                var xhr = new window.XMLHttpRequest();
                xhr.responseType = "document", xhr.open("GET", "data:text/html;charset=utf-8," + html, !1), 
                xhr.send(null);
                var body = xhr.response.body;
                return body.firstChild.remove(), body;
            }
            function getInertBodyElement_DOMParser(html) {
                html = "<remove></remove>" + html;
                try {
                    var body = new window.DOMParser().parseFromString(html, "text/html").body;
                    return body.firstChild.remove(), body;
                } catch (e) {
                    return;
                }
            }
            function getInertBodyElement_InertDocument(html) {
                return inertBodyElement.innerHTML = html, document.documentMode && stripCustomNsAttrs(inertBodyElement), 
                inertBodyElement;
            }
            var inertDocument;
            if (!document || !document.implementation) throw $sanitizeMinErr("noinert", "Can't create an inert html document");
            inertDocument = document.implementation.createHTMLDocument("inert");
            var inertBodyElement = (inertDocument.documentElement || inertDocument.getDocumentElement()).querySelector("body");
            return inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', 
            inertBodyElement.querySelector("svg") ? (inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', 
            inertBodyElement.querySelector("svg img") ? getInertBodyElement_DOMParser : getInertBodyElement_InertDocument) : getInertBodyElement_XHR;
        }(window, window.document);
    }
    function sanitizeText(chars) {
        var buf = [];
        return htmlSanitizeWriter(buf, noop).chars(chars), buf.join("");
    }
    var bind, extend, forEach, isDefined, lowercase, noop, nodeContains, htmlParser, htmlSanitizeWriter, $sanitizeMinErr = angular.$$minErr("$sanitize");
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider).info({
        angularVersion: "1.6.5"
    }), angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i, MAILTO_REGEXP = /^mailto:/i, linkyMinErr = angular.$$minErr("linky"), isDefined = angular.isDefined, isFunction = angular.isFunction, isObject = angular.isObject, isString = angular.isString;
        return function(text, target, attributes) {
            function addText(text) {
                text && html.push(sanitizeText(text));
            }
            if (null == text || "" === text) return text;
            if (!isString(text)) throw linkyMinErr("notstring", "Expected string but received: {0}", text);
            for (var match, url, i, attributesFn = isFunction(attributes) ? attributes : isObject(attributes) ? function() {
                return attributes;
            } : function() {
                return {};
            }, raw = text, html = []; match = raw.match(LINKY_URL_REGEXP); ) url = match[0], 
            match[2] || match[4] || (url = (match[3] ? "http://" : "mailto:") + url), i = match.index, 
            addText(raw.substr(0, i)), function(url, text) {
                var key, linkAttributes = attributesFn(url);
                html.push("<a ");
                for (key in linkAttributes) html.push(key + '="' + linkAttributes[key] + '" ');
                !isDefined(target) || "target" in linkAttributes || html.push('target="', target, '" '), 
                html.push('href="', url.replace(/"/g, "&quot;"), '">'), addText(text), html.push("</a>");
            }(url, match[0].replace(MAILTO_REGEXP, "")), raw = raw.substring(i + match[0].length);
            return addText(raw), $sanitize(html.join(""));
        };
    } ]);
}(window, window.angular), define("angular-sanitize", [ "angular" ], function() {}), 
function(root, factory) {
    "use strict";
    "function" == typeof define && define.amd ? define("bootbox", [ "jquery" ], factory) : "object" == typeof exports ? module.exports = factory(require("jquery")) : root.bootbox = factory(root.jQuery);
}(this, function init($, undefined) {
    "use strict";
    function _t(key) {
        var locale = locales[defaults.locale];
        return locale ? locale[key] : locales.en[key];
    }
    function processCallback(e, dialog, callback) {
        e.stopPropagation(), e.preventDefault(), $.isFunction(callback) && !1 === callback.call(dialog, e) || dialog.modal("hide");
    }
    function getKeyLength(obj) {
        var k, t = 0;
        for (k in obj) t++;
        return t;
    }
    function each(collection, iterator) {
        var index = 0;
        $.each(collection, function(key, value) {
            iterator(key, value, index++);
        });
    }
    function sanitize(options) {
        var buttons, total;
        if ("object" != typeof options) throw new Error("Please supply an object of options");
        if (!options.message) throw new Error("Please specify a message");
        return options = $.extend({}, defaults, options), options.buttons || (options.buttons = {}), 
        buttons = options.buttons, total = getKeyLength(buttons), each(buttons, function(key, button, index) {
            if ($.isFunction(button) && (button = buttons[key] = {
                callback: button
            }), "object" !== $.type(button)) throw new Error("button with key " + key + " must be an object");
            button.label || (button.label = key), button.className || (button.className = total <= 2 && index === total - 1 ? "btn-primary" : "btn-default");
        }), options;
    }
    function mapArguments(args, properties) {
        var argn = args.length, options = {};
        if (argn < 1 || argn > 2) throw new Error("Invalid argument length");
        return 2 === argn || "string" == typeof args[0] ? (options[properties[0]] = args[0], 
        options[properties[1]] = args[1]) : options = args[0], options;
    }
    function mergeArguments(defaults, args, properties) {
        return $.extend(!0, {}, defaults, mapArguments(args, properties));
    }
    function mergeDialogOptions(className, labels, properties, args) {
        return validateButtons(mergeArguments({
            className: "bootbox-" + className,
            buttons: createLabels.apply(null, labels)
        }, args, properties), labels);
    }
    function createLabels() {
        for (var buttons = {}, i = 0, j = arguments.length; i < j; i++) {
            var argument = arguments[i], key = argument.toLowerCase(), value = argument.toUpperCase();
            buttons[key] = {
                label: _t(value)
            };
        }
        return buttons;
    }
    function validateButtons(options, buttons) {
        var allowedButtons = {};
        return each(buttons, function(key, value) {
            allowedButtons[value] = !0;
        }), each(options.buttons, function(key) {
            if (allowedButtons[key] === undefined) throw new Error("button key " + key + " is not allowed (options are " + buttons.join("\n") + ")");
        }), options;
    }
    var templates = {
        dialog: "<div class='bootbox modal' tabindex='-1' role='dialog'><div class='modal-dialog'><div class='modal-content'><div class='modal-body'><div class='bootbox-body'></div></div></div></div></div>",
        header: "<div class='modal-header'><h4 class='modal-title'></h4></div>",
        footer: "<div class='modal-footer'></div>",
        closeButton: "<button type='button' class='bootbox-close-button close' data-dismiss='modal' aria-hidden='true'>&times;</button>",
        form: "<form class='bootbox-form'></form>",
        inputs: {
            text: "<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text />",
            textarea: "<textarea class='bootbox-input bootbox-input-textarea form-control'></textarea>",
            email: "<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' />",
            select: "<select class='bootbox-input bootbox-input-select form-control'></select>",
            checkbox: "<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' /></label></div>",
            date: "<input class='bootbox-input bootbox-input-date form-control' autocomplete=off type='date' />",
            time: "<input class='bootbox-input bootbox-input-time form-control' autocomplete=off type='time' />",
            number: "<input class='bootbox-input bootbox-input-number form-control' autocomplete=off type='number' />",
            password: "<input class='bootbox-input bootbox-input-password form-control' autocomplete='off' type='password' />"
        }
    }, defaults = {
        locale: "en",
        backdrop: "static",
        animate: !0,
        className: null,
        closeButton: !0,
        show: !0,
        container: "body"
    }, exports = {};
    exports.alert = function() {
        var options;
        if (options = mergeDialogOptions("alert", [ "ok" ], [ "message", "callback" ], arguments), 
        options.callback && !$.isFunction(options.callback)) throw new Error("alert requires callback property to be a function when provided");
        return options.buttons.ok.callback = options.onEscape = function() {
            return !$.isFunction(options.callback) || options.callback.call(this);
        }, exports.dialog(options);
    }, exports.confirm = function() {
        var options;
        if (options = mergeDialogOptions("confirm", [ "cancel", "confirm" ], [ "message", "callback" ], arguments), 
        options.buttons.cancel.callback = options.onEscape = function() {
            return options.callback.call(this, !1);
        }, options.buttons.confirm.callback = function() {
            return options.callback.call(this, !0);
        }, !$.isFunction(options.callback)) throw new Error("confirm requires a callback");
        return exports.dialog(options);
    }, exports.prompt = function() {
        var options, defaults, dialog, form, input, shouldShow, inputOptions;
        if (form = $(templates.form), defaults = {
            className: "bootbox-prompt",
            buttons: createLabels("cancel", "confirm"),
            value: "",
            inputType: "text"
        }, options = validateButtons(mergeArguments(defaults, arguments, [ "title", "callback" ]), [ "cancel", "confirm" ]), 
        shouldShow = options.show === undefined || options.show, options.message = form, 
        options.buttons.cancel.callback = options.onEscape = function() {
            return options.callback.call(this, null);
        }, options.buttons.confirm.callback = function() {
            var value;
            switch (options.inputType) {
              case "text":
              case "textarea":
              case "email":
              case "select":
              case "date":
              case "time":
              case "number":
              case "password":
                value = input.val();
                break;

              case "checkbox":
                var checkedItems = input.find("input:checked");
                value = [], each(checkedItems, function(_, item) {
                    value.push($(item).val());
                });
            }
            return options.callback.call(this, value);
        }, options.show = !1, !options.title) throw new Error("prompt requires a title");
        if (!$.isFunction(options.callback)) throw new Error("prompt requires a callback");
        if (!templates.inputs[options.inputType]) throw new Error("invalid prompt type");
        switch (input = $(templates.inputs[options.inputType]), options.inputType) {
          case "text":
          case "textarea":
          case "email":
          case "date":
          case "time":
          case "number":
          case "password":
            input.val(options.value);
            break;

          case "select":
            var groups = {};
            if (inputOptions = options.inputOptions || [], !$.isArray(inputOptions)) throw new Error("Please pass an array of input options");
            if (!inputOptions.length) throw new Error("prompt with select requires options");
            each(inputOptions, function(_, option) {
                var elem = input;
                if (option.value === undefined || option.text === undefined) throw new Error("given options in wrong format");
                option.group && (groups[option.group] || (groups[option.group] = $("<optgroup/>").attr("label", option.group)), 
                elem = groups[option.group]), elem.append("<option value='" + option.value + "'>" + option.text + "</option>");
            }), each(groups, function(_, group) {
                input.append(group);
            }), input.val(options.value);
            break;

          case "checkbox":
            var values = $.isArray(options.value) ? options.value : [ options.value ];
            if (inputOptions = options.inputOptions || [], !inputOptions.length) throw new Error("prompt with checkbox requires options");
            if (!inputOptions[0].value || !inputOptions[0].text) throw new Error("given options in wrong format");
            input = $("<div/>"), each(inputOptions, function(_, option) {
                var checkbox = $(templates.inputs[options.inputType]);
                checkbox.find("input").attr("value", option.value), checkbox.find("label").append(option.text), 
                each(values, function(_, value) {
                    value === option.value && checkbox.find("input").prop("checked", !0);
                }), input.append(checkbox);
            });
        }
        return options.placeholder && input.attr("placeholder", options.placeholder), options.pattern && input.attr("pattern", options.pattern), 
        options.maxlength && input.attr("maxlength", options.maxlength), form.append(input), 
        form.on("submit", function(e) {
            e.preventDefault(), e.stopPropagation(), dialog.find(".btn-primary").click();
        }), dialog = exports.dialog(options), dialog.off("shown.bs.modal"), dialog.on("shown.bs.modal", function() {
            input.focus();
        }), !0 === shouldShow && dialog.modal("show"), dialog;
    }, exports.dialog = function(options) {
        options = sanitize(options);
        var dialog = $(templates.dialog), innerDialog = dialog.find(".modal-dialog"), body = dialog.find(".modal-body"), buttons = options.buttons, buttonStr = "", callbacks = {
            onEscape: options.onEscape
        };
        if ($.fn.modal === undefined) throw new Error("$.fn.modal is not defined; please double check you have included the Bootstrap JavaScript library. See http://getbootstrap.com/javascript/ for more details.");
        if (each(buttons, function(key, button) {
            buttonStr += "<button data-bb-handler='" + key + "' type='button' class='btn " + button.className + "'>" + button.label + "</button>", 
            callbacks[key] = button.callback;
        }), body.find(".bootbox-body").html(options.message), !0 === options.animate && dialog.addClass("fade"), 
        options.className && dialog.addClass(options.className), "large" === options.size ? innerDialog.addClass("modal-lg") : "small" === options.size && innerDialog.addClass("modal-sm"), 
        options.title && body.before(templates.header), options.closeButton) {
            var closeButton = $(templates.closeButton);
            options.title ? dialog.find(".modal-header").prepend(closeButton) : closeButton.css("margin-top", "-10px").prependTo(body);
        }
        return options.title && dialog.find(".modal-title").html(options.title), buttonStr.length && (body.after(templates.footer), 
        dialog.find(".modal-footer").html(buttonStr)), dialog.on("hidden.bs.modal", function(e) {
            e.target === this && dialog.remove();
        }), dialog.on("shown.bs.modal", function() {
            dialog.find(".btn-primary:first").focus();
        }), "static" !== options.backdrop && dialog.on("click.dismiss.bs.modal", function(e) {
            dialog.children(".modal-backdrop").length && (e.currentTarget = dialog.children(".modal-backdrop").get(0)), 
            e.target === e.currentTarget && dialog.trigger("escape.close.bb");
        }), dialog.on("escape.close.bb", function(e) {
            callbacks.onEscape && processCallback(e, dialog, callbacks.onEscape);
        }), dialog.on("click", ".modal-footer button", function(e) {
            var callbackKey = $(this).data("bb-handler");
            processCallback(e, dialog, callbacks[callbackKey]);
        }), dialog.on("click", ".bootbox-close-button", function(e) {
            processCallback(e, dialog, callbacks.onEscape);
        }), dialog.on("keyup", function(e) {
            27 === e.which && dialog.trigger("escape.close.bb");
        }), $(options.container).append(dialog), dialog.modal({
            backdrop: !!options.backdrop && "static",
            keyboard: !1,
            show: !1
        }), options.show && dialog.modal("show"), dialog;
    }, exports.setDefaults = function() {
        var values = {};
        2 === arguments.length ? values[arguments[0]] = arguments[1] : values = arguments[0], 
        $.extend(defaults, values);
    }, exports.hideAll = function() {
        return $(".bootbox").modal("hide"), exports;
    };
    var locales = {
        bg_BG: {
            OK: "",
            CANCEL: "",
            CONFIRM: ""
        },
        br: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Sim"
        },
        cs: {
            OK: "OK",
            CANCEL: "Zruit",
            CONFIRM: "Potvrdit"
        },
        da: {
            OK: "OK",
            CANCEL: "Annuller",
            CONFIRM: "Accepter"
        },
        de: {
            OK: "OK",
            CANCEL: "Abbrechen",
            CONFIRM: "Akzeptieren"
        },
        el: {
            OK: "",
            CANCEL: "",
            CONFIRM: ""
        },
        en: {
            OK: "OK",
            CANCEL: "Cancel",
            CONFIRM: "OK"
        },
        es: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Aceptar"
        },
        et: {
            OK: "OK",
            CANCEL: "Katkesta",
            CONFIRM: "OK"
        },
        fa: {
            OK: "",
            CANCEL: "",
            CONFIRM: ""
        },
        fi: {
            OK: "OK",
            CANCEL: "Peruuta",
            CONFIRM: "OK"
        },
        fr: {
            OK: "OK",
            CANCEL: "Annuler",
            CONFIRM: "D'accord"
        },
        he: {
            OK: "",
            CANCEL: "",
            CONFIRM: ""
        },
        hu: {
            OK: "OK",
            CANCEL: "Mgsem",
            CONFIRM: "Megerst"
        },
        hr: {
            OK: "OK",
            CANCEL: "Odustani",
            CONFIRM: "Potvrdi"
        },
        id: {
            OK: "OK",
            CANCEL: "Batal",
            CONFIRM: "OK"
        },
        it: {
            OK: "OK",
            CANCEL: "Annulla",
            CONFIRM: "Conferma"
        },
        ja: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        },
        lt: {
            OK: "Gerai",
            CANCEL: "Ataukti",
            CONFIRM: "Patvirtinti"
        },
        lv: {
            OK: "Labi",
            CANCEL: "Atcelt",
            CONFIRM: "Apstiprint"
        },
        nl: {
            OK: "OK",
            CANCEL: "Annuleren",
            CONFIRM: "Accepteren"
        },
        no: {
            OK: "OK",
            CANCEL: "Avbryt",
            CONFIRM: "OK"
        },
        pl: {
            OK: "OK",
            CANCEL: "Anuluj",
            CONFIRM: "Potwierd"
        },
        pt: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Confirmar"
        },
        ru: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        },
        sq: {
            OK: "OK",
            CANCEL: "Anulo",
            CONFIRM: "Prano"
        },
        sv: {
            OK: "OK",
            CANCEL: "Avbryt",
            CONFIRM: "OK"
        },
        th: {
            OK: "",
            CANCEL: "",
            CONFIRM: ""
        },
        tr: {
            OK: "Tamam",
            CANCEL: "ptal",
            CONFIRM: "Onayla"
        },
        zh_CN: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        },
        zh_TW: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        }
    };
    return exports.addLocale = function(name, values) {
        return $.each([ "OK", "CANCEL", "CONFIRM" ], function(_, v) {
            if (!values[v]) throw new Error("Please supply a translation for '" + v + "'");
        }), locales[name] = {
            OK: values.OK,
            CANCEL: values.CANCEL,
            CONFIRM: values.CONFIRM
        }, exports;
    }, exports.removeLocale = function(name) {
        return delete locales[name], exports;
    }, exports.setLocale = function(name) {
        return exports.setDefaults("locale", name);
    }, exports.init = function(_$) {
        return init(_$ || $);
    }, exports;
}), "function" == typeof define && define.amd && define("ngBootbox", [ "bootbox" ], function(bootbox) {
    window.bootbox = bootbox;
}), angular.module("ngBootbox", []).provider("$ngBootboxConfig", function() {
    var defaultLocale = "";
    return {
        setDefaultLocale: function(name) {
            defaultLocale = name, window.bootbox.setLocale(name);
        },
        addLocale: function(name, values) {
            window.bootbox.addLocale(name, values);
        },
        removeLocale: function(name) {
            window.bootbox.removeLocale(name);
        },
        $get: function() {
            return {
                getDefaultLocale: function() {
                    return defaultLocale;
                }
            };
        }
    };
}).directive("ngBootboxAlert", [ "$ngBootbox", function($ngBootbox) {
    return {
        restrict: "A",
        scope: !1,
        link: function(scope, element, attr) {
            var msg = attr.ngBootboxAlert || "Yo!";
            element.bind("click", function() {
                $ngBootbox.alert(msg);
            });
        }
    };
} ]).directive("ngBootboxConfirm", [ "$ngBootbox", function($ngBootbox) {
    return {
        restrict: "A",
        scope: {
            actionOK: "&ngBootboxConfirmAction",
            actionCancel: "&ngBootboxConfirmActionCancel"
        },
        link: function(scope, element, attr) {
            var msg = attr.ngBootboxConfirm || "Are you sure?";
            element.bind("click", function() {
                $ngBootbox.confirm(msg).then(function() {
                    scope.actionOK();
                }, function() {
                    scope.actionCancel();
                });
            });
        }
    };
} ]).directive("ngBootboxPrompt", [ "$ngBootbox", function($ngBootbox) {
    return {
        restrict: "A",
        scope: {
            actionOK: "&ngBootboxPromptAction",
            actionCancel: "&ngBootboxPromptActionCancel",
            value: "@ngBootboxPromptDefaultValue",
            selectAllOnFocus: "@ngBootboxPromptSelectAllOnFocus"
        },
        link: function(scope, element, attr) {
            var msg = attr.ngBootboxPrompt || "Are you sure?", value = attr.ngBootboxPromptDefaultValue || "", selectAllOnFocus = scope.$eval(attr.ngBootboxPromptSelectAllOnFocus) || !1;
            element.bind("click", function() {
                $ngBootbox.prompt(msg, value, selectAllOnFocus).then(function(result) {
                    scope.actionOK({
                        result: result
                    });
                }, function() {
                    scope.actionCancel();
                });
            });
        }
    };
} ]).directive("ngBootboxCustomDialog", [ "$ngBootbox", function($ngBootbox) {
    return {
        restrict: "A",
        scope: {
            title: "@ngBootboxTitle",
            buttons: "=ngBootboxButtons",
            className: "@ngBootboxClassName",
            data: "=ngBootboxData",
            options: "=ngBootboxOptions"
        },
        link: function(scope, element, attr) {
            var options = {}, templateUrl = attr.ngBootboxCustomDialogTemplate;
            scope.options && (options = scope.options), scope.title && (options.title = scope.title), 
            scope.buttons && (options.buttons = scope.buttons), scope.className && (options.className = scope.className), 
            scope.data && (options.data = scope.data), templateUrl ? options.templateUrl = templateUrl : options.message = attr.ngBootboxCustomDialog, 
            element.bind("click", function() {
                $ngBootbox.customDialog(options);
            });
        }
    };
} ]).factory("$ngBootbox", [ "$q", "$templateCache", "$compile", "$rootScope", "$http", "$window", function($q, $templateCache, $compile, $rootScope, $http, $window) {
    function getTemplate(templateId) {
        var def = $q.defer(), template = $templateCache.get(templateId);
        return void 0 === template ? $http.get(templateId).then(function(response) {
            var data = response.data;
            $templateCache.put(templateId, data), def.resolve(data);
        }) : def.resolve(template), def.promise;
    }
    return {
        alert: function(msg) {
            function _callback() {
                deferred.resolve();
            }
            var deferred = $q.defer();
            return "object" == typeof msg ? $window.bootbox.alert(angular.merge(msg, {
                callback: _callback
            })) : $window.bootbox.alert(msg, _callback), deferred.promise;
        },
        confirm: function(msg) {
            function _callback(result) {
                result ? deferred.resolve() : deferred.reject();
            }
            var deferred = $q.defer();
            return "object" == typeof msg ? $window.bootbox.confirm(angular.merge(msg, {
                callback: _callback
            })) : $window.bootbox.confirm(msg, _callback), deferred.promise;
        },
        prompt: function(msg, value, selectAllOnFocus) {
            var deferred = $q.defer();
            return $window.bootbox.prompt({
                title: msg,
                value: value || "",
                selectAllOnFocus: selectAllOnFocus || !1,
                callback: function(result) {
                    null !== result ? deferred.resolve(result) : deferred.reject();
                }
            }), deferred.promise;
        },
        customDialog: function(options) {
            options.templateUrl ? getTemplate(options.templateUrl).then(function(template) {
                options.scope = options.scope || $rootScope, options.message = $compile(template)(options.scope), 
                $window.bootbox.dialog(options);
            }, function() {
                $window.bootbox.dialog(options);
            }) : $window.bootbox.dialog(options);
        },
        setDefaults: function(options) {
            $window.bootbox.setDefaults(options);
        },
        hideAll: function() {
            $window.bootbox.hideAll();
        },
        setLocale: function(name) {
            $window.bootbox.setLocale(name);
        },
        addLocale: function(name, values) {
            $window.bootbox.addLocale(name, values);
        },
        removeLocale: function(name) {
            $window.bootbox.removeLocale(name);
        }
    };
} ]), !window.XMLHttpRequest || window.FileAPI && FileAPI.shouldLoad || (window.XMLHttpRequest.prototype.setRequestHeader = function(orig) {
    return function(header, value) {
        if ("__setXHR_" === header) {
            var val = value(this);
            val instanceof Function && val(this);
        } else orig.apply(this, arguments);
    };
}(window.XMLHttpRequest.prototype.setRequestHeader));

var ngFileUpload = angular.module("ngFileUpload", []);

ngFileUpload.version = "12.2.13", ngFileUpload.service("UploadBase", [ "$http", "$q", "$timeout", function($http, $q, $timeout) {
    function sendHttp(config) {
        function notifyProgress(e) {
            deferred.notify && deferred.notify(e), promise.progressFunc && $timeout(function() {
                promise.progressFunc(e);
            });
        }
        function getNotifyEvent(n) {
            return null != config._start && resumeSupported ? {
                loaded: n.loaded + config._start,
                total: config._file && config._file.size || n.total,
                type: n.type,
                config: config,
                lengthComputable: !0,
                target: n.target
            } : n;
        }
        function uploadWithAngular() {
            $http(config).then(function(r) {
                if (resumeSupported && config._chunkSize && !config._finished && config._file) {
                    var fileSize = config._file && config._file.size || 0;
                    notifyProgress({
                        loaded: Math.min(config._end, fileSize),
                        total: fileSize,
                        config: config,
                        type: "progress"
                    }), upload.upload(config, !0);
                } else config._finished && delete config._finished, deferred.resolve(r);
            }, function(e) {
                deferred.reject(e);
            }, function(n) {
                deferred.notify(n);
            });
        }
        config.method = config.method || "POST", config.headers = config.headers || {};
        var deferred = config._deferred = config._deferred || $q.defer(), promise = deferred.promise;
        return config.disableProgress || (config.headers.__setXHR_ = function() {
            return function(xhr) {
                xhr && xhr.upload && xhr.upload.addEventListener && (config.__XHR = xhr, config.xhrFn && config.xhrFn(xhr), 
                xhr.upload.addEventListener("progress", function(e) {
                    e.config = config, notifyProgress(getNotifyEvent(e));
                }, !1), xhr.upload.addEventListener("load", function(e) {
                    e.lengthComputable && (e.config = config, notifyProgress(getNotifyEvent(e)));
                }, !1));
            };
        }), resumeSupported ? config._chunkSize && config._end && !config._finished ? (config._start = config._end, 
        config._end += config._chunkSize, uploadWithAngular()) : config.resumeSizeUrl ? $http.get(config.resumeSizeUrl).then(function(resp) {
            config.resumeSizeResponseReader ? config._start = config.resumeSizeResponseReader(resp.data) : config._start = parseInt((null == resp.data.size ? resp.data : resp.data.size).toString()), 
            config._chunkSize && (config._end = config._start + config._chunkSize), uploadWithAngular();
        }, function(e) {
            throw e;
        }) : config.resumeSize ? config.resumeSize().then(function(size) {
            config._start = size, config._chunkSize && (config._end = config._start + config._chunkSize), 
            uploadWithAngular();
        }, function(e) {
            throw e;
        }) : (config._chunkSize && (config._start = 0, config._end = config._start + config._chunkSize), 
        uploadWithAngular()) : uploadWithAngular(), promise.success = function(fn) {
            return promise.then(function(response) {
                fn(response.data, response.status, response.headers, config);
            }), promise;
        }, promise.error = function(fn) {
            return promise.then(null, function(response) {
                fn(response.data, response.status, response.headers, config);
            }), promise;
        }, promise.progress = function(fn) {
            return promise.progressFunc = fn, promise.then(null, null, function(n) {
                fn(n);
            }), promise;
        }, promise.abort = promise.pause = function() {
            return config.__XHR && $timeout(function() {
                config.__XHR.abort();
            }), promise;
        }, promise.xhr = function(fn) {
            return config.xhrFn = function(origXhrFn) {
                return function() {
                    origXhrFn && origXhrFn.apply(promise, arguments), fn.apply(promise, arguments);
                };
            }(config.xhrFn), promise;
        }, upload.promisesCount++, promise.finally && promise.finally instanceof Function && promise.finally(function() {
            upload.promisesCount--;
        }), promise;
    }
    function copy(obj) {
        var clone = {};
        for (var key in obj) obj.hasOwnProperty(key) && (clone[key] = obj[key]);
        return clone;
    }
    var upload = this;
    upload.promisesCount = 0, this.isResumeSupported = function() {
        return window.Blob && window.Blob.prototype.slice;
    };
    var resumeSupported = this.isResumeSupported();
    this.isUploadInProgress = function() {
        return upload.promisesCount > 0;
    }, this.rename = function(file, name) {
        return file.ngfName = name, file;
    }, this.jsonBlob = function(val) {
        null == val || angular.isString(val) || (val = JSON.stringify(val));
        var blob = new window.Blob([ val ], {
            type: "application/json"
        });
        return blob._ngfBlob = !0, blob;
    }, this.json = function(val) {
        return angular.toJson(val);
    }, this.isFile = function(file) {
        return null != file && (file instanceof window.Blob || file.flashId && file.name && file.size);
    }, this.upload = function(config, internal) {
        function toResumeFile(file, formData) {
            if (file._ngfBlob) return file;
            if (config._file = config._file || file, null != config._start && resumeSupported) {
                config._end && config._end >= file.size && (config._finished = !0, config._end = file.size);
                var slice = file.slice(config._start, config._end || file.size);
                return slice.name = file.name, slice.ngfName = file.ngfName, config._chunkSize && (formData.append("_chunkSize", config._chunkSize), 
                formData.append("_currentChunkSize", config._end - config._start), formData.append("_chunkNumber", Math.floor(config._start / config._chunkSize)), 
                formData.append("_totalSize", config._file.size)), slice;
            }
            return file;
        }
        function addFieldToFormData(formData, val, key) {
            if (void 0 !== val) if (angular.isDate(val) && (val = val.toISOString()), angular.isString(val)) formData.append(key, val); else if (upload.isFile(val)) {
                var file = toResumeFile(val, formData), split = key.split(",");
                split[1] && (file.ngfName = split[1].replace(/^\s+|\s+$/g, ""), key = split[0]), 
                config._fileKey = config._fileKey || key, formData.append(key, file, file.ngfName || file.name);
            } else if (angular.isObject(val)) {
                if (val.$$ngfCircularDetection) throw "ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: " + key;
                val.$$ngfCircularDetection = !0;
                try {
                    for (var k in val) if (val.hasOwnProperty(k) && "$$ngfCircularDetection" !== k) {
                        var objectKey = null == config.objectKey ? "[i]" : config.objectKey;
                        val.length && parseInt(k) > -1 && (objectKey = null == config.arrayKey ? objectKey : config.arrayKey), 
                        addFieldToFormData(formData, val[k], key + objectKey.replace(/[ik]/g, k));
                    }
                } finally {
                    delete val.$$ngfCircularDetection;
                }
            } else formData.append(key, val);
        }
        return internal || (config = copy(config)), config._isDigested || (config._isDigested = !0, 
        function() {
            config._chunkSize = upload.translateScalars(config.resumeChunkSize), config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null, 
            config.headers = config.headers || {}, config.headers["Content-Type"] = void 0, 
            config.transformRequest = config.transformRequest ? angular.isArray(config.transformRequest) ? config.transformRequest : [ config.transformRequest ] : [], 
            config.transformRequest.push(function(data) {
                var key, formData = new window.FormData();
                data = data || config.fields || {}, config.file && (data.file = config.file);
                for (key in data) if (data.hasOwnProperty(key)) {
                    var val = data[key];
                    config.formDataAppender ? config.formDataAppender(formData, key, val) : addFieldToFormData(formData, val, key);
                }
                return formData;
            });
        }()), sendHttp(config);
    }, this.http = function(config) {
        return config = copy(config), config.transformRequest = config.transformRequest || function(data) {
            return window.ArrayBuffer && data instanceof window.ArrayBuffer || data instanceof window.Blob ? data : $http.defaults.transformRequest[0].apply(this, arguments);
        }, config._chunkSize = upload.translateScalars(config.resumeChunkSize), config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null, 
        sendHttp(config);
    }, this.translateScalars = function(str) {
        if (angular.isString(str)) {
            if (str.search(/kb/i) === str.length - 2) return parseFloat(1024 * str.substring(0, str.length - 2));
            if (str.search(/mb/i) === str.length - 2) return parseFloat(1048576 * str.substring(0, str.length - 2));
            if (str.search(/gb/i) === str.length - 2) return parseFloat(1073741824 * str.substring(0, str.length - 2));
            if (str.search(/b/i) === str.length - 1) return parseFloat(str.substring(0, str.length - 1));
            if (str.search(/s/i) === str.length - 1) return parseFloat(str.substring(0, str.length - 1));
            if (str.search(/m/i) === str.length - 1) return parseFloat(60 * str.substring(0, str.length - 1));
            if (str.search(/h/i) === str.length - 1) return parseFloat(3600 * str.substring(0, str.length - 1));
        }
        return str;
    }, this.urlToBlob = function(url) {
        var defer = $q.defer();
        return $http({
            url: url,
            method: "get",
            responseType: "arraybuffer"
        }).then(function(resp) {
            var arrayBufferView = new Uint8Array(resp.data), type = resp.headers("content-type") || "image/WebP", blob = new window.Blob([ arrayBufferView ], {
                type: type
            }), matches = url.match(/.*\/(.+?)(\?.*)?$/);
            matches.length > 1 && (blob.name = matches[1]), defer.resolve(blob);
        }, function(e) {
            defer.reject(e);
        }), defer.promise;
    }, this.setDefaults = function(defaults) {
        this.defaults = defaults || {};
    }, this.defaults = {}, this.version = ngFileUpload.version;
} ]), ngFileUpload.service("Upload", [ "$parse", "$timeout", "$compile", "$q", "UploadExif", function($parse, $timeout, $compile, $q, UploadExif) {
    function applyExifRotations(files, attr, scope) {
        var promises = [ upload.emptyPromise() ];
        return angular.forEach(files, function(f, i) {
            0 === f.type.indexOf("image/jpeg") && upload.attrGetter("ngfFixOrientation", attr, scope, {
                $file: f
            }) && promises.push(upload.happyPromise(upload.applyExifRotation(f), f).then(function(fixedFile) {
                files.splice(i, 1, fixedFile);
            }));
        }), $q.all(promises);
    }
    function resizeFile(files, attr, scope, ngModel) {
        var resizeVal = upload.attrGetter("ngfResize", attr, scope);
        if (!resizeVal || !upload.isResizeSupported() || !files.length) return upload.emptyPromise();
        if (resizeVal instanceof Function) {
            var defer = $q.defer();
            return resizeVal(files).then(function(p) {
                resizeWithParams(p, files, attr, scope, ngModel).then(function(r) {
                    defer.resolve(r);
                }, function(e) {
                    defer.reject(e);
                });
            }, function(e) {
                defer.reject(e);
            });
        }
        return resizeWithParams(resizeVal, files, attr, scope, ngModel);
    }
    function resizeWithParams(params, files, attr, scope, ngModel) {
        for (var promises = [ upload.emptyPromise() ], i = 0; i < files.length; i++) !function(f, i) {
            if (0 === f.type.indexOf("image")) {
                if (params.pattern && !upload.validatePattern(f, params.pattern)) return;
                params.resizeIf = function(width, height) {
                    return upload.attrGetter("ngfResizeIf", attr, scope, {
                        $width: width,
                        $height: height,
                        $file: f
                    });
                };
                var promise = upload.resize(f, params);
                promises.push(promise), promise.then(function(resizedFile) {
                    files.splice(i, 1, resizedFile);
                }, function(e) {
                    f.$error = "resize", (f.$errorMessages = f.$errorMessages || {}).resize = !0, f.$errorParam = (e ? (e.message ? e.message : e) + ": " : "") + (f && f.name), 
                    ngModel.$ngfValidations.push({
                        name: "resize",
                        valid: !1
                    }), upload.applyModelValidation(ngModel, files);
                });
            }
        }(files[i], i);
        return $q.all(promises);
    }
    var upload = UploadExif;
    return upload.getAttrWithDefaults = function(attr, name) {
        if (null != attr[name]) return attr[name];
        var def = upload.defaults[name];
        return null == def ? def : angular.isString(def) ? def : JSON.stringify(def);
    }, upload.attrGetter = function(name, attr, scope, params) {
        var attrVal = this.getAttrWithDefaults(attr, name);
        if (!scope) return attrVal;
        try {
            return params ? $parse(attrVal)(scope, params) : $parse(attrVal)(scope);
        } catch (e) {
            if (name.search(/min|max|pattern/i)) return attrVal;
            throw e;
        }
    }, upload.shouldUpdateOn = function(type, attr, scope) {
        var modelOptions = upload.attrGetter("ngfModelOptions", attr, scope);
        return !modelOptions || !modelOptions.updateOn || modelOptions.updateOn.split(" ").indexOf(type) > -1;
    }, upload.emptyPromise = function() {
        var d = $q.defer(), args = arguments;
        return $timeout(function() {
            d.resolve.apply(d, args);
        }), d.promise;
    }, upload.rejectPromise = function() {
        var d = $q.defer(), args = arguments;
        return $timeout(function() {
            d.reject.apply(d, args);
        }), d.promise;
    }, upload.happyPromise = function(promise, data) {
        var d = $q.defer();
        return promise.then(function(result) {
            d.resolve(result);
        }, function(error) {
            $timeout(function() {
                throw error;
            }), d.resolve(data);
        }), d.promise;
    }, upload.updateModel = function(ngModel, attr, scope, fileChange, files, evt, noDelay) {
        function update(files, invalidFiles, newFiles, dupFiles, isSingleModel) {
            attr.$$ngfPrevValidFiles = files, attr.$$ngfPrevInvalidFiles = invalidFiles;
            var file = files && files.length ? files[0] : null, invalidFile = invalidFiles && invalidFiles.length ? invalidFiles[0] : null;
            ngModel && (upload.applyModelValidation(ngModel, files), ngModel.$setViewValue(isSingleModel ? file : files)), 
            fileChange && $parse(fileChange)(scope, {
                $files: files,
                $file: file,
                $newFiles: newFiles,
                $duplicateFiles: dupFiles,
                $invalidFiles: invalidFiles,
                $invalidFile: invalidFile,
                $event: evt
            });
            var invalidModel = upload.attrGetter("ngfModelInvalid", attr);
            invalidModel && $timeout(function() {
                $parse(invalidModel).assign(scope, isSingleModel ? invalidFile : invalidFiles);
            }), $timeout(function() {});
        }
        function resizeAndUpdate() {
            function updateModel() {
                $timeout(function() {
                    update(keep ? prevValidFiles.concat(valids) : valids, keep ? prevInvalidFiles.concat(invalids) : invalids, files, dupFiles, isSingleModel);
                }, options && options.debounce ? options.debounce.change || options.debounce : 0);
            }
            var resizingFiles = validateAfterResize ? allNewFiles : valids;
            resizeFile(resizingFiles, attr, scope, ngModel).then(function() {
                validateAfterResize ? upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope).then(function(validationResult) {
                    valids = validationResult.validsFiles, invalids = validationResult.invalidsFiles, 
                    updateModel();
                }) : updateModel();
            }, function() {
                for (var i = 0; i < resizingFiles.length; i++) {
                    var f = resizingFiles[i];
                    if ("resize" === f.$error) {
                        var index = valids.indexOf(f);
                        index > -1 && (valids.splice(index, 1), invalids.push(f)), updateModel();
                    }
                }
            });
        }
        var allNewFiles, prevValidFiles, prevInvalidFiles, dupFiles = [], invalids = [], valids = [];
        prevValidFiles = attr.$$ngfPrevValidFiles || [], prevInvalidFiles = attr.$$ngfPrevInvalidFiles || [], 
        ngModel && ngModel.$modelValue && (prevValidFiles = function(v) {
            return angular.isArray(v) ? v : [ v ];
        }(ngModel.$modelValue));
        var keep = upload.attrGetter("ngfKeep", attr, scope);
        allNewFiles = (files || []).slice(0), "distinct" !== keep && !0 !== upload.attrGetter("ngfKeepDistinct", attr, scope) || function() {
            function equals(f1, f2) {
                return f1.name === f2.name && (f1.$ngfOrigSize || f1.size) === (f2.$ngfOrigSize || f2.size) && f1.type === f2.type;
            }
            if (files) {
                allNewFiles = [], dupFiles = [];
                for (var i = 0; i < files.length; i++) !function(f) {
                    var j;
                    for (j = 0; j < prevValidFiles.length; j++) if (equals(f, prevValidFiles[j])) return !0;
                    for (j = 0; j < prevInvalidFiles.length; j++) if (equals(f, prevInvalidFiles[j])) return !0;
                    return !1;
                }(files[i]) ? allNewFiles.push(files[i]) : dupFiles.push(files[i]);
            }
        }();
        var isSingleModel = !keep && !upload.attrGetter("ngfMultiple", attr, scope) && !upload.attrGetter("multiple", attr);
        if (!keep || allNewFiles.length) {
            upload.attrGetter("ngfBeforeModelChange", attr, scope, {
                $files: files,
                $file: files && files.length ? files[0] : null,
                $newFiles: allNewFiles,
                $duplicateFiles: dupFiles,
                $event: evt
            });
            var validateAfterResize = upload.attrGetter("ngfValidateAfterResize", attr, scope), options = upload.attrGetter("ngfModelOptions", attr, scope);
            upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope).then(function(validationResult) {
                noDelay ? update(allNewFiles, [], files, dupFiles, isSingleModel) : (options && options.allowInvalid || validateAfterResize ? valids = allNewFiles : (valids = validationResult.validFiles, 
                invalids = validationResult.invalidFiles), upload.attrGetter("ngfFixOrientation", attr, scope) && upload.isExifSupported() ? applyExifRotations(valids, attr, scope).then(function() {
                    resizeAndUpdate();
                }) : resizeAndUpdate());
            });
        }
    }, upload;
} ]), ngFileUpload.directive("ngfSelect", [ "$parse", "$timeout", "$compile", "Upload", function($parse, $timeout, $compile, Upload) {
    function isDelayedClickSupported(ua) {
        var m = ua.match(/Android[^\d]*(\d+)\.(\d+)/);
        if (m && m.length > 2) {
            var v = Upload.defaults.androidFixMinorVersion || 4;
            return parseInt(m[1]) < 4 || parseInt(m[1]) === v && parseInt(m[2]) < v;
        }
        return -1 === ua.indexOf("Chrome") && /.*Windows.*Safari.*/.test(ua);
    }
    function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, upload) {
        function isInputTypeFile() {
            return "input" === elem[0].tagName.toLowerCase() && attr.type && "file" === attr.type.toLowerCase();
        }
        function fileChangeAttr() {
            return attrGetter("ngfChange") || attrGetter("ngfSelect");
        }
        function changeFn(evt) {
            if (upload.shouldUpdateOn("change", attr, scope)) {
                var fileList = evt.__files_ || evt.target && evt.target.files, files = [];
                if (!fileList) return;
                for (var i = 0; i < fileList.length; i++) files.push(fileList[i]);
                upload.updateModel(ngModel, attr, scope, fileChangeAttr(), files.length ? files : null, evt);
            }
        }
        function bindAttrToFileInput(fileElem, label) {
            function updateId(val) {
                fileElem.attr("id", "ngf-" + val), label.attr("id", "ngf-label-" + val);
            }
            for (var i = 0; i < elem[0].attributes.length; i++) {
                var attribute = elem[0].attributes[i];
                "type" !== attribute.name && "class" !== attribute.name && "style" !== attribute.name && ("id" === attribute.name ? (updateId(attribute.value), 
                unwatches.push(attr.$observe("id", updateId))) : fileElem.attr(attribute.name, attribute.value || "required" !== attribute.name && "multiple" !== attribute.name ? attribute.value : attribute.name));
            }
        }
        function clickHandler(evt) {
            if (elem.attr("disabled")) return !1;
            if (!attrGetter("ngfSelectDisabled", scope)) {
                var r = detectSwipe(evt);
                if (null != r) return r;
                resetModel(evt);
                try {
                    isInputTypeFile() || document.body.contains(fileElem[0]) || (generatedElems.push({
                        el: elem,
                        ref: fileElem.parent()
                    }), document.body.appendChild(fileElem.parent()[0]), fileElem.bind("change", changeFn));
                } catch (e) {}
                return isDelayedClickSupported(navigator.userAgent) ? setTimeout(function() {
                    fileElem[0].click();
                }, 0) : fileElem[0].click(), !1;
            }
        }
        function detectSwipe(evt) {
            var touches = evt.changedTouches || evt.originalEvent && evt.originalEvent.changedTouches;
            if (touches) {
                if ("touchstart" === evt.type) return initialTouchStartX = touches[0].clientX, initialTouchStartY = touches[0].clientY, 
                !0;
                if ("touchend" === evt.type) {
                    var currentX = touches[0].clientX, currentY = touches[0].clientY;
                    if (Math.abs(currentX - initialTouchStartX) > 20 || Math.abs(currentY - initialTouchStartY) > 20) return evt.stopPropagation(), 
                    evt.preventDefault(), !1;
                }
                return !0;
            }
        }
        function resetModel(evt) {
            upload.shouldUpdateOn("click", attr, scope) && fileElem.val() && (fileElem.val(null), 
            upload.updateModel(ngModel, attr, scope, fileChangeAttr(), null, evt, !0));
        }
        function ie10SameFileSelectFix(evt) {
            if (fileElem && !fileElem.attr("__ngf_ie10_Fix_")) {
                if (!fileElem[0].parentNode) return void (fileElem = null);
                evt.preventDefault(), evt.stopPropagation(), fileElem.unbind("click");
                var clone = fileElem.clone();
                return fileElem.replaceWith(clone), fileElem = clone, fileElem.attr("__ngf_ie10_Fix_", "true"), 
                fileElem.bind("change", changeFn), fileElem.bind("click", ie10SameFileSelectFix), 
                fileElem[0].click(), !1;
            }
            fileElem.removeAttr("__ngf_ie10_Fix_");
        }
        var attrGetter = function(name, scope) {
            return upload.attrGetter(name, attr, scope);
        };
        upload.registerModelChangeValidator(ngModel, attr, scope);
        var unwatches = [];
        attrGetter("ngfMultiple") && unwatches.push(scope.$watch(attrGetter("ngfMultiple"), function() {
            fileElem.attr("multiple", attrGetter("ngfMultiple", scope));
        })), attrGetter("ngfCapture") && unwatches.push(scope.$watch(attrGetter("ngfCapture"), function() {
            fileElem.attr("capture", attrGetter("ngfCapture", scope));
        })), attrGetter("ngfAccept") && unwatches.push(scope.$watch(attrGetter("ngfAccept"), function() {
            fileElem.attr("accept", attrGetter("ngfAccept", scope));
        })), unwatches.push(attr.$observe("accept", function() {
            fileElem.attr("accept", attrGetter("accept"));
        }));
        var initialTouchStartY = 0, initialTouchStartX = 0, fileElem = elem;
        isInputTypeFile() || (fileElem = function() {
            if (isInputTypeFile()) return elem;
            var fileElem = angular.element('<input type="file">'), label = angular.element("<label>upload</label>");
            return label.css("visibility", "hidden").css("position", "absolute").css("overflow", "hidden").css("width", "0px").css("height", "0px").css("border", "none").css("margin", "0px").css("padding", "0px").attr("tabindex", "-1"), 
            bindAttrToFileInput(fileElem, label), generatedElems.push({
                el: elem,
                ref: label
            }), document.body.appendChild(label.append(fileElem)[0]), fileElem;
        }()), fileElem.bind("change", changeFn), isInputTypeFile() ? elem.bind("click", resetModel) : elem.bind("click touchstart touchend", clickHandler), 
        -1 !== navigator.appVersion.indexOf("MSIE 10") && fileElem.bind("click", ie10SameFileSelectFix), 
        ngModel && ngModel.$formatters.push(function(val) {
            return null != val && 0 !== val.length || fileElem.val() && fileElem.val(null), 
            val;
        }), scope.$on("$destroy", function() {
            isInputTypeFile() || fileElem.parent().remove(), angular.forEach(unwatches, function(unwatch) {
                unwatch();
            });
        }), $timeout(function() {
            for (var i = 0; i < generatedElems.length; i++) {
                var g = generatedElems[i];
                document.body.contains(g.el[0]) || (generatedElems.splice(i, 1), g.ref.remove());
            }
        }), window.FileAPI && window.FileAPI.ngfFixIE && window.FileAPI.ngfFixIE(elem, fileElem, changeFn);
    }
    var generatedElems = [];
    return {
        restrict: "AEC",
        require: "?ngModel",
        link: function(scope, elem, attr, ngModel) {
            linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, Upload);
        }
    };
} ]), function() {
    function getTagType(el) {
        return "img" === el.tagName.toLowerCase() ? "image" : "audio" === el.tagName.toLowerCase() ? "audio" : "video" === el.tagName.toLowerCase() ? "video" : /./;
    }
    function linkFileDirective(Upload, $timeout, scope, elem, attr, directiveName, resizeParams, isBackground) {
        function constructDataUrl(file) {
            var disallowObjectUrl = Upload.attrGetter("ngfNoObjectUrl", attr, scope);
            Upload.dataUrl(file, disallowObjectUrl).finally(function() {
                $timeout(function() {
                    var src = (disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl;
                    isBackground ? elem.css("background-image", "url('" + (src || "") + "')") : elem.attr("src", src), 
                    src ? elem.removeClass("ng-hide") : elem.addClass("ng-hide");
                });
            });
        }
        $timeout(function() {
            var unwatch = scope.$watch(attr[directiveName], function(file) {
                var size = resizeParams;
                if ("ngfThumbnail" === directiveName && (size || (size = {
                    width: elem[0].naturalWidth || elem[0].clientWidth,
                    height: elem[0].naturalHeight || elem[0].clientHeight
                }), 0 === size.width && window.getComputedStyle)) {
                    var style = getComputedStyle(elem[0]);
                    style.width && style.width.indexOf("px") > -1 && style.height && style.height.indexOf("px") > -1 && (size = {
                        width: parseInt(style.width.slice(0, -2)),
                        height: parseInt(style.height.slice(0, -2))
                    });
                }
                return angular.isString(file) ? (elem.removeClass("ng-hide"), isBackground ? elem.css("background-image", "url('" + file + "')") : elem.attr("src", file)) : void (!file || !file.type || 0 !== file.type.search(getTagType(elem[0])) || isBackground && 0 !== file.type.indexOf("image") ? elem.addClass("ng-hide") : size && Upload.isResizeSupported() ? (size.resizeIf = function(width, height) {
                    return Upload.attrGetter("ngfResizeIf", attr, scope, {
                        $width: width,
                        $height: height,
                        $file: file
                    });
                }, Upload.resize(file, size).then(function(f) {
                    constructDataUrl(f);
                }, function(e) {
                    throw e;
                })) : constructDataUrl(file));
            });
            scope.$on("$destroy", function() {
                unwatch();
            });
        });
    }
    ngFileUpload.service("UploadDataUrl", [ "UploadBase", "$timeout", "$q", function(UploadBase, $timeout, $q) {
        var upload = UploadBase;
        return upload.base64DataUrl = function(file) {
            if (angular.isArray(file)) {
                var d = $q.defer(), count = 0;
                return angular.forEach(file, function(f) {
                    upload.dataUrl(f, !0).finally(function() {
                        if (++count === file.length) {
                            var urls = [];
                            angular.forEach(file, function(ff) {
                                urls.push(ff.$ngfDataUrl);
                            }), d.resolve(urls, file);
                        }
                    });
                }), d.promise;
            }
            return upload.dataUrl(file, !0);
        }, upload.dataUrl = function(file, disallowObjectUrl) {
            if (!file) return upload.emptyPromise(file, file);
            if (disallowObjectUrl && null != file.$ngfDataUrl || !disallowObjectUrl && null != file.$ngfBlobUrl) return upload.emptyPromise(disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl, file);
            var p = disallowObjectUrl ? file.$$ngfDataUrlPromise : file.$$ngfBlobUrlPromise;
            if (p) return p;
            var deferred = $q.defer();
            return $timeout(function() {
                if (window.FileReader && file && (!window.FileAPI || -1 === navigator.userAgent.indexOf("MSIE 8") || file.size < 2e4) && (!window.FileAPI || -1 === navigator.userAgent.indexOf("MSIE 9") || file.size < 4e6)) {
                    var URL = window.URL || window.webkitURL;
                    if (URL && URL.createObjectURL && !disallowObjectUrl) {
                        var url;
                        try {
                            url = URL.createObjectURL(file);
                        } catch (e) {
                            return void $timeout(function() {
                                file.$ngfBlobUrl = "", deferred.reject();
                            });
                        }
                        $timeout(function() {
                            if (file.$ngfBlobUrl = url, url) {
                                deferred.resolve(url, file), upload.blobUrls = upload.blobUrls || [], upload.blobUrlsTotalSize = upload.blobUrlsTotalSize || 0, 
                                upload.blobUrls.push({
                                    url: url,
                                    size: file.size
                                }), upload.blobUrlsTotalSize += file.size || 0;
                                for (var maxMemory = upload.defaults.blobUrlsMaxMemory || 268435456, maxLength = upload.defaults.blobUrlsMaxQueueSize || 200; (upload.blobUrlsTotalSize > maxMemory || upload.blobUrls.length > maxLength) && upload.blobUrls.length > 1; ) {
                                    var obj = upload.blobUrls.splice(0, 1)[0];
                                    URL.revokeObjectURL(obj.url), upload.blobUrlsTotalSize -= obj.size;
                                }
                            }
                        });
                    } else {
                        var fileReader = new FileReader();
                        fileReader.onload = function(e) {
                            $timeout(function() {
                                file.$ngfDataUrl = e.target.result, deferred.resolve(e.target.result, file), $timeout(function() {
                                    delete file.$ngfDataUrl;
                                }, 1e3);
                            });
                        }, fileReader.onerror = function() {
                            $timeout(function() {
                                file.$ngfDataUrl = "", deferred.reject();
                            });
                        }, fileReader.readAsDataURL(file);
                    }
                } else $timeout(function() {
                    file[disallowObjectUrl ? "$ngfDataUrl" : "$ngfBlobUrl"] = "", deferred.reject();
                });
            }), p = disallowObjectUrl ? file.$$ngfDataUrlPromise = deferred.promise : file.$$ngfBlobUrlPromise = deferred.promise, 
            p.finally(function() {
                delete file[disallowObjectUrl ? "$$ngfDataUrlPromise" : "$$ngfBlobUrlPromise"];
            }), p;
        }, upload;
    } ]), ngFileUpload.directive("ngfSrc", [ "Upload", "$timeout", function(Upload, $timeout) {
        return {
            restrict: "AE",
            link: function(scope, elem, attr) {
                linkFileDirective(Upload, $timeout, scope, elem, attr, "ngfSrc", Upload.attrGetter("ngfResize", attr, scope), !1);
            }
        };
    } ]), ngFileUpload.directive("ngfBackground", [ "Upload", "$timeout", function(Upload, $timeout) {
        return {
            restrict: "AE",
            link: function(scope, elem, attr) {
                linkFileDirective(Upload, $timeout, scope, elem, attr, "ngfBackground", Upload.attrGetter("ngfResize", attr, scope), !0);
            }
        };
    } ]), ngFileUpload.directive("ngfThumbnail", [ "Upload", "$timeout", function(Upload, $timeout) {
        return {
            restrict: "AE",
            link: function(scope, elem, attr) {
                var size = Upload.attrGetter("ngfSize", attr, scope);
                linkFileDirective(Upload, $timeout, scope, elem, attr, "ngfThumbnail", size, Upload.attrGetter("ngfAsBackground", attr, scope));
            }
        };
    } ]), ngFileUpload.config([ "$compileProvider", function($compileProvider) {
        $compileProvider.imgSrcSanitizationWhitelist && $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/), 
        $compileProvider.aHrefSanitizationWhitelist && $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);
    } ]), ngFileUpload.filter("ngfDataUrl", [ "UploadDataUrl", "$sce", function(UploadDataUrl, $sce) {
        return function(file, disallowObjectUrl, trustedUrl) {
            if (angular.isString(file)) return $sce.trustAsResourceUrl(file);
            var src = file && ((disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl);
            return file && !src ? (!file.$ngfDataUrlFilterInProgress && angular.isObject(file) && (file.$ngfDataUrlFilterInProgress = !0, 
            UploadDataUrl.dataUrl(file, disallowObjectUrl)), "") : (file && delete file.$ngfDataUrlFilterInProgress, 
            (file && src ? trustedUrl ? $sce.trustAsResourceUrl(src) : src : file) || "");
        };
    } ]);
}(), ngFileUpload.service("UploadValidate", [ "UploadDataUrl", "$q", "$timeout", function(UploadDataUrl, $q, $timeout) {
    function globStringToRegex(str) {
        var regexp = "", excludes = [];
        if (str.length > 2 && "/" === str[0] && "/" === str[str.length - 1]) regexp = str.substring(1, str.length - 1); else {
            var split = str.split(",");
            if (split.length > 1) for (var i = 0; i < split.length; i++) {
                var r = globStringToRegex(split[i]);
                r.regexp ? (regexp += "(" + r.regexp + ")", i < split.length - 1 && (regexp += "|")) : excludes = excludes.concat(r.excludes);
            } else 0 === str.indexOf("!") ? excludes.push("^((?!" + globStringToRegex(str.substring(1)).regexp + ").)*$") : (0 === str.indexOf(".") && (str = "*" + str), 
            regexp = "^" + str.replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]", "g"), "\\$&") + "$", 
            regexp = regexp.replace(/\\\*/g, ".*").replace(/\\\?/g, "."));
        }
        return {
            regexp: regexp,
            excludes: excludes
        };
    }
    function markModelAsDirty(ngModel, files) {
        null == files || ngModel.$dirty || (ngModel.$setDirty ? ngModel.$setDirty() : ngModel.$dirty = !0);
    }
    var upload = UploadDataUrl;
    return upload.validatePattern = function(file, val) {
        if (!val) return !0;
        var pattern = globStringToRegex(val), valid = !0;
        if (pattern.regexp && pattern.regexp.length) {
            var regexp = new RegExp(pattern.regexp, "i");
            valid = null != file.type && regexp.test(file.type) || null != file.name && regexp.test(file.name);
        }
        for (var len = pattern.excludes.length; len--; ) {
            var exclude = new RegExp(pattern.excludes[len], "i");
            valid = valid && (null == file.type || exclude.test(file.type)) && (null == file.name || exclude.test(file.name));
        }
        return valid;
    }, upload.ratioToFloat = function(val) {
        var r = val.toString(), xIndex = r.search(/[x:]/i);
        return r = xIndex > -1 ? parseFloat(r.substring(0, xIndex)) / parseFloat(r.substring(xIndex + 1)) : parseFloat(r);
    }, upload.registerModelChangeValidator = function(ngModel, attr, scope) {
        ngModel && ngModel.$formatters.push(function(files) {
            if (ngModel.$dirty) {
                var filesArray = files;
                files && !angular.isArray(files) && (filesArray = [ files ]), upload.validate(filesArray, 0, ngModel, attr, scope).then(function() {
                    upload.applyModelValidation(ngModel, filesArray);
                });
            }
            return files;
        });
    }, upload.applyModelValidation = function(ngModel, files) {
        markModelAsDirty(ngModel, files), angular.forEach(ngModel.$ngfValidations, function(validation) {
            ngModel.$setValidity(validation.name, validation.valid);
        });
    }, upload.getValidationAttr = function(attr, scope, name, validationName, file) {
        var dName = "ngf" + name[0].toUpperCase() + name.substr(1), val = upload.attrGetter(dName, attr, scope, {
            $file: file
        });
        if (null == val && (val = upload.attrGetter("ngfValidate", attr, scope, {
            $file: file
        }))) {
            var split = (validationName || name).split(".");
            val = val[split[0]], split.length > 1 && (val = val && val[split[1]]);
        }
        return val;
    }, upload.validate = function(files, prevLength, ngModel, attr, scope) {
        function validateSync(name, validationName, fn) {
            if (files) {
                for (var i = files.length, valid = null; i--; ) {
                    var file = files[i];
                    if (file) {
                        var val = upload.getValidationAttr(attr, scope, name, validationName, file);
                        null != val && (fn(file, val, i) || (-1 === ignoredErrors.indexOf(name) ? (file.$error = name, 
                        (file.$errorMessages = file.$errorMessages || {})[name] = !0, file.$errorParam = val, 
                        -1 === invalidFiles.indexOf(file) && invalidFiles.push(file), runAllValidation || files.splice(i, 1), 
                        valid = !1) : files.splice(i, 1)));
                    }
                }
                null !== valid && ngModel.$ngfValidations.push({
                    name: name,
                    valid: valid
                });
            }
        }
        function validateAsync(name, validationName, type, asyncFn, fn) {
            function resolveResult(defer, file, val) {
                function resolveInternal(fn) {
                    if (fn()) if (-1 === ignoredErrors.indexOf(name)) {
                        if (file.$error = name, (file.$errorMessages = file.$errorMessages || {})[name] = !0, 
                        file.$errorParam = val, -1 === invalidFiles.indexOf(file) && invalidFiles.push(file), 
                        !runAllValidation) {
                            var i = files.indexOf(file);
                            i > -1 && files.splice(i, 1);
                        }
                        defer.resolve(!1);
                    } else {
                        var j = files.indexOf(file);
                        j > -1 && files.splice(j, 1), defer.resolve(!0);
                    } else defer.resolve(!0);
                }
                null != val ? asyncFn(file, val).then(function(d) {
                    resolveInternal(function() {
                        return !fn(d, val);
                    });
                }, function() {
                    resolveInternal(function() {
                        return attrGetter("ngfValidateForce", {
                            $file: file
                        });
                    });
                }) : defer.resolve(!0);
            }
            var promises = [ upload.emptyPromise(!0) ];
            files && (files = void 0 === files.length ? [ files ] : files, angular.forEach(files, function(file) {
                var defer = $q.defer();
                return promises.push(defer.promise), !type || null != file.type && 0 === file.type.search(type) ? void ("dimensions" === name && null != upload.attrGetter("ngfDimensions", attr) ? upload.imageDimensions(file).then(function(d) {
                    resolveResult(defer, file, attrGetter("ngfDimensions", {
                        $file: file,
                        $width: d.width,
                        $height: d.height
                    }));
                }, function() {
                    defer.resolve(!1);
                }) : "duration" === name && null != upload.attrGetter("ngfDuration", attr) ? upload.mediaDuration(file).then(function(d) {
                    resolveResult(defer, file, attrGetter("ngfDuration", {
                        $file: file,
                        $duration: d
                    }));
                }, function() {
                    defer.resolve(!1);
                }) : resolveResult(defer, file, upload.getValidationAttr(attr, scope, name, validationName, file))) : void defer.resolve(!0);
            }));
            var deffer = $q.defer();
            return $q.all(promises).then(function(values) {
                for (var isValid = !0, i = 0; i < values.length; i++) if (!values[i]) {
                    isValid = !1;
                    break;
                }
                ngModel.$ngfValidations.push({
                    name: name,
                    valid: isValid
                }), deffer.resolve(isValid);
            }), deffer.promise;
        }
        ngModel = ngModel || {}, ngModel.$ngfValidations = ngModel.$ngfValidations || [], 
        angular.forEach(ngModel.$ngfValidations, function(v) {
            v.valid = !0;
        });
        var attrGetter = function(name, params) {
            return upload.attrGetter(name, attr, scope, params);
        }, ignoredErrors = (upload.attrGetter("ngfIgnoreInvalid", attr, scope) || "").split(" "), runAllValidation = upload.attrGetter("ngfRunAllValidations", attr, scope);
        if (null == files || 0 === files.length) return upload.emptyPromise({
            validFiles: files,
            invalidFiles: []
        });
        files = void 0 === files.length ? [ files ] : files.slice(0);
        var invalidFiles = [];
        validateSync("pattern", null, upload.validatePattern), validateSync("minSize", "size.min", function(file, val) {
            return file.size + .1 >= upload.translateScalars(val);
        }), validateSync("maxSize", "size.max", function(file, val) {
            return file.size - .1 <= upload.translateScalars(val);
        });
        var totalSize = 0;
        if (validateSync("maxTotalSize", null, function(file, val) {
            return !((totalSize += file.size) > upload.translateScalars(val) && (files.splice(0, files.length), 
            1));
        }), validateSync("validateFn", null, function(file, r) {
            return !0 === r || null === r || "" === r;
        }), !files.length) return upload.emptyPromise({
            validFiles: [],
            invalidFiles: invalidFiles
        });
        var deffer = $q.defer(), promises = [];
        return promises.push(validateAsync("maxHeight", "height.max", /image/, this.imageDimensions, function(d, val) {
            return d.height <= val;
        })), promises.push(validateAsync("minHeight", "height.min", /image/, this.imageDimensions, function(d, val) {
            return d.height >= val;
        })), promises.push(validateAsync("maxWidth", "width.max", /image/, this.imageDimensions, function(d, val) {
            return d.width <= val;
        })), promises.push(validateAsync("minWidth", "width.min", /image/, this.imageDimensions, function(d, val) {
            return d.width >= val;
        })), promises.push(validateAsync("dimensions", null, /image/, function(file, val) {
            return upload.emptyPromise(val);
        }, function(r) {
            return r;
        })), promises.push(validateAsync("ratio", null, /image/, this.imageDimensions, function(d, val) {
            for (var split = val.toString().split(","), valid = !1, i = 0; i < split.length; i++) Math.abs(d.width / d.height - upload.ratioToFloat(split[i])) < .01 && (valid = !0);
            return valid;
        })), promises.push(validateAsync("maxRatio", "ratio.max", /image/, this.imageDimensions, function(d, val) {
            return d.width / d.height - upload.ratioToFloat(val) < 1e-4;
        })), promises.push(validateAsync("minRatio", "ratio.min", /image/, this.imageDimensions, function(d, val) {
            return d.width / d.height - upload.ratioToFloat(val) > -1e-4;
        })), promises.push(validateAsync("maxDuration", "duration.max", /audio|video/, this.mediaDuration, function(d, val) {
            return d <= upload.translateScalars(val);
        })), promises.push(validateAsync("minDuration", "duration.min", /audio|video/, this.mediaDuration, function(d, val) {
            return d >= upload.translateScalars(val);
        })), promises.push(validateAsync("duration", null, /audio|video/, function(file, val) {
            return upload.emptyPromise(val);
        }, function(r) {
            return r;
        })), promises.push(validateAsync("validateAsyncFn", null, null, function(file, val) {
            return val;
        }, function(r) {
            return !0 === r || null === r || "" === r;
        })), $q.all(promises).then(function() {
            if (runAllValidation) for (var i = 0; i < files.length; i++) {
                var file = files[i];
                file.$error && files.splice(i--, 1);
            }
            runAllValidation = !1, validateSync("maxFiles", null, function(file, val, i) {
                return prevLength + i < val;
            }), deffer.resolve({
                validFiles: files,
                invalidFiles: invalidFiles
            });
        }), deffer.promise;
    }, upload.imageDimensions = function(file) {
        if (file.$ngfWidth && file.$ngfHeight) {
            var d = $q.defer();
            return $timeout(function() {
                d.resolve({
                    width: file.$ngfWidth,
                    height: file.$ngfHeight
                });
            }), d.promise;
        }
        if (file.$ngfDimensionPromise) return file.$ngfDimensionPromise;
        var deferred = $q.defer();
        return $timeout(function() {
            return 0 !== file.type.indexOf("image") ? void deferred.reject("not image") : void upload.dataUrl(file).then(function(dataUrl) {
                function success() {
                    var width = img[0].naturalWidth || img[0].clientWidth, height = img[0].naturalHeight || img[0].clientHeight;
                    img.remove(), file.$ngfWidth = width, file.$ngfHeight = height, deferred.resolve({
                        width: width,
                        height: height
                    });
                }
                function error() {
                    img.remove(), deferred.reject("load error");
                }
                function checkLoadErrorInCaseOfNoCallback() {
                    $timeout(function() {
                        img[0].parentNode && (img[0].clientWidth ? success() : secondsCounter++ > 10 ? error() : checkLoadErrorInCaseOfNoCallback());
                    }, 1e3);
                }
                var img = angular.element("<img>").attr("src", dataUrl).css("visibility", "hidden").css("position", "fixed").css("max-width", "none !important").css("max-height", "none !important");
                img.on("load", success), img.on("error", error);
                var secondsCounter = 0;
                checkLoadErrorInCaseOfNoCallback(), angular.element(document.getElementsByTagName("body")[0]).append(img);
            }, function() {
                deferred.reject("load error");
            });
        }), file.$ngfDimensionPromise = deferred.promise, file.$ngfDimensionPromise.finally(function() {
            delete file.$ngfDimensionPromise;
        }), file.$ngfDimensionPromise;
    }, upload.mediaDuration = function(file) {
        if (file.$ngfDuration) {
            var d = $q.defer();
            return $timeout(function() {
                d.resolve(file.$ngfDuration);
            }), d.promise;
        }
        if (file.$ngfDurationPromise) return file.$ngfDurationPromise;
        var deferred = $q.defer();
        return $timeout(function() {
            return 0 !== file.type.indexOf("audio") && 0 !== file.type.indexOf("video") ? void deferred.reject("not media") : void upload.dataUrl(file).then(function(dataUrl) {
                function success() {
                    var duration = el[0].duration;
                    file.$ngfDuration = duration, el.remove(), deferred.resolve(duration);
                }
                function error() {
                    el.remove(), deferred.reject("load error");
                }
                function checkLoadError() {
                    $timeout(function() {
                        el[0].parentNode && (el[0].duration ? success() : count > 10 ? error() : checkLoadError());
                    }, 1e3);
                }
                var el = angular.element(0 === file.type.indexOf("audio") ? "<audio>" : "<video>").attr("src", dataUrl).css("visibility", "none").css("position", "fixed");
                el.on("loadedmetadata", success), el.on("error", error);
                var count = 0;
                checkLoadError(), angular.element(document.body).append(el);
            }, function() {
                deferred.reject("load error");
            });
        }), file.$ngfDurationPromise = deferred.promise, file.$ngfDurationPromise.finally(function() {
            delete file.$ngfDurationPromise;
        }), file.$ngfDurationPromise;
    }, upload;
} ]), ngFileUpload.service("UploadResize", [ "UploadValidate", "$q", function(UploadValidate, $q) {
    var upload = UploadValidate, calculateAspectRatioFit = function(srcWidth, srcHeight, maxWidth, maxHeight, centerCrop) {
        var ratio = centerCrop ? Math.max(maxWidth / srcWidth, maxHeight / srcHeight) : Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
        return {
            width: srcWidth * ratio,
            height: srcHeight * ratio,
            marginX: srcWidth * ratio - maxWidth,
            marginY: srcHeight * ratio - maxHeight
        };
    }, resize = function(imagen, width, height, quality, type, ratio, centerCrop, resizeIf) {
        var deferred = $q.defer(), canvasElement = document.createElement("canvas"), imageElement = document.createElement("img");
        return imageElement.setAttribute("style", "visibility:hidden;position:fixed;z-index:-100000"), 
        document.body.appendChild(imageElement), imageElement.onload = function() {
            var imgWidth = imageElement.width, imgHeight = imageElement.height;
            if (imageElement.parentNode.removeChild(imageElement), null != resizeIf && !1 === resizeIf(imgWidth, imgHeight)) return void deferred.reject("resizeIf");
            try {
                if (ratio) {
                    var ratioFloat = upload.ratioToFloat(ratio);
                    imgWidth / imgHeight < ratioFloat ? (width = imgWidth, height = width / ratioFloat) : (height = imgHeight, 
                    width = height * ratioFloat);
                }
                width || (width = imgWidth), height || (height = imgHeight);
                var dimensions = calculateAspectRatioFit(imgWidth, imgHeight, width, height, centerCrop);
                canvasElement.width = Math.min(dimensions.width, width), canvasElement.height = Math.min(dimensions.height, height);
                canvasElement.getContext("2d").drawImage(imageElement, Math.min(0, -dimensions.marginX / 2), Math.min(0, -dimensions.marginY / 2), dimensions.width, dimensions.height), 
                deferred.resolve(canvasElement.toDataURL(type || "image/WebP", quality || .934));
            } catch (e) {
                deferred.reject(e);
            }
        }, imageElement.onerror = function() {
            imageElement.parentNode.removeChild(imageElement), deferred.reject();
        }, imageElement.src = imagen, deferred.promise;
    };
    return upload.dataUrltoBlob = function(dataurl, name, origSize) {
        for (var arr = dataurl.split(","), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); n--; ) u8arr[n] = bstr.charCodeAt(n);
        var blob = new window.Blob([ u8arr ], {
            type: mime
        });
        return blob.name = name, blob.$ngfOrigSize = origSize, blob;
    }, upload.isResizeSupported = function() {
        var elem = document.createElement("canvas");
        return window.atob && elem.getContext && elem.getContext("2d") && window.Blob;
    }, upload.isResizeSupported() && Object.defineProperty(window.Blob.prototype, "name", {
        get: function() {
            return this.$ngfName;
        },
        set: function(v) {
            this.$ngfName = v;
        },
        configurable: !0
    }), upload.resize = function(file, options) {
        if (0 !== file.type.indexOf("image")) return upload.emptyPromise(file);
        var deferred = $q.defer();
        return upload.dataUrl(file, !0).then(function(url) {
            resize(url, options.width, options.height, options.quality, options.type || file.type, options.ratio, options.centerCrop, options.resizeIf).then(function(dataUrl) {
                if ("image/jpeg" === file.type && !1 !== options.restoreExif) try {
                    dataUrl = upload.restoreExif(url, dataUrl);
                } catch (e) {
                    setTimeout(function() {
                        throw e;
                    }, 1);
                }
                try {
                    var blob = upload.dataUrltoBlob(dataUrl, file.name, file.size);
                    deferred.resolve(blob);
                } catch (e) {
                    deferred.reject(e);
                }
            }, function(r) {
                "resizeIf" === r && deferred.resolve(file), deferred.reject(r);
            });
        }, function(e) {
            deferred.reject(e);
        }), deferred.promise;
    }, upload;
} ]), function() {
    function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, upload, $http, $q) {
        function isDisabled() {
            return elem.attr("disabled") || attrGetter("ngfDropDisabled", scope);
        }
        function extractFilesAndUpdateModel(source, evt, updateOnType) {
            if (source) {
                var html;
                try {
                    html = source && source.getData && source.getData("text/html");
                } catch (e) {}
                extractFiles(source.items, source.files, !1 !== attrGetter("ngfAllowDir", scope), attrGetter("multiple") || attrGetter("ngfMultiple", scope)).then(function(files) {
                    files.length ? updateModel(files, evt) : extractFilesFromHtml(updateOnType, html).then(function(files) {
                        updateModel(files, evt);
                    });
                });
            }
        }
        function updateModel(files, evt) {
            upload.updateModel(ngModel, attr, scope, attrGetter("ngfChange") || attrGetter("ngfDrop"), files, evt);
        }
        function extractFilesFromHtml(updateOn, html) {
            if (!upload.shouldUpdateOn(updateOn, attr, scope) || "string" != typeof html) return upload.rejectPromise([]);
            var urls = [];
            html.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi, function(m, n, src) {
                urls.push(src);
            });
            var promises = [], files = [];
            if (urls.length) {
                angular.forEach(urls, function(url) {
                    promises.push(upload.urlToBlob(url).then(function(blob) {
                        files.push(blob);
                    }));
                });
                var defer = $q.defer();
                return $q.all(promises).then(function() {
                    defer.resolve(files);
                }, function(e) {
                    defer.reject(e);
                }), defer.promise;
            }
            return upload.emptyPromise();
        }
        function calculateDragOverClass(scope, attr, evt, callback) {
            var obj = attrGetter("ngfDragOverClass", scope, {
                $event: evt
            }), dClass = "dragover";
            if (angular.isString(obj)) dClass = obj; else if (obj && (obj.delay && (dragOverDelay = obj.delay), 
            obj.accept || obj.reject)) {
                var items = evt.dataTransfer.items;
                if (null != items && items.length) for (var pattern = obj.pattern || attrGetter("ngfPattern", scope, {
                    $event: evt
                }), len = items.length; len--; ) {
                    if (!upload.validatePattern(items[len], pattern)) {
                        dClass = obj.reject;
                        break;
                    }
                    dClass = obj.accept;
                } else dClass = obj.accept;
            }
            callback(dClass);
        }
        function extractFiles(items, fileList, allowDir, multiple) {
            function traverseFileTree(entry, path) {
                var defer = $q.defer();
                if (null != entry) if (entry.isDirectory) {
                    var promises = [ upload.emptyPromise() ];
                    if (includeDir) {
                        var file = {
                            type: "directory"
                        };
                        file.name = file.path = (path || "") + entry.name, files.push(file);
                    }
                    var dirReader = entry.createReader(), entries = [], readEntries = function() {
                        dirReader.readEntries(function(results) {
                            try {
                                results.length ? (entries = entries.concat(Array.prototype.slice.call(results || [], 0)), 
                                readEntries()) : (angular.forEach(entries.slice(0), function(e) {
                                    files.length <= maxFiles && totalSize <= maxTotalSize && promises.push(traverseFileTree(e, (path || "") + entry.name + "/"));
                                }), $q.all(promises).then(function() {
                                    defer.resolve();
                                }, function(e) {
                                    defer.reject(e);
                                }));
                            } catch (e) {
                                defer.reject(e);
                            }
                        }, function(e) {
                            defer.reject(e);
                        });
                    };
                    readEntries();
                } else entry.file(function(file) {
                    try {
                        file.path = (path || "") + file.name, includeDir && (file = upload.rename(file, file.path)), 
                        files.push(file), totalSize += file.size, defer.resolve();
                    } catch (e) {
                        defer.reject(e);
                    }
                }, function(e) {
                    defer.reject(e);
                });
                return defer.promise;
            }
            var maxFiles = upload.getValidationAttr(attr, scope, "maxFiles");
            null == maxFiles && (maxFiles = Number.MAX_VALUE);
            var maxTotalSize = upload.getValidationAttr(attr, scope, "maxTotalSize");
            null == maxTotalSize && (maxTotalSize = Number.MAX_VALUE);
            var includeDir = attrGetter("ngfIncludeDir", scope), files = [], totalSize = 0, promises = [ upload.emptyPromise() ];
            if (items && items.length > 0 && "file:" !== $window.location.protocol) for (var i = 0; i < items.length; i++) {
                if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
                    var entry = items[i].webkitGetAsEntry();
                    if (entry.isDirectory && !allowDir) continue;
                    null != entry && promises.push(traverseFileTree(entry));
                } else {
                    var f = items[i].getAsFile();
                    null != f && (files.push(f), totalSize += f.size);
                }
                if (files.length > maxFiles || totalSize > maxTotalSize || !multiple && files.length > 0) break;
            } else if (null != fileList) for (var j = 0; j < fileList.length; j++) {
                var file = fileList.item(j);
                if ((file.type || file.size > 0) && (files.push(file), totalSize += file.size), 
                files.length > maxFiles || totalSize > maxTotalSize || !multiple && files.length > 0) break;
            }
            var defer = $q.defer();
            return $q.all(promises).then(function() {
                if (multiple || includeDir || !files.length) defer.resolve(files); else {
                    for (var i = 0; files[i] && "directory" === files[i].type; ) i++;
                    defer.resolve([ files[i] ]);
                }
            }, function(e) {
                defer.reject(e);
            }), defer.promise;
        }
        var available = dropAvailable(), attrGetter = function(name, scope, params) {
            return upload.attrGetter(name, attr, scope, params);
        };
        if (attrGetter("dropAvailable") && $timeout(function() {
            scope[attrGetter("dropAvailable")] ? scope[attrGetter("dropAvailable")].value = available : scope[attrGetter("dropAvailable")] = available;
        }), !available) return void (!0 === attrGetter("ngfHideOnDropNotAvailable", scope) && elem.css("display", "none"));
        null == attrGetter("ngfSelect") && upload.registerModelChangeValidator(ngModel, attr, scope);
        var actualDragOverClass, leaveTimeout = null, stopPropagation = $parse(attrGetter("ngfStopPropagation")), dragOverDelay = 1;
        elem[0].addEventListener("dragover", function(evt) {
            if (!isDisabled() && upload.shouldUpdateOn("drop", attr, scope)) {
                if (evt.preventDefault(), stopPropagation(scope) && evt.stopPropagation(), navigator.userAgent.indexOf("Chrome") > -1) {
                    var b = evt.dataTransfer.effectAllowed;
                    evt.dataTransfer.dropEffect = "move" === b || "linkMove" === b ? "move" : "copy";
                }
                $timeout.cancel(leaveTimeout), actualDragOverClass || (actualDragOverClass = "C", 
                calculateDragOverClass(scope, attr, evt, function(clazz) {
                    actualDragOverClass = clazz, elem.addClass(actualDragOverClass), attrGetter("ngfDrag", scope, {
                        $isDragging: !0,
                        $class: actualDragOverClass,
                        $event: evt
                    });
                }));
            }
        }, !1), elem[0].addEventListener("dragenter", function(evt) {
            !isDisabled() && upload.shouldUpdateOn("drop", attr, scope) && (evt.preventDefault(), 
            stopPropagation(scope) && evt.stopPropagation());
        }, !1), elem[0].addEventListener("dragleave", function(evt) {
            !isDisabled() && upload.shouldUpdateOn("drop", attr, scope) && (evt.preventDefault(), 
            stopPropagation(scope) && evt.stopPropagation(), leaveTimeout = $timeout(function() {
                actualDragOverClass && elem.removeClass(actualDragOverClass), actualDragOverClass = null, 
                attrGetter("ngfDrag", scope, {
                    $isDragging: !1,
                    $event: evt
                });
            }, dragOverDelay || 100));
        }, !1), elem[0].addEventListener("drop", function(evt) {
            !isDisabled() && upload.shouldUpdateOn("drop", attr, scope) && (evt.preventDefault(), 
            stopPropagation(scope) && evt.stopPropagation(), actualDragOverClass && elem.removeClass(actualDragOverClass), 
            actualDragOverClass = null, extractFilesAndUpdateModel(evt.dataTransfer, evt, "dropUrl"));
        }, !1), elem[0].addEventListener("paste", function(evt) {
            navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && attrGetter("ngfEnableFirefoxPaste", scope) && evt.preventDefault(), 
            !isDisabled() && upload.shouldUpdateOn("paste", attr, scope) && extractFilesAndUpdateModel(evt.clipboardData || evt.originalEvent.clipboardData, evt, "pasteUrl");
        }, !1), navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && attrGetter("ngfEnableFirefoxPaste", scope) && (elem.attr("contenteditable", !0), 
        elem.on("keypress", function(e) {
            e.metaKey || e.ctrlKey || e.preventDefault();
        }));
    }
    function dropAvailable() {
        var div = document.createElement("div");
        return "draggable" in div && "ondrop" in div && !/Edge\/12./i.test(navigator.userAgent);
    }
    ngFileUpload.directive("ngfDrop", [ "$parse", "$timeout", "$window", "Upload", "$http", "$q", function($parse, $timeout, $window, Upload, $http, $q) {
        return {
            restrict: "AEC",
            require: "?ngModel",
            link: function(scope, elem, attr, ngModel) {
                linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, Upload, $http, $q);
            }
        };
    } ]), ngFileUpload.directive("ngfNoFileDrop", function() {
        return function(scope, elem) {
            dropAvailable() && elem.css("display", "none");
        };
    }), ngFileUpload.directive("ngfDropAvailable", [ "$parse", "$timeout", "Upload", function($parse, $timeout, Upload) {
        return function(scope, elem, attr) {
            if (dropAvailable()) {
                var model = $parse(Upload.attrGetter("ngfDropAvailable", attr));
                $timeout(function() {
                    model(scope), model.assign && model.assign(scope, !0);
                });
            }
        };
    } ]);
}(), ngFileUpload.service("UploadExif", [ "UploadResize", "$q", function(UploadResize, $q) {
    function applyTransform(ctx, orientation, width, height) {
        switch (orientation) {
          case 2:
            return ctx.transform(-1, 0, 0, 1, width, 0);

          case 3:
            return ctx.transform(-1, 0, 0, -1, width, height);

          case 4:
            return ctx.transform(1, 0, 0, -1, 0, height);

          case 5:
            return ctx.transform(0, 1, 1, 0, 0, 0);

          case 6:
            return ctx.transform(0, 1, -1, 0, height, 0);

          case 7:
            return ctx.transform(0, -1, -1, 0, height, width);

          case 8:
            return ctx.transform(0, -1, 1, 0, 0, width);
        }
    }
    function arrayBufferToBase64(buffer) {
        for (var binary = "", bytes = new Uint8Array(buffer), len = bytes.byteLength, i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
        return window.btoa(binary);
    }
    var upload = UploadResize;
    return upload.isExifSupported = function() {
        return window.FileReader && new FileReader().readAsArrayBuffer && upload.isResizeSupported();
    }, upload.readOrientation = function(file) {
        var defer = $q.defer(), reader = new FileReader(), slicedFile = file.slice ? file.slice(0, 65536) : file;
        return reader.readAsArrayBuffer(slicedFile), reader.onerror = function(e) {
            return defer.reject(e);
        }, reader.onload = function(e) {
            var result = {
                orientation: 1
            }, view = new DataView(this.result);
            if (65496 !== view.getUint16(0, !1)) return defer.resolve(result);
            for (var length = view.byteLength, offset = 2; offset < length; ) {
                var marker = view.getUint16(offset, !1);
                if (offset += 2, 65505 === marker) {
                    if (1165519206 !== view.getUint32(offset += 2, !1)) return defer.resolve(result);
                    var little = 18761 === view.getUint16(offset += 6, !1);
                    offset += view.getUint32(offset + 4, little);
                    var tags = view.getUint16(offset, little);
                    offset += 2;
                    for (var i = 0; i < tags; i++) if (274 === view.getUint16(offset + 12 * i, little)) {
                        var orientation = view.getUint16(offset + 12 * i + 8, little);
                        return orientation >= 2 && orientation <= 8 && (view.setUint16(offset + 12 * i + 8, 1, little), 
                        result.fixedArrayBuffer = e.target.result), result.orientation = orientation, defer.resolve(result);
                    }
                } else {
                    if (65280 != (65280 & marker)) break;
                    offset += view.getUint16(offset, !1);
                }
            }
            return defer.resolve(result);
        }, defer.promise;
    }, upload.applyExifRotation = function(file) {
        if (0 !== file.type.indexOf("image/jpeg")) return upload.emptyPromise(file);
        var deferred = $q.defer();
        return upload.readOrientation(file).then(function(result) {
            return result.orientation < 2 || result.orientation > 8 ? deferred.resolve(file) : void upload.dataUrl(file, !0).then(function(url) {
                var canvas = document.createElement("canvas"), img = document.createElement("img");
                img.onload = function() {
                    try {
                        canvas.width = result.orientation > 4 ? img.height : img.width, canvas.height = result.orientation > 4 ? img.width : img.height;
                        var ctx = canvas.getContext("2d");
                        applyTransform(ctx, result.orientation, img.width, img.height), ctx.drawImage(img, 0, 0);
                        var dataUrl = canvas.toDataURL(file.type || "image/WebP", .934);
                        dataUrl = upload.restoreExif(arrayBufferToBase64(result.fixedArrayBuffer), dataUrl);
                        var blob = upload.dataUrltoBlob(dataUrl, file.name);
                        deferred.resolve(blob);
                    } catch (e) {
                        return deferred.reject(e);
                    }
                }, img.onerror = function() {
                    deferred.reject();
                }, img.src = url;
            }, function(e) {
                deferred.reject(e);
            });
        }, function(e) {
            deferred.reject(e);
        }), deferred.promise;
    }, upload.restoreExif = function(orig, resized) {
        var ExifRestorer = {};
        return ExifRestorer.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", 
        ExifRestorer.encode64 = function(input) {
            var chr1, chr2, enc1, enc2, enc3, output = "", chr3 = "", enc4 = "", i = 0;
            do {
                chr1 = input[i++], chr2 = input[i++], chr3 = input[i++], enc1 = chr1 >> 2, enc2 = (3 & chr1) << 4 | chr2 >> 4, 
                enc3 = (15 & chr2) << 2 | chr3 >> 6, enc4 = 63 & chr3, isNaN(chr2) ? enc3 = enc4 = 64 : isNaN(chr3) && (enc4 = 64), 
                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4), 
                chr1 = chr2 = chr3 = "", enc1 = enc2 = enc3 = enc4 = "";
            } while (i < input.length);
            return output;
        }, ExifRestorer.restore = function(origFileBase64, resizedFileBase64) {
            origFileBase64.match("data:image/jpeg;base64,") && (origFileBase64 = origFileBase64.replace("data:image/jpeg;base64,", ""));
            var rawImage = this.decode64(origFileBase64), segments = this.slice2Segments(rawImage), image = this.exifManipulation(resizedFileBase64, segments);
            return "data:image/jpeg;base64," + this.encode64(image);
        }, ExifRestorer.exifManipulation = function(resizedFileBase64, segments) {
            var exifArray = this.getExifArray(segments), newImageArray = this.insertExif(resizedFileBase64, exifArray);
            return new Uint8Array(newImageArray);
        }, ExifRestorer.getExifArray = function(segments) {
            for (var seg, x = 0; x < segments.length; x++) if (seg = segments[x], 255 === seg[0] & 225 === seg[1]) return seg;
            return [];
        }, ExifRestorer.insertExif = function(resizedFileBase64, exifArray) {
            var imageData = resizedFileBase64.replace("data:image/jpeg;base64,", ""), buf = this.decode64(imageData), separatePoint = buf.indexOf(255, 3), mae = buf.slice(0, separatePoint), ato = buf.slice(separatePoint), array = mae;
            return array = array.concat(exifArray), array = array.concat(ato);
        }, ExifRestorer.slice2Segments = function(rawImageArray) {
            for (var head = 0, segments = []; !(255 === rawImageArray[head] & 218 === rawImageArray[head + 1]); ) {
                if (255 === rawImageArray[head] & 216 === rawImageArray[head + 1]) head += 2; else {
                    var length = 256 * rawImageArray[head + 2] + rawImageArray[head + 3], endPoint = head + length + 2, seg = rawImageArray.slice(head, endPoint);
                    segments.push(seg), head = endPoint;
                }
                if (head > rawImageArray.length) break;
            }
            return segments;
        }, ExifRestorer.decode64 = function(input) {
            var chr1, chr2, enc1, enc2, enc3, chr3 = "", enc4 = "", i = 0, buf = [];
            /[^A-Za-z0-9\+\/\=]/g.exec(input) && console.log("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, NaNExpect errors in decoding."), 
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            do {
                enc1 = this.KEY_STR.indexOf(input.charAt(i++)), enc2 = this.KEY_STR.indexOf(input.charAt(i++)), 
                enc3 = this.KEY_STR.indexOf(input.charAt(i++)), enc4 = this.KEY_STR.indexOf(input.charAt(i++)), 
                chr1 = enc1 << 2 | enc2 >> 4, chr2 = (15 & enc2) << 4 | enc3 >> 2, chr3 = (3 & enc3) << 6 | enc4, 
                buf.push(chr1), 64 !== enc3 && buf.push(chr2), 64 !== enc4 && buf.push(chr3), chr1 = chr2 = chr3 = "", 
                enc1 = enc2 = enc3 = enc4 = "";
            } while (i < input.length);
            return buf;
        }, ExifRestorer.restore(orig, resized);
    }, upload;
} ]), define("ng-file-upload", [ "angular" ], function() {}), "undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "angular-md5"), 
function(angular) {
    angular.module("angular-md5", [ "gdi2290.md5" ]), angular.module("ngMd5", [ "gdi2290.md5" ]), 
    angular.module("gdi2290.md5", [ "gdi2290.gravatar-filter", "gdi2290.md5-service", "gdi2290.md5-filter" ]), 
    angular.module("gdi2290.gravatar-filter", []).filter("gravatar", [ "md5", function(md5) {
        var cache = {};
        return function(text, defaultText) {
            return cache[text] || (defaultText = defaultText ? md5.createHash(defaultText.toString().toLowerCase()) : "", 
            cache[text] = text ? md5.createHash(text.toString().toLowerCase()) : defaultText), 
            cache[text];
        };
    } ]), angular.module("gdi2290.md5-filter", []).filter("md5", [ "md5", function(md5) {
        return function(text) {
            return text ? md5.createHash(text.toString().toLowerCase()) : text;
        };
    } ]), angular.module("gdi2290.md5-service", []).factory("md5", [ function() {
        return {
            createHash: function(str) {
                if (null === str) return null;
                var xl, k, AA, BB, CC, DD, a, b, c, d, rotateLeft = function(lValue, iShiftBits) {
                    return lValue << iShiftBits | lValue >>> 32 - iShiftBits;
                }, addUnsigned = function(lX, lY) {
                    var lX4, lY4, lX8, lY8, lResult;
                    return lX8 = 2147483648 & lX, lY8 = 2147483648 & lY, lX4 = 1073741824 & lX, lY4 = 1073741824 & lY, 
                    lResult = (1073741823 & lX) + (1073741823 & lY), lX4 & lY4 ? 2147483648 ^ lResult ^ lX8 ^ lY8 : lX4 | lY4 ? 1073741824 & lResult ? 3221225472 ^ lResult ^ lX8 ^ lY8 : 1073741824 ^ lResult ^ lX8 ^ lY8 : lResult ^ lX8 ^ lY8;
                }, _F = function(x, y, z) {
                    return x & y | ~x & z;
                }, _G = function(x, y, z) {
                    return x & z | y & ~z;
                }, _H = function(x, y, z) {
                    return x ^ y ^ z;
                }, _I = function(x, y, z) {
                    return y ^ (x | ~z);
                }, _FF = function(a, b, c, d, x, s, ac) {
                    return a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac)), addUnsigned(rotateLeft(a, s), b);
                }, _GG = function(a, b, c, d, x, s, ac) {
                    return a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac)), addUnsigned(rotateLeft(a, s), b);
                }, _HH = function(a, b, c, d, x, s, ac) {
                    return a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac)), addUnsigned(rotateLeft(a, s), b);
                }, _II = function(a, b, c, d, x, s, ac) {
                    return a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac)), addUnsigned(rotateLeft(a, s), b);
                }, wordToHex = function(lValue) {
                    var lByte, lCount, wordToHexValue = "", wordToHexValue_temp = "";
                    for (lCount = 0; lCount <= 3; lCount++) lByte = lValue >>> 8 * lCount & 255, wordToHexValue_temp = "0" + lByte.toString(16), 
                    wordToHexValue += wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
                    return wordToHexValue;
                }, x = [];
                for (x = function(str) {
                    for (var lWordCount, lMessageLength = str.length, lNumberOfWords_temp1 = lMessageLength + 8, lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64, lNumberOfWords = 16 * (lNumberOfWords_temp2 + 1), lWordArray = new Array(lNumberOfWords - 1), lBytePosition = 0, lByteCount = 0; lByteCount < lMessageLength; ) lWordCount = (lByteCount - lByteCount % 4) / 4, 
                    lBytePosition = lByteCount % 4 * 8, lWordArray[lWordCount] = lWordArray[lWordCount] | str.charCodeAt(lByteCount) << lBytePosition, 
                    lByteCount++;
                    return lWordCount = (lByteCount - lByteCount % 4) / 4, lBytePosition = lByteCount % 4 * 8, 
                    lWordArray[lWordCount] = lWordArray[lWordCount] | 128 << lBytePosition, lWordArray[lNumberOfWords - 2] = lMessageLength << 3, 
                    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29, lWordArray;
                }(str), a = 1732584193, b = 4023233417, c = 2562383102, d = 271733878, xl = x.length, 
                k = 0; k < xl; k += 16) AA = a, BB = b, CC = c, DD = d, a = _FF(a, b, c, d, x[k + 0], 7, 3614090360), 
                d = _FF(d, a, b, c, x[k + 1], 12, 3905402710), c = _FF(c, d, a, b, x[k + 2], 17, 606105819), 
                b = _FF(b, c, d, a, x[k + 3], 22, 3250441966), a = _FF(a, b, c, d, x[k + 4], 7, 4118548399), 
                d = _FF(d, a, b, c, x[k + 5], 12, 1200080426), c = _FF(c, d, a, b, x[k + 6], 17, 2821735955), 
                b = _FF(b, c, d, a, x[k + 7], 22, 4249261313), a = _FF(a, b, c, d, x[k + 8], 7, 1770035416), 
                d = _FF(d, a, b, c, x[k + 9], 12, 2336552879), c = _FF(c, d, a, b, x[k + 10], 17, 4294925233), 
                b = _FF(b, c, d, a, x[k + 11], 22, 2304563134), a = _FF(a, b, c, d, x[k + 12], 7, 1804603682), 
                d = _FF(d, a, b, c, x[k + 13], 12, 4254626195), c = _FF(c, d, a, b, x[k + 14], 17, 2792965006), 
                b = _FF(b, c, d, a, x[k + 15], 22, 1236535329), a = _GG(a, b, c, d, x[k + 1], 5, 4129170786), 
                d = _GG(d, a, b, c, x[k + 6], 9, 3225465664), c = _GG(c, d, a, b, x[k + 11], 14, 643717713), 
                b = _GG(b, c, d, a, x[k + 0], 20, 3921069994), a = _GG(a, b, c, d, x[k + 5], 5, 3593408605), 
                d = _GG(d, a, b, c, x[k + 10], 9, 38016083), c = _GG(c, d, a, b, x[k + 15], 14, 3634488961), 
                b = _GG(b, c, d, a, x[k + 4], 20, 3889429448), a = _GG(a, b, c, d, x[k + 9], 5, 568446438), 
                d = _GG(d, a, b, c, x[k + 14], 9, 3275163606), c = _GG(c, d, a, b, x[k + 3], 14, 4107603335), 
                b = _GG(b, c, d, a, x[k + 8], 20, 1163531501), a = _GG(a, b, c, d, x[k + 13], 5, 2850285829), 
                d = _GG(d, a, b, c, x[k + 2], 9, 4243563512), c = _GG(c, d, a, b, x[k + 7], 14, 1735328473), 
                b = _GG(b, c, d, a, x[k + 12], 20, 2368359562), a = _HH(a, b, c, d, x[k + 5], 4, 4294588738), 
                d = _HH(d, a, b, c, x[k + 8], 11, 2272392833), c = _HH(c, d, a, b, x[k + 11], 16, 1839030562), 
                b = _HH(b, c, d, a, x[k + 14], 23, 4259657740), a = _HH(a, b, c, d, x[k + 1], 4, 2763975236), 
                d = _HH(d, a, b, c, x[k + 4], 11, 1272893353), c = _HH(c, d, a, b, x[k + 7], 16, 4139469664), 
                b = _HH(b, c, d, a, x[k + 10], 23, 3200236656), a = _HH(a, b, c, d, x[k + 13], 4, 681279174), 
                d = _HH(d, a, b, c, x[k + 0], 11, 3936430074), c = _HH(c, d, a, b, x[k + 3], 16, 3572445317), 
                b = _HH(b, c, d, a, x[k + 6], 23, 76029189), a = _HH(a, b, c, d, x[k + 9], 4, 3654602809), 
                d = _HH(d, a, b, c, x[k + 12], 11, 3873151461), c = _HH(c, d, a, b, x[k + 15], 16, 530742520), 
                b = _HH(b, c, d, a, x[k + 2], 23, 3299628645), a = _II(a, b, c, d, x[k + 0], 6, 4096336452), 
                d = _II(d, a, b, c, x[k + 7], 10, 1126891415), c = _II(c, d, a, b, x[k + 14], 15, 2878612391), 
                b = _II(b, c, d, a, x[k + 5], 21, 4237533241), a = _II(a, b, c, d, x[k + 12], 6, 1700485571), 
                d = _II(d, a, b, c, x[k + 3], 10, 2399980690), c = _II(c, d, a, b, x[k + 10], 15, 4293915773), 
                b = _II(b, c, d, a, x[k + 1], 21, 2240044497), a = _II(a, b, c, d, x[k + 8], 6, 1873313359), 
                d = _II(d, a, b, c, x[k + 15], 10, 4264355552), c = _II(c, d, a, b, x[k + 6], 15, 2734768916), 
                b = _II(b, c, d, a, x[k + 13], 21, 1309151649), a = _II(a, b, c, d, x[k + 4], 6, 4149444226), 
                d = _II(d, a, b, c, x[k + 11], 10, 3174756917), c = _II(c, d, a, b, x[k + 2], 15, 718787259), 
                b = _II(b, c, d, a, x[k + 9], 21, 3951481745), a = addUnsigned(a, AA), b = addUnsigned(b, BB), 
                c = addUnsigned(c, CC), d = addUnsigned(d, DD);
                return (wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)).toLowerCase();
            }
        };
    } ]);
}(angular), define("angular-md5", [ "angular" ], function() {}), define("siglasApp", [ "routes", "services/dependencyResolverFor", "services/protectedRoute", "i18n/i18nLoader!", "angular", "angular-route", "bootstrap", "angular-translate", "angular-local-storage", "angular-animate", "angular-toastr", "angular-jwt", "angular-bootstrap", "lodash", "async", "angular-moment", "angular-sanitize", "ngBootbox", "ng-file-upload", "angular-md5" ], function(config, dependencyResolverFor, protectedRoute, i18n) {
    var siglasApp = angular.module("siglasApp", [ "ngRoute", "ngSanitize", "pascalprecht.translate", "LocalStorageModule", "ngAnimate", "toastr", "angular-jwt", "ui.bootstrap", "angularMoment", "ngBootbox", "ngFileUpload", "angular-md5" ]);
    return siglasApp.constant("HOST", "localhost:8081/webapp").config([ "$routeProvider", "$controllerProvider", "$compileProvider", "$filterProvider", "$provide", "$translateProvider", "$httpProvider", "localStorageServiceProvider", function($routeProvider, $controllerProvider, $compileProvider, $filterProvider, $provide, $translateProvider, $httpProvider, localStorageServiceProvider) {
        siglasApp.controller = $controllerProvider.register, siglasApp.directive = $compileProvider.directive, 
        siglasApp.filter = $filterProvider.register, siglasApp.factory = $provide.factory, 
        siglasApp.service = $provide.service, void 0 !== config.routes && angular.forEach(config.routes, function(route, path) {
            var controllers = _.map([ route.controller ].concat(route.controllers || []), function(controller) {
                return "controllers/" + controller;
            });
            $routeProvider.when(path, {
                templateUrl: route.templateUrl,
                resolve: {
                    controllers: dependencyResolverFor(controllers).resolver,
                    protected: protectedRoute(route).resolver
                },
                controller: route.controller,
                controllerAs: route.controllerAs,
                reloadOnSearch: !1
            });
        }), void 0 !== config.defaultRoutePath && $routeProvider.otherwise({
            redirectTo: config.defaultRoutePath
        }), $translateProvider.translations("preferredLanguage", i18n), $translateProvider.preferredLanguage("preferredLanguage"), 
        $translateProvider.useSanitizeValueStrategy("sce"), $httpProvider.defaults.headers.common["Content-Type"] = "application/json", 
        localStorageServiceProvider.setPrefix("siglas"), $provide.decorator("$q", [ "$delegate", function($delegate) {
            var originalDefer = $delegate.defer;
            return $delegate.defer = function() {
                var promiseProto = originalDefer().promise.constructor.prototype;
                return Object.defineProperty(promiseProto, "spread", {
                    value: function(resolve, reject) {
                        function spread(data) {
                            return resolve.apply(null, data);
                        }
                        return this.then(spread, reject);
                    },
                    writable: !0,
                    enumerable: !1
                }), originalDefer();
            }, $delegate;
        } ]);
    } ]).run([ "$rootScope", "$location", "$route", "$q", "$http", "$window", "AuthService", "FavouritesService", "amMoment", function($rootScope, $location, $route, $q, $http, $window, AuthService, FavouritesService, amMoment) {
        function onSync(profile) {
            console.log("profile", profile), profile && ($rootScope.loggedUser = profile, $rootScope.loggedUser.favourites = [], 
            FavouritesService.mine({
                pageNumber: 0,
                pageSize: 8,
                sortOrder: "DESC",
                sortField: "CREATED"
            }).then(function(result) {
                $rootScope.loggedUser.favourites = result.results, $rootScope.loggedUser.favourites.hasMore = result.numberOfTotalResults > result.numberOfAvailableResults;
            }, function(error) {
                console.error(error);
            }), /^\/auth/.test($location.path()) && $location.path("/")), $rootScope.loading = !1;
        }
        amMoment.changeLocale("es"), $rootScope.$on("$routeChangeStart", function(event, next, current) {
            console.log("$routeChangeStart " + (current || {
                loadedTemplateUrl: "none"
            }).loadedTemplateUrl + " -> " + next.loadedTemplateUrl);
        }), $rootScope.$on("$routeChangeSuccess", function(event, next, current) {
            console.log("$routeChangeSuccess " + (current || {
                loadedTemplateUrl: "none"
            }).loadedTemplateUrl + " -> " + next.loadedTemplateUrl);
        }), $rootScope.loading = !0, AuthService.syncWithLocalStorage().then(onSync, function(error) {
            console.log(error), $rootScope.loading = !1, $location.path("/"), $rootScope.loggedUser = null;
        });
    } ]), siglasApp;
}), define("services/IdService", [ "siglasApp" ], function(siglasApp) {
    siglasApp.service("IdService", [ "$http", "$q", "localStorageService", "jwtHelper", "HOST", function($http, $q, localStorageService, jwtHelper, HOST) {
        function byUsername(username) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/id/" + username)
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error.data);
            }), defer.promise;
        }
        function profile(username) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/id/" + username + "/profile")
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error.data);
            }), defer.promise;
        }
        function published(username, query) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/id/" + username + "/published"),
                params: query
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error.data);
            }), defer.promise;
        }
        var Id = {};
        Id.byUsername = byUsername, Id.profile = profile, Id.published = published;
        var api = function(path) {
            return "http://" + HOST + path;
        };
        return Id;
    } ]);
}), define("services/AuthService", [ "siglasApp", "services/IdService" ], function(siglasApp) {
    siglasApp.service("AuthService", [ "$http", "$q", "localStorageService", "jwtHelper", "IdService", "md5", "HOST", function($http, $q, localStorageService, jwtHelper, IdService, md5, HOST) {
        function setDefaultAuthorizationHeader(token) {
            $http.defaults.headers.common.Authorization = "Bearer " + token;
        }
        function removeDefaultAuthorizationHeader() {
            delete $http.defaults.headers.common.Authorization;
        }
        function logIn(username, password) {
            var defer = $q.defer();
            return $http({
                method: "POST",
                url: api("/api/auth/login"),
                data: {
                    username: username,
                    password: password
                }
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : (console.log(response.data), setDefaultAuthorizationHeader(response.data.idToken), 
                console.log($http.defaults.headers.common.Authorization), console.log("setting local storage"), 
                localStorageService.set("tokens", response.data), void defer.resolve(response.data));
            }, function(error) {
                console.log(error), defer.reject(error.data);
            }), defer.promise;
        }
        function register(user) {
            var defer = $q.defer();
            return $http({
                method: "POST",
                url: api("/api/auth/register"),
                data: JSON.stringify(user)
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : (console.log(response.data), setDefaultAuthorizationHeader(response.data.idToken), 
                console.log($http.defaults.headers.common.Authorization), console.log("setting local storage"), 
                localStorageService.set("tokens", response.data), void defer.resolve(response.data));
            }, function(error) {
                console.log(error), defer.reject(error.data);
            }), defer.promise;
        }
        function renewToken(tokens) {
            var defer = $q.defer();
            return console.log("renewing token"), $http({
                method: "POST",
                url: api("/v1/auth/renew"),
                data: angular.extend({}, tokens, {
                    appVersion: window.appVersion
                })
            }).then(function(response) {
                return console.log("renew response", response), response.status >= 400 ? (console.log(response.status), 
                localStorageService.remove("tokens"), logout().then(function() {
                    removeDefaultAuthorizationHeader(), defer.reject(error);
                }, function(err) {
                    removeDefaultAuthorizationHeader(), defer.reject(err);
                })) : (setDefaultAuthorizationHeader(response.data.tokens.accessToken), console.log($http.defaults.headers.common.Authorization), 
                console.log("setting local storage"), localStorageService.set("tokens", response.data.tokens), 
                void defer.resolve(response.data.user));
            }, function(error) {
                return console.log(error), localStorageService.remove("tokens"), logout().then(function() {
                    removeDefaultAuthorizationHeader(), defer.reject(error);
                }, function(err) {
                    removeDefaultAuthorizationHeader(), defer.reject(err);
                });
            }), defer.promise;
        }
        function forgotPass(email) {
            var defer = $q.defer();
            return $http({
                method: "POST",
                url: api("/api/auth/forgot-pass"),
                data: {
                    email: email
                }
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error.data);
            }), defer.promise;
        }
        function fetchProfile() {
            var defer = $q.defer();
            return console.log("fetching profile"), console.log($http.defaults.headers.common.Authorization), 
            $http({
                method: "GET",
                url: api("/api/me/profile")
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : (console.log("got profile", response.data), void defer.resolve(response.data));
            }, function(error) {
                console.log(error), defer.reject(error.data);
            }), defer.promise;
        }
        function syncWithLocalStorage() {
            var defer = $q.defer();
            console.log("syncWithLocalStorage");
            var tokens = localStorageService.get("tokens");
            return console.log("current token is", tokens), tokens ? jwtHelper.isTokenExpired(tokens.idToken) ? (console.log("token is expired"), 
            renewToken(tokens)) : (console.log("token is ok"), console.log("setting default $http Authorization header to " + tokens.idToken), 
            setDefaultAuthorizationHeader(tokens.idToken), fetchProfile()) : (defer.resolve(), 
            defer.promise);
        }
        function isTokenValid() {
            console.log("isTokenValid");
            var tokens = localStorageService.get("tokens");
            return console.log("current token is", tokens), !!tokens && !jwtHelper.isTokenExpired(tokens.accessToken);
        }
        function logout() {
            var defer = $q.defer();
            return console.log("logout"), removeDefaultAuthorizationHeader(), localStorageService.remove("tokens"), 
            defer.resolve(), defer.promise;
        }
        function isPasswordTokenValid(username, token) {
            var defer = $q.defer();
            return IdService.profile(username).then(function(result) {
                var timestamp = Date.now(), hexTimestamp = timestamp.toString(16), usernameHash = md5.createHash(username), generatedToken = hexTimestamp + usernameHash;
                if (generatedToken.length !== token.length) return defer.reject("INVALID");
                var tokenTimestamp = parseInt(token.substr(0, hexTimestamp.length), 16);
                return tokenTimestamp - timestamp > 0 ? defer.reject("INVALID") : timestamp - tokenTimestamp > MAX_EXPIRY ? defer.reject("EXPIRED") : generatedToken.substr(hexTimestamp.length) === token.substr(hexTimestamp.length) ? defer.resolve() : defer.reject("INVALID");
            }, function(err) {
                defer.reject(err);
            }), defer.promise;
        }
        function resetPassword(username, passwords) {
            var defer = $q.defer();
            return $http({
                method: "PUT",
                url: api("/api/id/" + username + "/reset-password"),
                data: JSON.stringify(passwords)
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        var Auth = {};
        Auth.logIn = logIn, Auth.register = register, Auth.syncWithLocalStorage = syncWithLocalStorage, 
        Auth.fetchProfile = fetchProfile, Auth.logout = logout, Auth.forgotPass = forgotPass, 
        Auth.resetPassword = resetPassword, Auth.isPasswordTokenValid = isPasswordTokenValid, 
        Auth.isTokenValid = isTokenValid;
        var api = function(path) {
            return "http://" + HOST + path;
        }, MAX_EXPIRY = 108e5;
        return Auth;
    } ]);
}), define("services/FavouritesService", [ "siglasApp" ], function(siglasApp) {
    siglasApp.service("FavouritesService", [ "$http", "$q", "localStorageService", "jwtHelper", "HOST", function($http, $q, localStorageService, jwtHelper, HOST) {
        function mine(query) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/me/favourites"),
                params: query
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function all() {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/me/favourites/all")
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function add(id) {
            var defer = $q.defer();
            return $http({
                method: "POST",
                url: api("/api/me/favourites/"),
                data: {
                    item: id
                }
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function remove(id) {
            var defer = $q.defer();
            return $http({
                method: "DELETE",
                url: api("/api/me/favourites/" + id)
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        var Favourites = {};
        Favourites.mine = mine, Favourites.all = all, Favourites.remove = remove, Favourites.add = add;
        var api = function(path) {
            return "http://" + HOST + path;
        };
        return Favourites;
    } ]);
}), define("controllers/IndexCtrl", [ "siglasApp", "services/AuthService", "services/FavouritesService" ], function(siglasApp) {
    siglasApp.controller("IndexCtrl", [ "$scope", "$rootScope", "$location", "$route", "AuthService", "toastr", "$filter", "FavouritesService", function($scope, $rootScope, $location, $route, AuthService, toastr, $filter, FavouritesService) {
        function logout() {
            AuthService.logout().then(function() {
                $rootScope.loggedUser = null, toastr.success($filter("translate")("ng.messages.logoutSuccessful")), 
                $location.path("/");
            });
        }
        function performQuery() {
            "/store/items/all" === $location.path() ? $scope.$broadcast("query.update", self.query) : $location.path("/store/items/all").search({
                query: self.query
            });
        }
        function removeFavourite(favId) {
            FavouritesService.remove(favId).then(function(result) {
                $rootScope.loggedUser.favourites = _.filter($rootScope.loggedUser.favourites, function(fav) {
                    return fav.id !== favId;
                }), $rootScope.loggedUser.favourites.hasMore = $rootScope.loggedUser.favourites.length > 8, 
                $scope.$broadcast("fav.remove", favId), toastr.success($filter("translate")("successMessages.toggleFavourite.removeSuccess"));
            }, function(err) {
                console.error(err), toastr.error($filter("translate")("successMessages.toggleFavourite.removeError"));
            });
        }
        console.log("IndexCtrl"), console.log($filter("translate")("ng.messages.logoutSuccessful"));
        var self = this;
        self.$route = $route, self.$location = $location, self.logout = logout, self.query = $location.search().query, 
        self.performQuery = performQuery, self.removeFavourite = removeFavourite;
    } ]);
}), define("services/ItemService", [ "siglasApp" ], function(siglasApp) {
    siglasApp.service("ItemService", [ "$http", "$q", "localStorageService", "jwtHelper", "HOST", function($http, $q, localStorageService, jwtHelper, HOST) {
        function mostSold(limit) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/store/most-sold"),
                params: {
                    limit: limit
                }
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data.items);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function published(query) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/me/published/"),
                params: query
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function allPublished(query) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/me/published/all")
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function pendingPurchases(query) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/me/purchased/pending")
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function findById(id) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/store/item/" + id)
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function related(id, query) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/store/item/" + id + "/related"),
                params: query
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function update(item) {
            var defer = $q.defer();
            return $http({
                method: "PUT",
                url: api("/api/store/item/" + item.id),
                data: item
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : (console.log(response), void defer.resolve(response.data));
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function create(item) {
            var defer = $q.defer();
            return $http({
                method: "POST",
                url: api("/api/store/item"),
                data: item
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : (console.log(response), void defer.resolve(response.data));
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function uploadImage(id, files) {
            var defer = $q.defer(), formData = new FormData();
            return _.each(files, function(file) {
                formData.append("images", file);
            }), $http({
                method: "PUT",
                url: api("/api/store/item/" + id + "/images"),
                data: formData,
                headers: {
                    "Content-Type": void 0
                },
                transformRequest: angular.identity
            }).then(function(response) {
                console.log(response), defer.resolve(response.data);
            }, function(error) {
                defer.reject(error);
            }), defer.promise;
        }
        function comments(id) {
            var defer = $q.defer();
            return $http({
                method: "GET",
                url: api("/api/store/item/" + id + "/comments")
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        function addComment(id, comment) {
            var defer = $q.defer();
            return $http({
                method: "POST",
                url: api("/api/store/item/" + id + "/comments"),
                data: comment
            }).then(function(response) {
                return response.status >= 400 ? (console.log(response.status), response.status, 
                defer.reject(response.data)) : void defer.resolve(response.data);
            }, function(error) {
                console.log(error), defer.reject(error);
            }), defer.promise;
        }
        var Item = {};
        Item.mostSold = mostSold, Item.published = published, Item.allPublished = allPublished, 
        Item.pendingPurchases = pendingPurchases, Item.related = related, Item.findById = findById, 
        Item.update = update, Item.create = create, Item.uploadImage = uploadImage, Item.comments = comments, 
        Item.addComment = addComment;
        var api = function(path) {
            return "http://" + HOST + path;
        };
        return Item;
    } ]);
}), require.config({
    baseUrl: "scripts",
    paths: {
        affix: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/affix",
        alert: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/alert",
        angular: "../../bower_components/angular/angular",
        "angular-route": "../../bower_components/angular-route/angular-route",
        "angular-translate": "../../bower_components/angular-translate/angular-translate",
        button: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/button",
        bootstrap: "../../bower_components/bootstrap/dist/js/bootstrap",
        carousel: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/carousel",
        collapse: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/collapse",
        dropdown: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/dropdown",
        "es5-shim": "../../bower_components/es5-shim/es5-shim",
        jquery: "../../bower_components/jquery/dist/jquery",
        json3: "../../bower_components/json3/lib/json3",
        modal: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/modal",
        moment: "../../bower_components/moment/min/moment-with-locales",
        popover: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/popover",
        requirejs: "../../bower_components/requirejs/require",
        scrollspy: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/scrollspy",
        tab: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/tab",
        tooltip: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/tooltip",
        transition: "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap/transition",
        "bootstrap-sass-official": "../../bower_components/bootstrap-sass-official/assets/javascripts/bootstrap",
        "angular-animate": "../../bower_components/angular-animate/angular-animate",
        "angular-bootstrap": "../../bower_components/angular-bootstrap/ui-bootstrap-tpls",
        "angular-sanitize": "../../bower_components/angular-sanitize/angular-sanitize",
        lodash: "../../bower_components/lodash/lodash",
        "angular-local-storage": "../../bower_components/angular-local-storage/dist/angular-local-storage",
        "angular-toastr": "../../bower_components/angular-toastr/dist/angular-toastr.tpls",
        "angular-jwt": "../../bower_components/angular-jwt/dist/angular-jwt",
        async: "../../bower_components/async/dist/async",
        "angular-moment": "../../bower_components/angular-moment/angular-moment",
        bootbox: "../../bower_components/bootbox.js/bootbox",
        jqBootstrapValidation: "../../bower_components/jqBootstrapValidation/dist/jqBootstrapValidation-1.3.7.min",
        "jquery.easing": "../../bower_components/jquery.easing/jquery.easing",
        ngBootbox: "../../bower_components/ngBootbox/dist/ngBootbox",
        "ng-file-upload": "../../bower_components/ng-file-upload/ng-file-upload",
        "angular-socket-io": "../../bower_components/angular-socket-io/socket",
        dropzone: "../../bower_components/dropzone/dist/min/dropzone.min",
        "ng-dropzone": "../../bower_components/ng-dropzone/dist/ng-dropzone",
        underscore: "../../bower_components/underscore/underscore",
        "angular-md5": "../../bower_components/angular-md5/angular-md5"
    },
    shim: {
        angular: {
            deps: [ "jquery" ]
        },
        "angular-route": {
            deps: [ "angular" ]
        },
        "angular-sanitize": {
            deps: [ "angular" ]
        },
        bootstrap: {
            deps: [ "jquery", "modal" ]
        },
        modal: {
            deps: [ "jquery" ]
        },
        tooltip: {
            deps: [ "jquery" ]
        },
        "angular-translate": {
            deps: [ "angular" ]
        },
        "angular-local-storage": {
            deps: [ "angular" ]
        },
        "angular-animate": {
            deps: [ "angular" ]
        },
        "angular-toastr": {
            deps: [ "angular" ]
        },
        "angular-jwt": {
            deps: [ "angular" ]
        },
        "angular-bootstrap": {
            deps: [ "angular" ]
        },
        "angular-socket-io": {
            deps: [ "angular" ]
        },
        "ng-file-upload": {
            deps: [ "angular" ]
        },
        "angular-moment": {
            deps: [ "angular", "moment" ]
        },
        ngBootbox: {
            deps: [ "bootbox", "angular", "jquery", "bootstrap" ]
        },
        "angular-md5": {
            deps: [ "angular" ]
        }
    },
    packages: []
}), paths && require.config({
    paths: paths
}), require([ "angular", "siglasApp", "controllers/IndexCtrl", "services/AuthService", "services/ItemService", "services/FavouritesService" ], function() {
    angular.bootstrap(document, [ "siglasApp" ]);
}), define("build", function() {});